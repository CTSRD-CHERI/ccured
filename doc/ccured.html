


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>

<HEAD>


<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<STYLE type="text/css">
.toc{list-style:none;}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
.part{margin:auto;text-align:center}
</STYLE>

<base target="main">
<script language="JavaScript">
<!-- Begin
function loadTop(url) {
  parent.location.href= url;
}
// -->
</script>
</HEAD>

<BODY >
<!--HEVEA command line is: /usr/bin/hevea -exec xxdate.exe ../../ccuredpp -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF chapter 1 -->



<TABLE CLASS="title">
<TR><TD></TD>
</TR></TABLE><BR>
<!--TOC chapter Introduction-->

<H1 CLASS="chapter"><A NAME="htoc1">Chapter&nbsp;1</A>&nbsp;&nbsp;Introduction</H1><!--SEC END -->

<EM>This version of the document refers to CCured 1.3.5 (based
 on CIL 1.3.5) and was last modified on 						28th									September,&nbsp;2006</EM><BR>
<BR>
CCured is a source-to-source translator for C. It analyzes the C program to
determine the smallest number of run-time checks that must be inserted in the
program to prevent all memory safety violations. The resulting program is
memory safe, meaning that it will stop rather than overrun a buffer or
scribble over memory that it shouldn't touch. Many programs can be made
memory-safe this way while losing only 10&ndash;60% run-time performance (the
performance cost is smaller for cleaner programs, and can be improved further
by holding CCured's hand on the parts of the program that it does not
understand by itself). Using CCured we have found bugs that Purify misses with
an order of magnitude smaller run-time cost.<BR>
<BR>
Small programs can be passed through CCured automatically. For medium size
and large programs you have to hold CCured's hand a bit but we tried to
explain the process clearly in this manual. We have used CCured on programs
such as <FONT COLOR=blue>sendmail</FONT>, <FONT COLOR=blue>bind</FONT>, <FONT COLOR=blue>openssl</FONT>, <FONT COLOR=blue>Apache modules</FONT>, <FONT COLOR=blue>Linux</FONT>
device drivers, and the SPEC95 benchmarks. Some of these programs are quite
big (300Kloc) and it can take a few days for somebody to &#8220;port&#8221; the program
to CCured. <BR>
<BR>
The translator itself is written in Ocaml (a dialect of ML). There is also a
Perl script, <FONT COLOR=blue>ccured</FONT>, that operates as a drop-in replacement for 'gcc', so
that software packages' existing Makefiles can be used with very minor
changes. Finally, CCured provides a library of runtime functions (including
the Boehm-Weiser conservative garbage collector).<BR>
<BR>
CCured is implemented on top of the <a target="_blank"
href="../cil/index.html">CIL framework</a>. for analysis and transformation
of C programs. This one you can use to write easily a program analysis
module that works on ANSI C code as well as on code that uses the GNU C
extensions.<BR>
<BR>
If you are anxious to see CCured in action you can try out our 
<a target="_blank" href="web/index.html">online demo</a>.<BR>
<BR>
In this manual you can find a tutorial on getting started with CCured
(Chapter&nbsp;<A HREF="#ch-tutorial">3</A>), documentation for all of the features (actually some of
the more researchy features are not yet fully documented) and step-by-step
accounts on what it took to use CCured on several example programs
(Chapter&nbsp;<A HREF="#ch-examples">6</A>). We suggest that you read the chapters in order and go to
the &#8220;Advanced CCured Features&#8221; only if you need it. The Chapter&nbsp;<A HREF="#ch-warn">10</A> (CCured
Warnings and Errors) will help you figure out if you are running into an error
that is covered by an advanced feature.<BR>
<BR>
In addition to this manual, you can find information on CCured in the
research papers that we have written. A comprehensive look at CCured
can be found in our <A HREF="/ccured/toplas.pdf">ACM TOPLAS article</A>, which
includes much of the material from the other CCured papers. You may
also be interested in the <A HREF="/ccured/popl02.pdf">POPL '02 paper</A>
describing the type system and inference algorithm, and the
<A HREF="/ccured/pldi03.pdf">&#8220;CCured in the Real World&#8221;</A> paper from PLDI '03
that discusses several advanced features that we discovered were
important for large legacy systems.<BR>
<BR>
<!--TOC section Authors-->

<H2 CLASS="section"><A NAME="htoc2">1.1</A>&nbsp;&nbsp;Authors</H2><!--SEC END -->

CCured was developed primarily by
<A HREF="mailto:necula@cs.berkeley.edu">George Necula</A>,
<A HREF="mailto:smcpeak@cs.berkeley.edu">Scott McPeak</A>,
<A HREF="mailto:weimer@cs.berkeley.edu">Westley Weimer</A>,
<A HREF="mailto:matth@cs.berkeley.edu">Matthew Harren</A> and
<A HREF="mailto:jcondit@cs.berkeley.edu">Jeremy Condit</A>. Other people helped with
various components: Shree Rahul, Raymond To, Aman Bhargava, James Lee, Winston
Liaw.<BR>
<BR>
This work was supported in part by the National Science Foundation under
Grants No. 9875171, 0085949 and 0081588, and gifts from Microsoft Research.
Any opinions, findings, and conclusions or recommendations expressed in this
material are those of the author(s) and do not necessarily reflect the views
of the National Science Foundation or the other sponsors.<BR>
<BR>
<!--TOC chapter Installation-->

<H1 CLASS="chapter"><A NAME="htoc3">Chapter&nbsp;2</A>&nbsp;&nbsp;Installation</H1><!--SEC END -->
<A NAME="ch-start"></A>
CCured works on Linux and MS Windows (Win95 operation is unreliable but Win98
and (highly recommended instead) Win2k or WinXP should work). CCured might
also work on other systems that use <FONT COLOR=blue>gcc</FONT>, but we have not tried it.<BR>
<BR>
CCured is somewhat sensitive to the version of the compiler that you are
using. More precisely, CCured is sensitive to the format of the system include
files that you are using. When you install CCured it will create slightly
modified copies of some of the system include files. These copies are created
based on some patches that we distribute with CCured. If your include files
are different from those that we used to create the patches then the CCured
installation might fail. At the moment we have tested CCured with the
following compilers:
<UL CLASS="itemize"><LI CLASS="li-itemize">
On Windows, <FONT COLOR=blue>cl</FONT> compiler version 12.00.8168, 13.00.9466, and
 13.10.3077. Run <FONT COLOR=blue>cl</FONT> with no arguments to get the compiler version. 
<LI CLASS="li-itemize">On Windows, using <FONT COLOR=blue>cygwin</FONT> and <FONT COLOR=blue>gcc</FONT> version 2.95.3, and
 versions 3.0.4 through 3.4.4.
<LI CLASS="li-itemize">On Linux, using <FONT COLOR=blue>gcc</FONT> version 2.95.3, and versions 3.2 through 3.3.5.
</UL>
 Some of the system include files that CCured depends on are really part of
the standard library. CCured has been tried with the following versions of
<FONT COLOR=blue>glibc</FONT>: <TT>glibc-2.2.3</TT>, <TT>glibc-2.2.5</TT>, <TT>glibc-2.2.93</TT>, and
<TT>glibc-2.3.2</TT>. To find out the version of your <TT>glibc</TT> you can run
<TT>/lib/libc.so.6</TT> on Linux.<BR>
<BR>
If you want to use CCured on Windows then you must get a complete
installation of <FONT COLOR=blue>cygwin</FONT> (make sure you install the development tools such
as <FONT COLOR=blue>gcc</FONT> and <FONT COLOR=blue>ld</FONT> as well and the <FONT COLOR=blue>perl</FONT> interpreter) and the <B>source-code</B> Ocaml distribution and compile it yourself using the cygwin tools
(as opposed to getting the Win32 native-code version of Ocaml). You will need
Ocaml release 3.08 or higher to build CCured. If you have not done this before
then take a look <A HREF="../ccured/setup.html">here</A>. (Don't need to worry
about <FONT COLOR=blue>cvs</FONT> and <FONT COLOR=blue>ssh</FONT> unless you will need to use the master CVS
repository for CCured.)<BR>
<BR>
<!--TOC section Get the CCured sources-->

<H2 CLASS="section"><A NAME="htoc4">2.1</A>&nbsp;&nbsp;Get the CCured sources</H2><!--SEC END -->

Download the CCured <A HREF="distrib">distribution</A> (latest version is
<A HREF="distrib/ccured-1.3.5.tar.gz"><TT>distrib/ccured-1.3.5.tar.gz</TT></A>). See the Section&nbsp;<A HREF="#sec-changes">13</A> for recent changes to the CCured distribution.<BR>
<BR>
<!--TOC section Configure and Compile CCured-->

<H2 CLASS="section"><A NAME="htoc5">2.2</A>&nbsp;&nbsp;Configure and Compile CCured</H2><!--SEC END -->

Run the following commands in the top level directory. If you are using
Windows then at least the <FONT COLOR=blue>configure</FONT> command must be run from within
<FONT COLOR=blue>bash</FONT>. 
<PRE CLASS="verbatim">
./configure
make
make quicktest (optional)
cd test
make testrun/hello INFERBOX=infer
</PRE>
 The <FONT COLOR=blue>configure</FONT> script tries to find appropriate defaults for your system.
You can control its actions by passing the following arguments:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>CC=foo</FONT> Specifies the path for the <FONT COLOR=blue>gcc</FONT> executable. By default
whichever version is in the PATH is used.
</UL>
The last line in the above sequence of commands will apply CCured (and then
run the result) on the file <FONT COLOR=blue>test/small1/hello.c</FONT>. (See the
<FONT COLOR=blue>test/Makefile</FONT> for the sequence of commands.)<BR>
<BR>
It is possible that you get a configuration error saying that certain patterns
did not match. This means that your standard include files are different than
those that we have prepared the distribution for. (See the above discussion.)
Your recourse in this case is either to install one of the versions of the
compiler that we tested CCured for or to extend the patch files so that they
match your includes. It is not hard, and it is explained in the
<A HREF="../cil/patcher.html">patcher</A> documentation.<BR>
<BR>
After running <FONT COLOR=blue>make</FONT> you have built a few executables (in the <FONT COLOR=blue>obj</FONT>
directory) and have configured the <FONT COLOR=blue>bin/ccured</FONT> Perl script. If you want to
move this script to another directory (e.g. to <FONT COLOR=blue>/usr/local/bin</FONT>) make sure
to copy the <FONT COLOR=blue>CilConfig.pm</FONT> file to the same directory. <BR>
<BR>
Now you can continue with a tutorial (Chapter&nbsp;<A HREF="#ch-tutorial">3</A>), or you can jump
ahead and find out how to run CCured (Chapter&nbsp;<A HREF="#ch-invoke">4</A>).<BR>
<BR>
<!--TOC section Test CCured-->

<H2 CLASS="section"><A NAME="htoc6">2.3</A>&nbsp;&nbsp;Test CCured</H2><!--SEC END -->

Once you have built CCured you can run 
<PRE CLASS="verbatim">
make quicktest
</PRE>
This will run a few small examples.
<BR>
<BR>
<!--TOC chapter CCured Tutorial-->

<H1 CLASS="chapter"><A NAME="htoc7">Chapter&nbsp;3</A>&nbsp;&nbsp;CCured Tutorial</H1><!--SEC END -->
<A NAME="ch-tutorial"></A><!--NAME tutorial.html-->
 <BR>
<BR>
CCured is an extension of the C programming language that distinguishes among
various kinds of pointers depending on their usage. The purpose of this
distinction is to be able to prevent improper usage of pointers and thus to
guarantee that your programs do not access memory areas they shouldn't access.
You can continue to write C programs but CCured will change them slightly so
that they are type safe. In this chapter we explain in what situations will
your program be changed and in which way. <BR>
<BR>
CCured leaves unchanged code that does not use pointers or arrays. Actually,
CCured is implemented on top of the C Intermediate Language (CIL)
infrastructure, which means that C programs are first translated into a subset
of the C language that has simple semantic rules. The following are some of
the transformations that are performed:
<UL CLASS="itemize"><LI CLASS="li-itemize">
C expressions and statements are separated into expressions (no
side-effect and no control-flow), instructions (assignments and function
calls, with one side-effect and no control-flow) and statements (the
control-flow constructs). This means that CIL serializes the side-effects and
the control-flow. 
<LI CLASS="li-itemize">All type and structure declarations are moved to the beginning of the
file. 
<LI CLASS="li-itemize">The scope of variables is resolved and local variables are renamed
accordingly. All local variables are moved to function-scope and are declared
at the beginning of the function body. The initialization for such variables
is done using explicit assignment instructions.
<LI CLASS="li-itemize">Anonymous structures and unions are given unique names. 
<LI CLASS="li-itemize">All implicit casts and conversion are expressed as explicit casts.
<LI CLASS="li-itemize">All GNU CC extensions are compiled into regular C code. 
</UL>
For a complete description of the CIL infrastructure see
<A HREF="../cil/index.html">the CIL documentation</A>.<BR>
<BR>
<!--TOC section CCured Attributes-->

<H2 CLASS="section"><A NAME="htoc8">3.1</A>&nbsp;&nbsp;CCured Attributes</H2><!--SEC END -->
<A NAME="sec-typeannot"></A>
The most significant difference between C and CCured is that CCured pays
close attention to how pointers are manipulated and it classifies pointers
into various kinds according to what you do with them. We'll discuss the
various kinds starting in the next section but before that we need to
introduce an important notation that you can use to communicate to CCured
which pointer kinds you want for your pointers. The same notation is then used
by CCured to explain in the transformed program what pointer kind if inferred
for each pointer. <BR>
<BR>
CCured uses type attributes to express the kind of pointers. Type attributes
exist in a limited form in ANSI C (i.e. the <FONT COLOR=blue>volatile</FONT>, <FONT COLOR=blue>const</FONT> and
<FONT COLOR=blue>restrict</FONT> type qualifiers) and in a richer form in the GCC dialect of C.
CCured, just like GCC, allows any attributes to be specified for types, names
of variables, functions or fields, and for structure or union declarations.
Unlike GCC, CCured has precise rules for how attributes are interpreted in a
declaration (instead GCC relies on knowing the semantics of the attribute in
order to associate it with the proper element of a declaration). The rule of
thumb is that the attribute of a pointer type is written immediately <B>following</B> the <FONT COLOR=blue>*</FONT> pointer-type constructor and the attribute of a name is
written immediately before the semicolon or the <FONT COLOR=blue>=</FONT> sign that terminates the
declaration of the name. CCured uses pointer-kinds such as <TT>SAFE</TT>,
<TT>SEQ</TT> and <TT>WILD</TT> and the corresponding attribute are formed by adding two
leading underscores. For example, in the following declaration:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * __WILD * __SEQ x __SAFE; 
</FONT></PRE>
the type of <FONT COLOR=blue>x</FONT> is declared to be a <TT>SEQ</TT>uence pointer to a <TT>WILD</TT>
pointer (just like pointer-types in C, attributes are read from
right-to-left). The <FONT COLOR=blue>__<TT>SAFE</TT></FONT> attribute in this case applies to the name
<FONT COLOR=blue>x</FONT>, which in the context of CCured means that whenever we take the address
of the variable <FONT COLOR=blue>x</FONT> we are going to obtain a <TT>SAFE</TT> pointer. The type of
such a pointer would be <FONT COLOR=blue>int * __WILD * __SEQ * __SAFE</FONT> (read as a
<TT>SAFE</TT> pointer to a <TT>SEQ</TT> pointer to a <TT>WILD</TT> pointer to an integer.).<BR>
<BR>
(The complete attribute-parsing rules for CIL are described in the
<A HREF="../cil/attributes.html">CIL manual</A>.)<BR>
<BR>
CCured is designed to work on regular C programs (i.e. without pointer-kind
attributes). One of the main features of CCured is that it will analyze your
pointer usage and will find for all pointers in your program what is the best
pointer-kind that can be ascribed to that pointer. However, you can also place
pointer-kind annotations and force CCured to use certain pointer kinds. <BR>
<BR>
<!--TOC section <TT>SAFE</TT> pointers-->

<H2 CLASS="section"><A NAME="htoc9">3.2</A>&nbsp;&nbsp;<TT>SAFE</TT> pointers</H2><!--SEC END -->

The main action in CCured concerns pointers and arrays. Pointers in C can be
assigned to l-values, dereferenced, subject to pointer arithmetic and cast to
other pointer or non-pointer types. In contrast, pointers in a typical
type-safe language (e.g. Java, Basic, ML) cannot be subject to arithmetic or
(arbitrary) casts. CCured allows all the pointer operations that C allows but
gives preferential treatment to pointers that are not subject to arithmetic or
to casts. CCured refers to such pointers as <TT>SAFE</TT> pointers.<BR>
<BR>
Consider for example this small code-fragment that computes the length of a
linked list:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct list { 
   void * car; 
   struct list * cdr; 
};

int length(struct list * l) {
  int i = 0;
  while(l) {
    l = l-&gt;cdr; 
    i ++;
  }
  return i;
}
</FONT></PRE>
<a target="_blank" href="examples/ex1.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex1.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The only pointers used in this code fragment are pointers to list cells and
they are not subject to arithmetic or to casts. In fact, this code fragment
can be transcribed literally into Java or C#. You can see in the cured code
that CCured has inferred that these pointers are indeed <TT>SAFE</TT>. <BR>
<BR>
<!--TOC paragraph Properties of <TT>SAFE</TT> pointers-->

<H5 CLASS="paragraph">Properties of <TT>SAFE</TT> pointers</H5><!--SEC END -->

 The <TT>SAFE</TT> pointers are the best kind of pointers, meaning that they incur
the least amount of run-time cost. Here is a list of the properties of
<TT>SAFE</TT> pointers:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Cannot be subject to pointer arithmetic (adding or subtracting an
integer from it).
<LI CLASS="li-itemize">Cannot be cast (except subject to stringent rules which we'll discuss
below). Note that assignment, passing actual arguments and returning are
implicit casts. 
<LI CLASS="li-itemize">Can be set to a compile-time constant equal to 0 but not to any other
integer expression.
<LI CLASS="li-itemize">Can be cast to an integer and can be subtracted from another pointer.
This is useful for comparisons.
<LI CLASS="li-itemize"><TT>SAFE</TT> pointers are represented using the standard C representation
on one word. 
<LI CLASS="li-itemize">Every time a <TT>SAFE</TT> pointer is dereferenced, a null check is inserted
before the dereference. 
</UL>
All of these restrictions are such that the following invariant holds for all
<TT>SAFE</TT> pointers:
<DIV CLASS="center"><B>A <TT>SAFE</TT> pointer to type <FONT COLOR=blue>T</FONT> is either 0 or else it points to a valid area
of memory containing an object of type <FONT COLOR=blue>T</FONT>. Furthermore, all other pointers
to the same area are also <TT>SAFE</TT> and agree on the type <FONT COLOR=blue>T</FONT> of the stored
object. 
</B></DIV><BR>
<BR>
<!--TOC subsection Safe Casts-->

<H3 CLASS="subsection"><A NAME="htoc10">3.2.1</A>&nbsp;&nbsp;Safe Casts</H3><!--SEC END -->

Casting a pointer to an integer is always allowed. CCured does actually allow
certain other casts on <TT>SAFE</TT> pointers. For example it is safe to cast a
pointer to a structure containing two integers into a pointer to integers. In
general it is safe to cast a pointer to a long structure into a pointer to a
short structure as long as the two structures agree on the types of the
elements in the overlapping portion. CCured is actually quite liberal about
these rules and will think of nested combinations of structures and arrays as
one big structure with non-structure and non-array fields. This feature is
called <EM>physical subtyping</EM>. For example, in the code shown below, all of
the four casts implicit in the assignments are safe and CCured will infer that
all pointers involved are <TT>SAFE</TT>.
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct large {
  struct small {
      int * f1;
      int * f2; 
  } a;
  int * f3;
} x;

struct small * s1 = &amp; x;
int *        * s2 = &amp; x;
struct { int *a1, *a2, *a3; } * s3 = &amp; x;
struct { int *a1, *a2[2];   } * s4 = &amp; x;
</FONT></PRE>
<a target="_blank" href="examples/ex2.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex2.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Notice that all of the <FONT COLOR=blue>s1</FONT>, <FONT COLOR=blue>s2</FONT>, <FONT COLOR=blue>s3</FONT> and <FONT COLOR=blue>s4</FONT> are aliases for the
address of <FONT COLOR=blue>x</FONT> but they agree on the type of the object pointed to.<BR>
<BR>
Following are two examples of casts that are not allowed (for <TT>SAFE</TT>
 pointers; you can see that CCured infers the <TT>WILD</TT> kind for the pointers
 involved):
<PRE CLASS="verbatim"><FONT COLOR=blue>
int y1;
int * * x1 = &amp; y1; // Cast an int * to a int * *  
int y2;
struct { int * a1, a2; } * x2 = &amp;y2;
</FONT></PRE>
<a target="_blank" href="examples/ex3.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex3.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If the first cast were allowed then by writing to <FONT COLOR=blue>y1</FONT> an arbitrary
integer we would be invalidating the assumption that <FONT COLOR=blue>x1</FONT> points to a
pointer value. The second cast is similar. <BR>
<BR>
<!--TOC subsection Union types-->

<H3 CLASS="subsection"><A NAME="htoc11">3.2.2</A>&nbsp;&nbsp;Union types</H3><!--SEC END -->
<A NAME="sec-union"></A>
Further complications arise in the case of union types. A pointer to union
type can be <TT>SAFE</TT> if it obeys all of the restrictions mentioned above and
also for all two fields of the union type, they agree on the types of the
elements in the overlap. For example, in the code below the type of <FONT COLOR=blue>x</FONT> can
be a <TT>SAFE</TT> pointer.
<PRE CLASS="verbatim"><FONT COLOR=blue>
union { 
    int *f1;
    int *f2[2];
    struct { int *a1, *a2, *a3; } f3;
} * x;

int* foo() { return x-&gt;f1; } //use x so it is analyzed.
</FONT></PRE>
<a target="_blank" href="examples/ex4.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex4.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
But in the following code the type of <FONT COLOR=blue>x</FONT> cannot possibly be <TT>SAFE</TT>
because the type of the field <FONT COLOR=blue>f3.a2</FONT> does not match the type of the
overlapping field
<FONT COLOR=blue>f2[1]</FONT> and thus <FONT COLOR=blue>x-&gt;f3.a2</FONT> could be used to write an arbitrary integer
that can later be interpreted as a pointer using the expression <FONT COLOR=blue>x-&gt;f2[1]</FONT>.
<PRE CLASS="verbatim"><FONT COLOR=blue>
union { 
    int *f1;
    int *f2[2];
    struct { int *a1, a2, *a3; } f3;
} * x;

int* foo() { return x-&gt;f1; } //use x so it is analyzed.
</FONT></PRE>
<a target="_blank" href="examples/ex5.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex5.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If your program uses a union with incompatible fields you can still obtain
<TT>SAFE</TT> pointers if you rewrite the <FONT COLOR=blue>union</FONT> to be a <FONT COLOR=blue>struct</FONT>. This will
waste some space but in some cases (in which the program requires the type to
have a given size) it might break the semantics of the program.<BR>
<BR>
Or, you can use tagged unions (Section&nbsp;<A HREF="#sec-taggedunion">9.7</A>) in which CCured will
insert run-time checks to ensure that you are not trying to read a pointer for
a field of a union when you wrote a scalar (or an incompatible pointer) using
another field.<BR>
<BR>
<!--TOC subsection <TT>SAFE</TT> Function Pointers-->

<H3 CLASS="subsection"><A NAME="htoc12">3.2.3</A>&nbsp;&nbsp;<TT>SAFE</TT> Function Pointers</H3><!--SEC END -->

There is nothing special about function pointers. They can be safe provided
that they are not cast to incompatible pointer types. A function pointer type
is compatible only with another function pointer type with the same number and
type of arguments and the same result type. <BR>
<BR>
A common problem with function pointers (and functions) in CCured is if your
program uses external function without prototypes. This makes CCured think
that the function is taking no arguments and returning an integer and every
time you use it in a different way CCured behaves as if you are casting the
function pointer (denoted implicitly by the function's name) to the type
needed in the cast. CCured will print warnings about using functions without
prototype and we recommend that you fix those problems and try CCured again.
For a discussion of what happens when you do not use your function pointer in
a clean way you should read to the end of this tutorial chapter and then read
Section&nbsp;<A HREF="#sec-funptr">9.1</A>. <BR>
<BR>
<!--TOC section Checks for <TT>SAFE</TT> Pointers-->

<H2 CLASS="section"><A NAME="htoc13">3.3</A>&nbsp;&nbsp;Checks for <TT>SAFE</TT> Pointers</H2><!--SEC END -->

As we mentioned above, every time a <TT>SAFE</TT> pointer is dereferenced it must be
checked whether it is null or not. We know from the invariant for <TT>SAFE</TT>
pointers that non-null pointers can be dereferenced and we can count that the
value read through them has the type given by the pointer type. <BR>
<BR>
A null check appears in the output of CCured as a call to the function
<FONT COLOR=blue>CHECK_NULL</FONT>. This and other run-time checking functions used by CCured
have a name that starts with the prefix <FONT COLOR=blue>CHECK_</FONT> and are declared in the
file <A HREF="ccuredcheck.h"><TT>ccuredcheck.h</TT></A>. You will see in that file that most of these
functions are declared inline. <BR>
<BR>
Checking for null pointers is necessary not just when reading or writing
through them but also when they are used to compute the address of a subobject
of the object they point to. For example, in the following code CCured will
add a run-time check that <FONT COLOR=blue>s</FONT> is not null before computing the value of
<FONT COLOR=blue>x</FONT>. Then again there will be a check that <FONT COLOR=blue>x</FONT> is not null before
dereferencing it.
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct str  {
   int a, b;
};

int getaddr(struct str * s) { 
   int * x = &amp; (s-&gt;b);
   return *x;        
}
</FONT></PRE>
<a target="_blank" href="examples/ex6.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex6.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The first check in the code above is necessary to enforce the invariant that
<TT>SAFE</TT> pointers are either 0 or else valid pointers. Without that check the
value of <FONT COLOR=blue>x</FONT> would be 4 (on most machines) which would break the invariant
and would defeat the second null-check thus letting you dereference an invalid
pointer. <BR>
<BR>
At this point you are starting to see some of the subtleties in the design of
CCured. To ensure that we got everything right we have formalized the type
system of CCured and we proved (for a subset of CCured) that the set of
run-time checks and invariants achieve memory safety. In fact, in the first
implementation of CCured we had forgotten about the first null check in the
above example and the need for it was revealed while trying to prove that
CCured is sound. To read our formalization and see the soundness proofs take a
look at our paper <A HREF="popl02.pdf">&#8220;CCured: Type-Safe Retrofitting of
Legacy Code&#8221;</A>.<BR>
<BR>
CCured includes a simple optimizer that tries to eliminate redundant
checks and checks that cannot possibly fail (such as checking that the address
of a global variable is non-null). Currently the optimizer is fairly naive.
For example, it does not know that since <FONT COLOR=blue>s</FONT> is a non-null <TT>SAFE</TT> pointer
to <FONT COLOR=blue>struct str</FONT> then <FONT COLOR=blue>&amp;(s-&gt;b)</FONT> is guaranteed to be non-null as well, thus
the second check is not really necessary. <BR>
<BR>
Speaking of too many checks, some of the more experienced C programmers
will have noticed that our run-time checks prevent a common idiom for computing
the offset of fields in structures. The typical code for doing that is shown
below (as is defined as the macro <FONT COLOR=blue>offsetof</FONT> in many C libraries):
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct str  {
   int a, b;
};

int get_offset_of_b() {
  return (int) &amp;(((struct str*)0)-&gt;b);
}
</FONT></PRE>
<a target="_blank" href="examples/ex7.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex7.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
CCured recognizes in this specific case that you are casting the result of
the <FONT COLOR=blue>&amp;</FONT> operator to an integer, so it avoids the run-time check. <BR>
<BR>
<!--TOC section Checks for Returning Pointers-->

<H2 CLASS="section"><A NAME="htoc14">3.4</A>&nbsp;&nbsp;Checks for Returning Pointers</H2><!--SEC END -->

<B><EM>Note: Checks for returning stack pointers have been disabled
 in the current version.</EM></B> This was done because recent versions of
 gcc perform more aggressive inlining that results in false positives
 for our return-pointer checks. For more information, contact the
 CCured developers.<BR>
<BR>
One of the unsafe features of C is that the address of a local variable can
be returned from a function and later be used in a context in which the
storage for the local variable has been reused. Many C compilers try to give
warnings when they notice this happening but it is way to easy to fool them.
For example, in the code example below the function <FONT COLOR=blue>bar</FONT> does return the
address of its <FONT COLOR=blue>local</FONT> variable and this is going to be missed by most
compilers.
<PRE CLASS="verbatim"><FONT COLOR=blue>
int *foo(int *in) { // in is a stack address
   *in = 5;
   return in;     
}
int* bar() {
  int local = 0;
  return foo(&amp;local);
}
</FONT></PRE>
<a target="_blank" href="examples/ex8.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex8.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Each function that returns a pointer value will have one call to
<FONT COLOR=blue>CHECK_RETURNPTR</FONT> that will verify that the pointer value is not in the
stack frame of the function that is returning. Note that the pointer value can
be 0, or can be a pointer to a heap area or to a cooler stack frame (a
caller stack frame). <BR>
<BR>
There is one complication with the return checks. There is no portable way to
implement the check that a pointer is in the frame of the returning function.
Currently CCured checks that the pointer value is not in the 1Mbyte range
that starts at the current address of the frame pointer going towards lower
addresses. However, getting the address of the frame pointer is somewhat
unreliable in the context of heavy optimizations. The method that seems to
work best is to introduce a volatile local variable whose address is then the
address of the stack frame. Since the address of the variable is taken and the
variable appears first in the local declarations, it appears that both GCC and
MSVC will allocate such a variable at the highest address in the frame. <BR>
<BR>
Note that we have observed the <FONT COLOR=blue>CHECK_RETURNPTR</FONT> check to lead to spurious
failures in the case when the function returning a pointer is inlined into its
caller. For example, the code example from above the check for the return of
<FONT COLOR=blue>foo</FONT> should succeed and the one for the return of <FONT COLOR=blue>bar</FONT> should fail. If
<FONT COLOR=blue>foo</FONT> is inlined into <FONT COLOR=blue>bar</FONT> then <FONT COLOR=blue>foo</FONT>'s check will see that <FONT COLOR=blue>in</FONT> is
in the current stack frame and will generate a run-time error. This is not an
ideal situation and we are looking for a better solution.<BR>
<BR>
<!--TOC section Checks for Writing Pointers-->

<H2 CLASS="section"><A NAME="htoc15">3.5</A>&nbsp;&nbsp;Checks for Writing Pointers</H2><!--SEC END -->
<A NAME="sec-storeptr"></A>
Another possible unsoundness with addresses of local variables is when the
address of a local variable is written to a global or to the heap. In that
case the pointer value might be used later at a time when the underlying
storage is being reused by another activation frame. <BR>
<BR>
For example, in the following code fragment, both of the assignments are
checked using the <FONT COLOR=blue>CHECK_STOREPTR</FONT> run-time function. The first one is
checked because we are obviously writing to a global variable. The second one
is checked because we are writing through a pointer and thus we cannot know
for sure whether we are writing to the heap or to the stack. 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int *g;
void foo(int * *x) {
  g = *x; // Check this
 
  *x = g; // Check this  
}        
</FONT></PRE>
<a target="_blank" href="examples/ex9.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex9.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The <FONT COLOR=blue>CHECK_STOREPTR</FONT> is passed both the address we are writing to and the
pointer that is being written. This function will in fact allow writing of
stack pointers into cooler stack locations (deeper into the stack). The
function will also allow the writing of null pointers anywhere. As a special
feature, CCured will allow the writing of stack pointers that are in the stack
frame of <TT>main</TT> or at higher addresses. This is useful because the
command-line arguments and the environment strings are allocated on the stack
of the program before <TT>main</TT> is called. <BR>
<BR>
In rare occasions, we have encountered programs that do want to write the
address of locals variables into global variables. CCured provides an
easy-to-use mechanism for dealing with those situations. If you add the
attribute <FONT COLOR=blue>__HEAPIFY</FONT> to the name of a local variable, the CCured will
move that variable to the heap using dynamic memory allocation. In fact, just
one allocation is made for all <FONT COLOR=blue>__HEAPIFY</FONT> local variables in a stack
frame. Take a look at what happens in the following code fragment (do not be
fooled by the call to <FONT COLOR=blue>free</FONT>; in CCured that is only a hint to the built-in
garbage collector): 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int *g;
void foo() {
  int local __HEAPIFY = 5;
  g = &amp;local;
}
</FONT></PRE>
<a target="_blank" href="examples/ex10.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex10.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
 <!--TOC section <TT>SEQ</TT>uence Pointers-->

<H2 CLASS="section"><A NAME="htoc16">3.6</A>&nbsp;&nbsp;<TT>SEQ</TT>uence Pointers</H2><!--SEC END -->

So far we have discussed pointers for which we disallow most casts and
pointer arithmetic. In this section we will discuss another family of CCured
pointers that can be used in pointer arithmetic operations. We call these
<EM>sequence</EM> pointers and they come in two flavors: those that can only be
advanced through pointer arithmetic (called forward-sequence pointers or
<TT>FSEQ</TT>) and the regular sequence pointer that can be moved both forward and
backward (we use the kind <TT>SEQ</TT>for these pointers). The cost that the
programmer pays for using these more capable pointers is that each dereference
will be accompanied by a bounds check. <BR>
<BR>
Consider the following code fragment. The pointer <FONT COLOR=blue>x</FONT> cannot be <TT>SAFE</TT>
because it is involved in pointer arithmetic. Since we are adding a
non-constant value CCured cannot be certain that the pointer is only advancing
so it will assign the more general <TT>SEQ</TT> kind to it. 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * arith(int * x, int delta) {
   return x + delta;
}
</FONT></PRE>
<a target="_blank" href="examples/ex11.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex11.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
<!--TOC subsection Representation-->

<H3 CLASS="subsection"><A NAME="htoc17">3.6.1</A>&nbsp;&nbsp;Representation</H3><!--SEC END -->

By looking at the CCured output for the above code you will notice several
changes in the code. First, the type of the <FONT COLOR=blue>x</FONT> parameter and the name of
the function have changed as follows:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct seq_int {
   int *  __SEQ  _p ;
   struct meta_seq_int {
      void *_b ;
      void *_e ;
   } _ms ;
};
typedef struct seq_int seq_int;

int * arith_sq(seq_int p, int delta);
</FONT></PRE>
We see that CCured has created the type <FONT COLOR=blue>seq_int</FONT> (sequence pointer to an
integer). This type has two components, the regular pointer value (field
<FONT COLOR=blue>_p</FONT>) and a metadata component (the field <FONT COLOR=blue>_ms</FONT>). <EM>Metadata</EM> is the
CCured terminology for additional information that CCured is carrying with the
pointers in order to be able to check their usage. All multi-word pointers in
CCured are represented as a structure with two elements: a field <TT>_p</TT> that
stores the value of the pointer and the field <TT>_ms</TT> that stores the
metadata for the pointer. <BR>
<BR>
In the case of a <TT>SEQ</TT> pointer the metadata consists of two pointers, one
that stores the beginning of the memory area in which a pointer was created
(stored in field <FONT COLOR=blue>_b</FONT>), and the end of that memory area (in field <FONT COLOR=blue>_e</FONT>).
Such a memory area is also called a <EM>home area</EM> for a pointer. The
meta-data of the home area are generated by CCured for a pointer obtained by
allocation or by taking the address of a variable, and is passed along in an
assignment. Thus, a <TT>SEQ</TT> pointer carries with it the beginning and the end
of the home area from which it originates and these values will be used to
perform the necessary bounds checking.<BR>
<BR>
<DIV CLASS="center">
<IMG SRC="ccuredpp001.png">
</DIV><BR>
<BR>
The structures denoting fat pointers are named by adding a prefix
corresponding to the kind of fat pointer to a canonical name of the type. For
the general rules for naming types, see Section&nbsp;<A HREF="#sec-tnames">A.1</A>.<BR>
<BR>
Notice also that the name of the <FONT COLOR=blue>arith</FONT> function has changed. CCured
mangles the names of globals whose type has changed. We do this to ensure that
you are not going to be linking your CCured code with a library that, for
example, calls the <FONT COLOR=blue>arith</FONT> function with a regular pointer argument. The
mangling is always in the form of a suffix separated from the main name by an
underscore. The suffix is constructed as a sequence of letters, each one
signifying a certain kind of pointer (<FONT COLOR=blue>q</FONT> stands for <TT>SEQ</TT>). The order of
the letters corresponds to the order in which the pointer type is encountered
in a depth-first in-order traversal of the structure of the global's type
(for functions we scan the result type first and then the arguments in order;
however, we do not scan structures and unions). For the general rules on
global name mangling, see Section&nbsp;<A HREF="#sec-mangling">8.1</A>.<BR>
<BR>
Sequence pointers have an additional capability: they can be set to any
integer value, not just to 0 as in the case of <TT>SAFE</TT> pointers. We allow this
because the sequence pointers have the additional fields that can be encoded to
identify an integer disguised as a pointer. In particular both the <FONT COLOR=blue>_b</FONT> and
the <FONT COLOR=blue>_e</FONT> fields of a <TT>SEQ</TT> pointer are null in the case when the pointer
is actually an integer. The example below uses this capability of sequence
pointers. Notice that null pointers (those in which all three fields are 0)
are just a special case in which a <TT>SEQ</TT> pointer is actually an integer. 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * __SEQ getSeq() {
    return 5;
}
</FONT></PRE>
<a target="_blank" href="examples/ex12.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex12.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
<!--TOC subsection Invariants for SEQ pointers-->

<H3 CLASS="subsection"><A NAME="htoc18">3.6.2</A>&nbsp;&nbsp;Invariants for SEQ pointers</H3><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
Cannot be cast (except subject to stringent rules which we'll discuss
below). Note that assignment, passing actual arguments and returning are
implicit casts. 
<LI CLASS="li-itemize">Can be subject to pointer arithmetic (adding or subtracting an
integer from it).
<LI CLASS="li-itemize">Can be set to any integer value.
<LI CLASS="li-itemize">Can be cast to an integer and can be subtracted from another pointer.
This is useful for comparisons.
<LI CLASS="li-itemize"><TT>SEQ</TT> pointers are represented using three words. 
<LI CLASS="li-itemize">Every time a <TT>SEQ</TT> pointer is dereferenced, both a check that the
pointer is not null or a disguised integer and a bounds check are inserted.
</UL>
When sequence pointers are assigned, passed as arguments or as return values,
written or read from memory they carry their metadata unchanged. Same happens
when they are subject to casts or to pointer arithmetic. (Pointer arithmetic
affects only the <FONT COLOR=blue>_p</FONT> component of the sequence pointer but not the home
area.) There are two operations in which <TT>SEQ</TT> pointers &#8220;are born&#8221;: by
using the name of a global or local array (possibly embedded inside other
structures or arrays) or by dynamic memory allocation. It is at that time that
the metadata for the <TT>SEQ</TT> pointers is computed and initialized, in the case
of an array based on the array length. and in the case of memory allocation
based on the allocated size. Take a look at the code CCured generates to
initialize the metadata for the <FONT COLOR=blue>r1</FONT> and <FONT COLOR=blue>r2</FONT> pointers in the code below,
both for the case of the memory allocation and for using the name of an array.
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern void* malloc(unsigned int);
int foo(int x) {
  int *p, *r1, *r2;
  int a[8];

  r1 = (int*)malloc(16);
  r2 = a;
  p = r1; 
  p = r2;
  return *(p + x); // Force p to be SEQ
}
</FONT></PRE>
<a target="_blank" href="examples/ex13.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex13.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Whenever a pointer is subject to pointer arithmetic CCured will force that
pointer to be <TT>SEQ</TT>. This means that the pointer should come accompanied by
appropriate metadata. Thus the CCured inferencer will propagate the request
for the metadata <B>backwards</B> through the data flow, across function calls
and returns, to all the places where the pointer might be produced. For
example in the previous example <FONT COLOR=blue>p</FONT> is subject to pointer arithmetic so it
must be <TT>SEQ</TT>. But since <FONT COLOR=blue>p</FONT> is assigned from <FONT COLOR=blue>r1</FONT> and <FONT COLOR=blue>r2</FONT>, they too
must be <TT>SEQ</TT>. Finally the request reaches the name of the array <FONT COLOR=blue>a</FONT> (in
which case the metadata for a <TT>SEQ</TT> pointer is computed based on the length of
<FONT COLOR=blue>a</FONT>) and also the <FONT COLOR=blue>malloc</FONT> (in which case the metadata is computed based
on the allocated length). <BR>
<BR>
<!--TOC subsection Run-time checks for SEQ pointers-->

<H3 CLASS="subsection"><A NAME="htoc19">3.6.3</A>&nbsp;&nbsp;Run-time checks for SEQ pointers</H3><!--SEC END -->
<A NAME="sec-checkseq"></A>
One of the design decisions for <TT>SEQ</TT> pointers was whether to check that the
pointer remains within bounds after each arithmetic operation, or to allow
pointer to go temporarily out of bounds and do the check when you use the
pointer. We chose to check the dereferences because the C standard actually
allows pointers to point outside their home area. <BR>
<BR>
Sometimes a pointer is subject to arithmetic and then assigned to a pointer
that is used only for reading and writing. The latter pointer will be inferred
to be <TT>SAFE</TT> and the <TT>SEQ</TT> pointer will be converted to a <TT>SAFE</TT> pointer.
<PRE CLASS="verbatim"><FONT COLOR=blue>
int foo(int x) {
  int *p, *safe;
  p += x; // p is SEQ
  safe = p; // safe is SAFE
  return *safe;
}
</FONT></PRE>
<a target="_blank" href="examples/ex14.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex14.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
To convert a <TT>SEQ</TT> pointer to <TT>SAFE</TT> we must check that it is in
within the bounds of the home area or is null. Note that even though a <TT>SEQ</TT>
pointer might contain arbitrary integers, a <TT>SAFE</TT> pointer can only contain
the integer 0. In the above code you can observe a run-time call to
<FONT COLOR=blue>CHECK_xxx</FONT> that performs the bounds checking. The same check is used when
reading or writing through a <TT>SEQ</TT> pointer, as in the example below. 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int addAll(int * p, int len, int stride) {
    int sum = 0, i;
    for(; len &gt;= 0; len -= stride, p += stride) {
       sum += *p;
    }
    return sum;
}
</FONT></PRE>
<a target="_blank" href="examples/ex15.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex15.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Just like for <TT>SAFE</TT> pointers we must check the pointer validity when taking
the address of a field of an object pointed to by a <TT>SEQ</TT> pointer:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct elem {
   int f1, f2;
   int nested[8];
};

int foo(struct elem *array, int len) {
  int * pnested, * pnestedseq;
  array += len; // Make array a SEQ
  pnested = &amp; array-&gt;f2; // A bounds check here
  pnestedseq = &amp; array-&gt;nested[2]; // A bounds check here
  pnestedseq += len; // pnestedseq is a SEQ
}   
</FONT></PRE>
<a target="_blank" href="examples/ex16.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex16.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
In the example above <FONT COLOR=blue>array</FONT> is a <TT>SEQ</TT> pointer pointing to elements of
type <FONT COLOR=blue>struct elem</FONT>. As long as we only do pointer arithmetic on <FONT COLOR=blue>array</FONT> no
bounds checking is necessary. However, when we take the address of the field
<FONT COLOR=blue>f2</FONT> we will obtain a <TT>SAFE</TT> pointer and thus we must be sure that
<FONT COLOR=blue>array</FONT>is within the bounds of its home area. Another interesting situation
occurs on the next line in the above example where we obtain a <TT>SEQ</TT> pointer
with a home included within the home of <FONT COLOR=blue>array</FONT>. The home of <FONT COLOR=blue>pnestedseq</FONT>
is the <FONT COLOR=blue>nested</FONT> array within the <FONT COLOR=blue>struct elem</FONT> element pointed to by
<FONT COLOR=blue>array</FONT>. But again we must know that <FONT COLOR=blue>array</FONT> is within bounds. <BR>
<BR>
Just like for <TT>SAFE</TT> pointers we must check for stack addresses when a
<TT>SEQ</TT> pointer is written through a pointer or returned from a function. But
in this case the check is more subtle. To see why consider the following
program fragment:
<PRE CLASS="verbatim"><FONT COLOR=blue>
// return a fat pointer to my own local, but using arithmetic
// to hide the fact that it's mine
int * sneaky()
{
  int local[2];
  int *x = local;
  x += 200;            // push x (apparently) above my frame
  return x;
}
int main() {
  int *plocal = sneaky();
  return *(plocal - 200); // Back into its (vanished) home
  
}
</FONT></PRE>
<a target="_blank" href="examples/ex17.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex17.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If we were to check that the <FONT COLOR=blue>_p</FONT> field is not a local stack address we
would fail to notice the unsoundness in the above example. For this reason the
stack checks are performed using the <FONT COLOR=blue>_b</FONT> pointer. Another to do so is that
if the <FONT COLOR=blue>_b</FONT> pointer is null then we are returning an integer disguised as a
pointer and we should not care whether it is equal to a stack address (since
such a pointer cannot ever be dereferenced). <BR>
<BR>
The bounds checks in CCured are more involved that in languages like Java
where all of the elements have the same size. It turns out that we can write
faster checks if we maintain the invariant that each <TT>FSEQ</TT> or <TT>SEQ</TT> pointer
points to an area that contains a whole number of elements of the given type.
Consider the following code fragment:
<PRE CLASS="verbatim"><FONT COLOR=blue>
char buffer[17]; 
int main() {
  long * __FSEQ p = buffer; // This will fail
  return p[2];
}
</FONT></PRE>
<a target="_blank" href="examples/ex18.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex18.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
This will fail with an alignment check because there is no room for a whole
number of <FONT COLOR=blue>long</FONT> elements in <FONT COLOR=blue>buffer</FONT>.
<PRE CLASS="verbatim">
Failure ALIGNSEQ at ./foo.c:3: main(): Creating an unaligned sequence
</PRE>
 In general, this check can appear as part of a cast from a sequence pointer
to a sequence pointer of a wider base type. However, the above program is
perfectly fine. We can do several things:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Ignore this run-time error (see Section&nbsp;<A HREF="#sec-errorhandle">4.2</A>)
<LI CLASS="li-itemize">Tell CCured to allow partial elements in sequences and to use slightly
more expensive run-time checks. You must pass the
<FONT COLOR=blue>&ndash;allowPartialElementsInSeuqnece</FONT> to CCured to achieve this (see
Chapter&nbsp;<A HREF="#ch-invoke">4</A>). 
<LI CLASS="li-itemize">Change the code to align the sequence. You can use the build-in function
<TT>__align_seq</TT> to &#8220;chop&#8221; the accessible area of a sequence pointer have
a length that is multiple of a certain size. You must use this function
<EM>before</EM> you cast the sequence pointer:
<PRE CLASS="verbatim"><FONT COLOR=blue>
char buffer[17]; 
int main() {
  // This will make p appear to point toexactly 6 longs
  long * __FSEQ p = __align_seq(buffer, sizeof(*p)); 
  return p[2];
}
</FONT></PRE>
<a target="_blank" href="examples/ex19.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex19.cured.c">CCured output</A>
for this code fragment</UL>
<!--TOC subsection Casts allowed for <TT>SEQ</TT> pointers-->

<H3 CLASS="subsection"><A NAME="htoc20">3.6.4</A>&nbsp;&nbsp;Casts allowed for <TT>SEQ</TT> pointers</H3><!--SEC END -->
. 
It is always possible to cast
a <TT>SEQ</TT> pointer to a <TT>SAFE</TT> pointer with the same underlying type. A
bounds-check is performed in that case. It is also possible to cast a <TT>SAFE</TT>
pointer to a <TT>SEQ</TT> pointer, in which case the home area of the new pointer is
the memory range occupied by one element of the <TT>SAFE</TT> pointer type. <BR>
<BR>
Casting of <TT>SEQ</TT> pointers is only allowed when the underlying types are the
same or very closely related. We cannot freely allow the casting of <TT>SEQ</TT>
pointers using the physical subtyping rules that we used for <TT>SAFE</TT> pointers.
To see why consider the following program:
<PRE CLASS="verbatim"><FONT COLOR=blue>[--noSplitPointers]
struct wide {
   int i;
   int *p;
};
void foo(struct wide * __SEQ x) {
  int * __SEQ pi = (int*)wide;
  *(pi + 1) = 5;
}
</FONT></PRE>
Notice that the cast has the property that it casts a pointer to a large
structure to a pointer to smaller structure that is compatible with the large
one. If we were to allow the above program then we would be able to write an
arbitrary integer in a place where the pointer-type field <FONT COLOR=blue>p</FONT> is stored. The
rule for <TT>SEQ</TT> pointers is that an infinite-tiling of the two types being
cast is compatible. This allows us to cast a pointer to an array into a
pointer to array elements (a very useful operation when working with
multi-dimensional arrays): 
<PRE CLASS="verbatim"><FONT COLOR=blue>
double a[8][8];
int zero() {
  double * pa = a;
  for(int i=0; i&lt;sizeof(a)/sizeof(double); i++) {
     * pa ++ = 0.0;
  }
}
</FONT></PRE>
<a target="_blank" href="examples/ex20.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex20.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
<!--TOC section <TT>FSEQ</TT> Pointers-->

<H2 CLASS="section"><A NAME="htoc21">3.7</A>&nbsp;&nbsp;<TT>FSEQ</TT> Pointers</H2><!--SEC END -->

We observed in our experiments that most <TT>SEQ</TT> pointers only move forward.
Thus the lower-bound check is not needed and also the <FONT COLOR=blue>_b</FONT> field of the
<TT>SEQ</TT> pointer is also not needed. To capture this common case CCured is
using the <TT>FSEQ</TT> pointer kind (forward sequence). The <TT>FSEQ</TT> pointer is
very similar to the <TT>SEQ</TT> pointer with a few exceptions. <BR>
<BR>
Consider the following example:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int addAll(int * p, int len) {
    int sum = 0, i;
    for(; len &gt;= 0; len --, p ++) {
       sum += *p;
    }
    return sum;
}
</FONT></PRE>
<a target="_blank" href="examples/ex21.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex21.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
A <TT>FSEQ</TT> pointer is represented as a two-word structure with just the
<FONT COLOR=blue>_p</FONT> (actual pointer value) and <FONT COLOR=blue>_ms._e</FONT> (end of the home area) fields:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct meta_fseqp_int {
   void *_e ;
};
struct fseqp_int {
   int *  __FSEQ  _p ;
   struct meta_fseqp_int _ms ;
};

typedef struct fseqp_int fseqp_int;

int addAll_f(int *  __FSEQ  p, void *p_ms_e , int len);
</FONT></PRE><BR>
<BR>
<DIV CLASS="center">
<IMG SRC="ccuredpp002.png">
</DIV><BR>
<BR>
A <TT>FSEQ</TT> pointer can also encode an integer, in which case the <FONT COLOR=blue>_e</FONT> field
is null. <BR>
<BR>
A <TT>FSEQ</TT> pointer with a non-null <FONT COLOR=blue>_e</FONT> field points always to an address
that is above or equal to the beginning of the home area. However, it might be
beyond the end of the home area, and that is why a <TT>FSEQ</TT> pointer requires an
upper-bound check whenever it is used (see the CCured output for the above
example). <BR>
<BR>
When doing stack checks for the <TT>FSEQ</TT> pointer we use the value of the
<FONT COLOR=blue>_e</FONT> field. <BR>
<BR>
However, we must check for each arithmetic operation on <TT>FSEQ</TT> pointers
whether it is advancing the pointer or not. This is done using the
<FONT COLOR=blue>CHECK_ADVANCE</FONT> run-time function. Notice that just because we add 1 to a
pointer it does not mean that we are advancing it. We might be trying to
overflow the addition and to break the invariant.<BR>
<BR>
What remains to be said about <TT>FSEQ</TT> pointer is how does CCured infer that a
pointer is <TT>FSEQ</TT> as opposed to <TT>SEQ</TT>. CCured looks at all arithmetic
operations and if we always adding a positive constant to a pointer then
CCured will infer that pointer to be <TT>FSEQ</TT>. Another useful heuristic that
CCured uses is that pointer arithmetic expressed using the array indexing
notation is taken as an indication that we are advancing the pointer:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int addAll(int * p, int len) {
    int sum = 0, i;
    for(i=0; i&lt;len; i++) {
       sum += p[i];
    }
    return sum;
}
</FONT></PRE>
<a target="_blank" href="examples/ex22.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex22.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Finally, <TT>FSEQ</TT> pointers can be cast to and from <TT>SAFE</TT> pointers using the
same rules that we discussed for <TT>SEQ</TT> pointers. <TT>FSEQ</TT> pointers can also be
cast to and from <TT>SEQ</TT> pointers. When casting a <TT>SEQ</TT> pointer into a <TT>FSEQ</TT>
pointer we must perform a lower-bound check. When casting a <TT>FSEQ</TT> pointer
into a <TT>SEQ</TT> pointer we consider that the home area starts at the place where
the pointer is pointing (provided that the pointer is not encoding an integer
and is within bounds). Note however that such a cast will never occur in a
program without pointer-kind annotations. The CCured inferencer will instead
prefer to propagate the constraint that all pointers which are assigned to
<TT>SEQ</TT> pointer must themselves be <TT>SEQ</TT> pointers and thus have a valid
<FONT COLOR=blue>_b</FONT> field. <BR>
<BR>
<!--TOC subsection Arrays of unspecified length-->

<H3 CLASS="subsection"><A NAME="htoc22">3.7.1</A>&nbsp;&nbsp;Arrays of unspecified length</H3><!--SEC END -->

We saw that a <TT>SEQ</TT> pointer obtains its metadata from the length present in
the array type from which they originate. But occasionally it is useful to
have arrays with either unspecified length or with a zero-length. Consider the
following code, in which the <FONT COLOR=blue>struct open</FONT> is open-ended, that is the number
of integer pointers contained in the <FONT COLOR=blue>rest</FONT> array field is determined at the
allocation time (in this case 4):
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct open {
  int   count;
  int * rest[0];
};
extern void* malloc(unsigned int);
int main() {

 struct open *p = (struct open*)malloc(20);
 return p-&gt;rest[5];
}
</FONT></PRE>
<a target="_blank" href="examples/ex23.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex23.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
CCured supports this paradigm and computes the size of the <FONT COLOR=blue>rest</FONT> field at
the time of the allocation. Then CCured will turn the array <FONT COLOR=blue>rest</FONT> into a
<B>sized</B> array, which is essentially a structure with two fields: a field
<FONT COLOR=blue>_size</FONT> which stores the size of the array and a second field <FONT COLOR=blue>_array</FONT>
which contains the array itself:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct _sized_a_char {
   unsigned int _size ;
   char (  __SIZED  _array)[20] ;
};
</FONT></PRE>
Sized arrays are very similar to the Java arrays in that they store their
length in the first word of the data structure. When a <TT>SEQ</TT> pointer is
created from such an array the metadata is computed based on the stored size. <BR>
<BR>
There is one more situation in which CCured will automatically infer that an
array must be sized. That is when the array is declared external and without a
length:
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern a[];
int main() {
    return a[3];
}
</FONT></PRE>
<a target="_blank" href="examples/ex24.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex24.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Additionally, the programmer can request that an array be represented in sized
form by using the <FONT COLOR=blue>__SIZED</FONT> attribute <B>on the array name</B>:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int *a [8] __SIZED;
</FONT></PRE>
<a target="_blank" href="examples/ex25.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex25.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Note that CCured does not support the allocation of sequences of arrays of
structures with open arrays. For example, the following code will produce a
warning and will allocate a sequence of <FONT COLOR=blue>struct open</FONT> elements each with a
zero-length <FONT COLOR=blue>rest</FONT> field!
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct open {
  int   count;
  int * rest[0];
};
extern void* malloc(unsigned int);
int main() {

 struct open *p = (struct open*)malloc(20);
 p ++; // Make p FSEQ
 return p-&gt;rest[5];
}
</FONT></PRE>
<a target="_blank" href="examples/ex26.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex26.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
You might have noticed in the previous example that when reading from a
<TT>SEQ</TT> pointer, CCured will allow the reading of the byte immediately
following the array. This &#8220;feature&#8221; is part of our current mechanism for
handling null-terminated strings, in which case the terminal null character
can be read but not written, as discussed in the next example. <BR>
<BR>
 <!--TOC section <TT>WILD</TT> Pointers-->

<H2 CLASS="section"><A NAME="htoc23">3.8</A>&nbsp;&nbsp;<TT>WILD</TT> Pointers</H2><!--SEC END -->

The pointer kinds we have seen so far can be dereferenced and can be subject
to pointer arithmetic but can only be cast in very restrictive ways. Therefore
we cannot really hope to be able to annotate all existing C programs with
kinds like <TT>SAFE</TT>, <TT>SEQ</TT> and <TT>FSEQ</TT>. We also need a pointer
kind that can also be cast to any other type. The <TT>WILD</TT> pointer kind plays
this role. Looking back at the kinds of pointers we have introduced so far we
observe that the most restrictive kind of pointer, the <TT>SAFE</TT> pointer, is
also the cheapest to use. It requires only one word for storage and only a
null check for dereference; just like Java references. Then as we add more
capabilities we also increase the cost of the pointer. The <TT>FSEQ</TT> pointers
have all the capabilities of <TT>SAFE</TT> pointers but can also move forward. The
additional cost is an extra word required for the storage of the end of the
valid range and an upped-bound check required before dereference. The <TT>SEQ</TT>
pointers have the additional capability of moving backwards and the additional
cost of one more storage word and a lower-bound check before dereference.
Keeping with this trend it is to be expected that <TT>WILD</TT> pointers are going
to be even more costly. As we shall see, the <TT>WILD</TT> pointers must be able not
only to find the bounds of the range in which they are supposed to navigate but
they must also know for each word in that range whether it is a pointer or a
non-pointer. The previously-introduced kinds of pointers did not need to
maintain that information at run-time because the lack of casts allowed the
compiler to keep track of such information statically.<BR>
<BR>
One way to think of the CCured pointer-kind inferencer is as an analysis that
classifies your pointers into two big categories: those for which the static
type is an accurate description of the values pointed to; and those for which
it is not. We refer to the first category as the <EM>statically-typed</EM>
pointers and they consist of the pointers discussed so far: <TT>SAFE</TT>, <TT>SEQ</TT>,
and <TT>FSEQ</TT>. The second category consist of the <EM>dynamically-typed</EM> pointers and include the <TT>WILD</TT> pointers. Since the
compiler cannot verify statically the type of the values the <TT>WILD</TT> pointers
point to, then CCured inserts code to maintain at run-time information about
the contents of a memory range pointed to by <TT>WILD</TT>pointers. <BR>
<BR>
Consider the following example, in which <FONT COLOR=blue>a</FONT> (of type <FONT COLOR=blue>int
*</FONT>) is cast to type <FONT COLOR=blue>int * *</FONT>:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int foo(int * a) {
   int * * g = (int * *)a; // Bad cast
   return 0;
}
</FONT></PRE>
<a target="_blank" href="examples/ex27.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex27.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
There are several new things in the CCured version of the above
program fragment. We start with the type of <FONT COLOR=blue>a</FONT>: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct meta_wildp_int {
   void *_b ;
}   ;
struct wildp_int {
   int *  __WILD  _p ;
   struct meta_wildp_int _ms ;
}   ;
typedef struct wildp_int wildp_int;

int foo_w(wildp_int __WILD a);
</FONT></PRE><BR>
<BR>
<DIV CLASS="center">
<IMG SRC="ccuredpp003.png">
</DIV><BR>
<BR>
A <TT>WILD</TT> pointer is represented as a two-word structure. As usual the
<FONT COLOR=blue>_p</FONT> field stores the actual pointer and just like for <TT>SEQ</TT> pointers the
<FONT COLOR=blue>_b</FONT> field stores the beginning of the pointer's home area. The major
difference in the representation of <TT>WILD</TT> pointers is the layout of the home
area. Since we must keep track at run-time what is stored in each location in
a dynamically-typed area we will store a bitmap (one bit per word) at the end
of the home area. And just like for sized arrays the word immediately before
the home area stores the size in words of the home area. Such an example is
shown in the code below where the address of the local variable <FONT COLOR=blue>h</FONT> is the
home for the pointer <FONT COLOR=blue>p</FONT>.
<PRE CLASS="verbatim"><FONT COLOR=blue>
void foo() {
   int * h = 0;
   int * p = (int *) &amp;h;
   return 0;
}
</FONT></PRE>
<a target="_blank" href="examples/ex28.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex28.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The type of <FONT COLOR=blue>h</FONT> is:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct _tagged_wildp_int {
   unsigned int _len ;
   wildp_int    _data  __attribute__((__packed__)) ;
   int _tags[(sizeof(wildp_int    ) + 127U) &gt;&gt; 7]  __attribute__((__packed__)) ;
};
typedef struct _tagged_wildp_int _tagged_wildp_int;
</FONT></PRE>
The <FONT COLOR=blue>_data</FONT> field in a tagged area stores the actual data, which in this
case is a <TT>WILD</TT> pointer. The <FONT COLOR=blue>_tags</FONT> field contains one word for every 32
words of data. Each bit in the tags is 1 if the corresponding word in the data
field stores the <FONT COLOR=blue>_b</FONT> field of a <TT>WILD</TT> pointer, and 0 otherwise (if it
contains an integer or the <FONT COLOR=blue>_p</FONT> field of a <TT>WILD</TT> pointer or equivalently
a value that is not CCured metadata). To maintain this invariant we
must update the tag bits every time we perform a memory write. When we write an
integer into a word we clear the bit corresponding to that word. When we write
a <TT>WILD</TT> pointer then we set the two bits corresponding to the two words to 0
and 1 respectively. When we read an integer we do not need to check tags. When
we read a <TT>WILD</TT> pointer then we check that the tag bit for the word from
which we'll read the <FONT COLOR=blue>_b</FONT> component has a set tag bit. If this is not true
then we check whether the <FONT COLOR=blue>_b</FONT> component that we'll read is 0. In this
latter case we would be reading a pointer that cannot be used for memory
dereference anyway. This latter situation occurs when we read a pointer from
an area that has been initialized with zeros. <BR>
<BR>
Notice that this scheme ensures that we will never interpret a word in a
tagged area as a <FONT COLOR=blue>_b</FONT> field except if it was last written with a contents
of a <FONT COLOR=blue>_b</FONT> field. This however does not prevent code that overwrites the
<FONT COLOR=blue>_p</FONT> fields from running (except that the resulting pointers might not be
later usable). <BR>
<BR>
The following run-time support functions are used in conjunction with <TT>WILD</TT>
pointers:
<PRE CLASS="verbatim"><FONT COLOR=blue>
/* Fetch the size (in words) of the tagged area pointed to by a WILD pointer.
   This also checks that the pointer has a valid _b field */
unsigned int 
CHECK_FETCHLENGTH(void *_p,          /* The _p field of the pointer */
                  void *_b);         /* The _b field */

/* Do bounds checking for WILD pointers */
CHECK_BOUNDS_LEN(void *_b,           
                 unsigned int bwords,/* Result of FETCHLENGTH */
                 void *_p, 
                 unsigned int plen); /* The size in bytes of the memory area
                                        being accessed */

/* Clear the tags for a memory range. This is called before writing a scalar
   or a structure containing at least one scalar into a tagged area. */
CHECK_ZEROTAGS(void *base,            /* The base of the tagged area */
               unsigned int nrwords,  /* Number of data words in the area */
               void *start,           /* Start of the memory range for which 
                                         to clear the tags */
               unsigned int size);   /* Size in bytes of the memory range for
                                        which to clear the tags */

/* Set the tags for writing a pointer. This also checks that we are not
   writing a stack pointer. This is called for EACH pointer in a structure
   that is being written. */
CHECK_WILDPOINTERWRITE(void *base,    /* The base of the tagged area in which
                                         we write */
                       unsigned int nrwords, /* Number of data words in the 
                                                area */
                       void **where, /* The address in the tagged area where 
                                        we are about to write */
                       void *_b,     /* The _b field of the written pointer */
                       void *_p);    /* The _p field of the written pointer */


/* Check that the pointer we are about to read has a _b field that has not
been tampered with */
CHECK_WILDPOINTERREAD(void *base,    /* The base of the tagged area in which
                                         we write */
                       unsigned int nrwords, /* Number of data words in the 
                                                area */
                       void **where, /* The address in the tagged area where 
                                        we are about to write */
                       void *_b,     /* The _b field of the written pointer */
                       void *_p);    /* The _p field of the written pointer */
</FONT></PRE>
The code fragment below uses these runtime functions:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct s {
  int  i; // Some integer
  int *q; // And some pointer
} g, * __WILD pg = &amp;g;

int foo(struct s * __WILD x) {
   // Read an integer from x. 
   // Must do bounds check
   int read = x-&gt;i;
   // Read a pointer from x
   // Must do bounds check and check that the _b field is valid
   int * ptr = x-&gt;q;
   // Write an integer
   x-&gt;i = 5;
   // Write a pointer
   x-&gt;q = (int*)6;
   // Read and write the whole struct
   g = *x;     
}
</FONT></PRE>
<a target="_blank" href="examples/ex29.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex29.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
A <TT>WILD</TT> pointer can be used in a very flexible way but there are some
constraints. Like any of the other pointers that can be subject to pointer
arithmetic the <TT>WILD</TT> pointer carries with it the identity of the home area
and can be used to access only that area. But most importantly a <TT>WILD</TT>
pointer can only be case to and from another <TT>WILD</TT> pointer and can only
point to scalars or other <TT>WILD</TT> pointers. Essentially this means that the
dynamically-typed universe can touch the statically-typed universe in only a
single way: a <TT>WILD</TT> pointer can be stored in a statically-typed area. <BR>
<BR>
The following pointer kind is not legal &#8220;<FONT COLOR=blue>int * <TT>SAFE</TT> * <TT>WILD</TT></FONT>&#8221;. To
see why consider the (ill-typed) code below:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int foo(int * __SAFE * __WILD x) {
  int * __SAFE y;
  *(int __WILD *)x = 5; // Ok since x can be cast to another __WILD pointer
  y = * x; // Ok
  return *y; // Ok since y is SAFE and non-null
}
</FONT></PRE>
Essentially we cannot count on the accuracy of the types pointed to by
<TT>WILD</TT> pointers. For this reason we can only allow <TT>WILD</TT> pointers to point
to scalars or other <TT>WILD</TT> pointers. So, in the above example CCured does not
recognize <FONT COLOR=blue>x</FONT> as a valid type. <BR>
<BR>
For the same reason we cannot cast between <TT>WILD</TT> pointers and non-<TT>WILD</TT>
pointers. <BR>
<BR>
<!--TOC section Split Metadata-->

<H2 CLASS="section"><A NAME="htoc24">3.9</A>&nbsp;&nbsp;Split Metadata</H2><!--SEC END -->
<A NAME="sec-splitmeta"></A>
In the previous examples pointers with metadata are represented as
structures. It turns out that <TT>gcc</TT> or the Microsoft Visual C compiler
are not very effective at optimizing code that uses many variables with
structured types. Thus, CCured has the ability to split such variables into
several single-word variables. Consider again one of the examples from before: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * arith(int * x, int delta) {
   return x + delta;
}
</FONT></PRE>
<a target="_blank" href="examples/ex30.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex30.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Notice that <TT>x</TT> becomes split into three variables: <TT>x</TT> (for the <TT>_p</TT>
field, or the regular pointer value), and <TT>x_b</TT> and <TT>x_e</TT> for the
beginning and end metadata fields. Notice also that function parameters and
arguments (but <EM>not the results</EM> are split in the same way):
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * arith_sq(int * x, void * x_b, void * x_e, int delta);
</FONT></PRE>
By default, CCured splits the metadata. You must pass the argument
<TT>&ndash;noSplitPointers</TT> to prevent it. <BR>
<BR>
<!--TOC chapter Invoking CCured-->

<H1 CLASS="chapter"><A NAME="htoc25">Chapter&nbsp;4</A>&nbsp;&nbsp;Invoking CCured</H1><!--SEC END -->
<A NAME="ch-invoke"></A>
CCured consists of several components: an Ocaml application that does the
main work, a set of Perl scripts that are used to invoke the CCured
application, and a set of header and run-time library files. <BR>
<BR>
The easiest way to use CCured is through the <FONT COLOR=blue>bin/ccured</FONT> script. This
script is intended to be used in the same context and with the same
command-options as either the <FONT COLOR=blue>gcc</FONT> compiler or the Microsoft Visual C
compiler (MSVC). This script is configured at installation time to know where
the rest of the CCured installation resides. If you move this script to
another directory you must also make a copy in the new directory of the
<FONT COLOR=blue>CilConfig.pm</FONT> file. <BR>
<BR>
Since <FONT COLOR=blue>ccured</FONT> is a drop-in replacement for <FONT COLOR=blue>gcc</FONT>, for most software
projects you can reuse the regular build-infrastructure:
<PRE CLASS="verbatim">
make mystuff CC="bin/ccured [options]"
</PRE>
 Here is the sequence of actions that the <FONT COLOR=blue>ccured</FONT> script performs:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
It recognizes among the command-line arguments those that are intended
for the pre-processor; then, for each source file (i.e. with the extension
t.c), calls the preprocessor and places the result in a file with the
extension <FONT COLOR=blue>.i</FONT> in the same directory as the source file.
<LI CLASS="li-enumerate">For every <FONT COLOR=blue>.i</FONT> file that it produces and that must be compiled (i.e.
the <FONT COLOR=blue>-E</FONT> option was not specified to require only preprocessing) <FONT COLOR=blue>ccured</FONT>
will save a copy of the file with the extension <FONT COLOR=blue>.o</FONT>, thus &#8220;fooling&#8221;
<FONT COLOR=blue>make</FONT> that the object file was actually produced. 
<LI CLASS="li-enumerate">Whenever <FONT COLOR=blue>ccured</FONT> is invoked to link <EM>into a library</EM> a number of
<FONT COLOR=blue>.o</FONT> files that are actually preprocessed sources saved in the previous
step, the CCured engine will be invoked to parse all of the files and produce
a single <FONT COLOR=blue>C</FONT> file with the same content but with names of types and
variables properly renamed. The output is then saved as the resulting library.
You should use the <FONT COLOR=blue>&ndash;mode=AR</FONT> argument to CCured if you want to pass the
remaining arguments as for the <FONT COLOR=blue>ar</FONT> utility. More details about the merging
stage that CCured used can be found <A HREF="../cil/merger.html">.</A>
<LI CLASS="li-enumerate">Finally, when <FONT COLOR=blue>ccured</FONT> is called to link <EM>into an executable</EM> a
number of object files and libraries it will separate from them those that are
actually saved sources and will merge them all in memory. The resulting file
is then subject to CCured type inference followed by the insertion of run-time
checks. Optionally, an optimizer is invoked to try to clean up some of the
inserted run-time checks. The result is saved using the full name of the
desired executable with the suffix <FONT COLOR=blue>ccured.c</FONT>. Finally this file is
preprocessed, compiled and linked using the underlying compiler. 
</OL>
Notice that by default the curing process is invoked on the whole program.
This is necessary to allow the CCured inferencer to see all the uses of your
pointers. An alternative is to annotate the include files with pointer-kind
annotation and let the inferencer do the inference within one file only. <BR>
<BR>
<!--TOC section Command-line options-->

<H2 CLASS="section"><A NAME="htoc26">4.1</A>&nbsp;&nbsp;Command-line options</H2><!--SEC END -->
<A NAME="sec-commandline"></A>
You always run CCured with the command options of <FONT COLOR=blue>gcc</FONT> (e.g., <FONT COLOR=blue>-c</FONT> to
compile only, <FONT COLOR=blue>-o</FONT> to specify the output file, etc.). Here are some common
ways to use invoke CCured:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>bin/ccured &ndash;nocure &ndash;nomerge hello1.c hello2.c -o hello.exe</FONT>
&nbsp;&nbsp;&nbsp;- Compiles and links without curing and without merging (still
uses the CIL front-end)
<LI CLASS="li-itemize"><FONT COLOR=blue>bin/ccured &ndash;nocure hello1.c hello2.c -o hello.exe</FONT>
&nbsp;&nbsp;&nbsp;-Merges using CIL, then compiles and links with <FONT COLOR=blue>gcc</FONT>
<LI CLASS="li-itemize"><FONT COLOR=blue>bin/ccured hello1.c hello2.c -o hello.exe</FONT> &nbsp;&nbsp;&nbsp;-Merges using
CIL, processes with CCured, the compiles and links with <FONT COLOR=blue>gcc</FONT>
<LI CLASS="li-itemize"><FONT COLOR=blue>bin/ccured -c hello1.c hello2.c</FONT> &nbsp;&nbsp;&nbsp;-Just put preprocessed source in the object files
<LI CLASS="li-itemize"><FONT COLOR=blue>bin/ccured hello1.o hello2.o -o hello.exe</FONT> &nbsp;&nbsp;&nbsp;-Take the
preprocessed source in the object file, merge, cure, gcc. 
<LI CLASS="li-itemize"><FONT COLOR=blue>bin/ccured &ndash;mode=AR cr hello.a hello1.o hello2.o</FONT> &nbsp;&nbsp;&nbsp;-Merge
the preprocessed source in the object files into an archive (which itself
contains source)
<LI CLASS="li-itemize"><FONT COLOR=blue>bin/ccured hello.a main.c -o hello.exe</FONT>&nbsp;&nbsp;&nbsp;-Preprocess the C
source, merge with the sources in the archive, cure and gcc. 
</UL>
Most of the command-line options that you pass to <FONT COLOR=blue>ccured</FONT> will be passed
along to the underlying preprocessor, compiler or linker. However the
<FONT COLOR=blue>ccured</FONT> script recognizes the following special options:
<UL CLASS="itemize"><LI CLASS="li-itemize">
General options
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>&ndash;save-temps</FONT>. It tells the CCured script to save the temporary files
 (including the output of CCured).
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;nocure</FONT>. It does not actually cure the code. However, it reads it
in using the CIL front-end and then it prints it out immediately. Use this in
the first phase to check that the CIL front-end works for you. 
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;mode=AR</FONT>. Invoke CCured to act as the archiver. In this case there
should be no more arguments, except those that the <FONT COLOR=blue>ar</FONT> utility would take.
This is because the <FONT COLOR=blue>ar</FONT> arguments are positional.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;mode=MSVC</FONT>. Use instead of the Microsoft Visual C compiler
(<FONT COLOR=blue>cl</FONT>). CCured and the CIL front-end know how to handle the MSVC extensions.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;leavealone=foo</FONT>. CCured will not merge and will not process the
file whose name starts with foo. Instead it will compile it as usual and will
link it in when needed. You can put in this file functions that you do not
want CCured to see (e.g., if they are really ugly and you are ashamed of
what you did!). See Section&nbsp;<A HREF="#sec-trusted">7.4</A> for details.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;stats</FONT>. Print some statistics about the inserted checks.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;stages</FONT>. Print details about the various stages.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;extrafiles=&lt;xxx&gt;</FONT>. Give the name of a text file that contains
whitespace-separated named of additional files to process (in case your
command lines are too long).
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;nomerge</FONT>. Invoke the curing process during the compilation stage,
without waiting to have the whole program.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;keepunused</FONT>. Disable the removal of apparently unused elements from
the file, such as local variables or prototypes.
</UL><BR>
<BR>
<LI CLASS="li-itemize">Inference
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>&ndash;noemitbrowser</FONT>. Do not produce the browser information (speed up
curing). 
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;browserdir=&lt;dir&gt;</FONT>. Use <FONT COLOR=blue>&lt;dir&gt;</FONT> as the name of the directory where
to store the browser information. By default it is placed in a directory whose
name is formed from the name of the executable followed by <TT>.browser</TT>. 
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;browserSourceFileSize=N</FONT>. Specify the number of statements to put
in a source file fragment. Default is 2000. Larger value means fewer source
fragments but also slower browser operation. 
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;browserNodeFileSize=N</FONT>. Specify the number of inference nodes to
put in a file. Default is 2000. Larger value means fewer
source fragments but also slower browser operation.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;emitinfer</FONT>. This means that the result of inference is also printed
in a file <FONT COLOR=blue>fooinfer.c</FONT> where <FONT COLOR=blue>foo</FONT> is the desired executable. See
Chapter&nbsp;<A HREF="#ch-graph">A</A>. It is recommended that you use the browser instead.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;emitGraphDetailLevel</FONT>. Controls how much information to put in the
infer file. Values range from 0 to 3. 
</UL><BR>
<BR>
<LI CLASS="li-itemize">Curing
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>&ndash;allowInlineAssembly</FONT>. Allow (unsound, best-effort) handling of
inline assembly.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;nogc</FONT>. Will assume that you do not use a garbage collector. In this
case the cured code will use explicit deallocation and might be unsafe.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;optimize</FONT>. Run the optimizer after curing.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;releaselib</FONT>. Use the release library (compiled with optimizations
on) 
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;noUnrefPointerChecks</FONT>. Treat as scalars those pointer variables
whose values are never used as pointers. 
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;allowPartialElementsInSequence</FONT>. Do not check that a sequence
contains a whole number of elements. If you turn this on, more programs will
cure, but the bounds checks for sequence pointers will be more expensive (see
Section&nbsp;<A HREF="#sec-checkseq">3.6.3</A>). 
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;noSplitPointers</FONT>. Do not split CCured multi-word pointers into
 single-word variables (Section&nbsp;<A HREF="#sec-splitmeta">3.9</A>).
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;alwaysStopOnError</FONT>. Generate code that always stops on error
(slightly faster).
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;failIsTerse</FONT>. Do not print source-file location on failure. This
makes your program smaller and faster.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;noPrintLn</FONT>. Turns off the printing of line-number information. This
way the errors will be referenced to the Cured file not the source file.
<LI CLASS="li-itemize"><FONT COLOR=blue>&ndash;commPrintLn</FONT>. Print line-number information as comments. This
way the errors that CCured prints at run-time and the debugging information in
the cured code refer to the cured file, not the original source, but
you can still figure out from what file this is coming.
<LI CLASS="li-itemize"><TT>&ndash;printCilAsIs</TT>. Do not attempt to simplify the program while
 printing. If this is turned on, then all loops will be printed as
 &#8220;while(1)&#8221;, as they are in the internal language.
</UL>
</UL>
For most performance you should use the options:
<PRE CLASS="verbatim">
--optimize --releaselib --alwaysStopOnError --failIsTerse
</PRE>
 All of the other options that start with <FONT COLOR=blue>&ndash;</FONT> (and are not recognized as
compiler options) are passed unmodified to the CCured Ocaml application.<BR>
<BR>
<!--TOC section Controlling error handling at run time-->

<H2 CLASS="section"><A NAME="htoc27">4.2</A>&nbsp;&nbsp;Controlling error handling at run time</H2><!--SEC END -->
<A NAME="sec-errorhandle"></A>
After you cure a program you can run it as usual. The operations of the
CCured-inserted run-time checks can be controlled with a few environment
variables when the target program is run:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>CCURED_CONTINUE_ON_ERROR</FONT>: if set and if <FONT COLOR=blue>&ndash;alwaysStopOnError</FONT>
was not used during curing, the execution will continue on error. This means
that your program might be unsafe. It might also be possible that a cascade of
check failures will be triggered.
<LI CLASS="li-itemize"><FONT COLOR=blue>CCURED_SLEEP_ON_ERROR</FONT>: if set the program goes to sleep on an
error. When it does so, it prints the process id. You can then connect to it
using <TT>gdb</TT> as follows (replace <TT>test</TT> with the name of your executable
and <TT>10343</TT> with the actual process id printed when the process goes to
sleep.):
<UL CLASS="itemize"><LI CLASS="li-itemize">
Start <TT>gdb</TT> (preferably from within Emacs)
<LI CLASS="li-itemize">Type
<PRE CLASS="verbatim">
(gdb) file test
(gdb) attach 10343
</PRE></UL><BR>
This is useful for debugging multi-threaded code or code that
is started by daemons. This has effect only if the program would actually stop
there.<BR>
<BR>
Note that this mode is most useful when you compiled the code with <TT>-g</TT> and
you did not use <TT>&ndash;releaselib</TT>. I also prefer to use <TT>-commPrintLn</TT> so
that the debugging information refers to the cured file, not the original. <BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=blue>CCURED_ERROR_HANDLERS</FONT>: if set, then its value is taken to be the
name of a text file that contains indications on how to handle various error
conditions. First, the error messages that CCured prints are like this:
<PRE CLASS="verbatim">
Failure UBOUND at hello.c:10: main(): Ubound
</PRE>
 Each message has an error name (<FONT COLOR=blue>UBOUND</FONT>), a file location (<FONT COLOR=blue>hello.c</FONT>), a
line number (<FONT COLOR=blue>10</FONT>), a function in which the error occurred (<FONT COLOR=blue>main</FONT>), and
some explanation. You can specify error handlers based on the error name and
error location. <BR>
<BR>
Each line in the error handler file must look like this:
<PRE CLASS="verbatim">
[stop|warn|sleep|ignore|//] [*|ERRNAME] at [*|FILE] : [*|LINE] : [*:FUNC]
</PRE>
 Note that you can almost copy and paste CCured error messages into this file.
<FONT COLOR=blue>stop</FONT> means that the execution stops, <FONT COLOR=blue>warn</FONT> that a warning is printed
and the execution continues, <FONT COLOR=blue>ignore</FONT> that not even a warning is printed.
<TT>//</TT> means that the rest of the line is to be ignored.
<FONT COLOR=blue>*</FONT> is a wildcard that matches anything. Except for the first two elements,
any suffix of the line can be missing. Whatever comes after the function name
is ignored. Empty lines are ignored and lines are matched in order. The file
is parsed when the program starts and then it is indexed by the error number
and looked up when an error occurs. Note that you cannot override
<FONT COLOR=blue>&ndash;alwaysStopOnError</FONT> this way!<BR>
<BR>
For example, the following file:
<PRE CLASS="verbatim">
ignore UBOUND
stop * at hello.c: 10
ignore LBOUND at *:*:tricky
</PRE>
 means that all UBOUND errors are ignored, the execution stops for any error
in line 10 of hello.c (except UBOUND), and LBOUND in function <FONT COLOR=blue>tricky</FONT> is
ignored (except if it happens in line 10 of hello.c). Errors that do not
match are treated in the default way (stop if <FONT COLOR=blue>&ndash;alwaysStopOnError</FONT> or
<FONT COLOR=blue>CCURED_CONTINUE_ON_ERROR</FONT> are not specified).<BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=blue>CCURED_DUMP_HANDLERS</FONT>: if set, then CCured dumps its error handler
table (so that you can check that it has the values you want). <BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=blue>CCURED_ERROR_LOG</FONT>: If set, CCured will print all error
messages (except those which are are listed as <FONT COLOR=blue>ignore</FONT> in the error
handling file) to the specified log file in addition to
<TT>stderr</TT>. This variable should be set to the absolute path of the
log file.<BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=blue>CCURED_NO_SIGABRT</FONT>: When CCured handles an error by
 stopping the program's execution, it will normally call <TT>abort()</TT>.
 If this variable is set, CCured will use <TT>exit(-1)</TT> instead of
 <TT>abort()</TT>, which means that <TT>SIGABRT</TT> is not thrown.</UL>
<!--TOC chapter CCured Type Inference-->

<H1 CLASS="chapter"><A NAME="htoc28">Chapter&nbsp;5</A>&nbsp;&nbsp;CCured Type Inference</H1><!--SEC END -->
<A NAME="ch-typeinference"></A>
If you do not pass pass the <FONT COLOR=blue>&ndash;nocure</FONT> argument to <FONT COLOR=blue>ccured</FONT>, CCured
will automatically infer pointer kinds (see Section&nbsp;<A HREF="#sec-typeannot">3.1</A>) for the
pointer types in your program. In a nutshell, this is done by creating a graph
with one node for every pointer type in the program. If the program contains a
cast or assignment from one type to another, the graph contains an edge
between the corresponding nodes.<BR>
<BR>
Once the graph has been created, the inferencer will examine every node and
edge in the graph. If the edge represents a cast that is not captured by
our notion of physical subtyping (i.e., a cast that we cannot statically
verify to be valid) we mark the involved nodes (and thus the pointers in
the program they are associated with) as <TT>WILD</TT>. Since <TT>WILD</TT>pointers may
only point to other <TT>WILD</TT>areas, any node connected to a <TT>WILD</TT>node must
also be <TT>WILD</TT>. <BR>
<BR>
The inferencer then checks the remaining nodes to see if the types they
represent are involved in pointer arithmetic. A node that is only
incremented can be made <TT>FSEQ</TT>while a node that is subject to general
arithmetic must be <TT>SEQ</TT>. All remaining nodes (i.e., those that adhere to
our notion of physical subtyping and have no other constraints) become <TT>SAFE</TT>. <BR>
<BR>
The actual inferencer includes support for a number of specialty pointer
types, like the run-time type information pointer (<TT>RTTI</TT>), but the basic idea
remains as described above. The end result of the inferencer is the graph,
which serves as a mapping from types in the program to pointer kinds. The
module that inserts run-time checks into the program uses this information to
determine which checks to put where.<BR>
<BR>
In the process of adding run-time checks to make the program type- and
memory-safe, CCured introduces new types, changes old types and changes
function prototypes. In each of these cases a new name is introduced to
eliminate confusion and to prevent the resulting program from linking
improperly. <BR>
<BR>
<!--TOC section Using the pointer browser-->

<H2 CLASS="section"><A NAME="htoc29">5.1</A>&nbsp;&nbsp;Using the pointer browser</H2><!--SEC END -->
<A NAME="sec-browser"></A>
To inspect the results of the inference you should use the pointer browser.
Every time you run CCured it will produce a directory called <FONT COLOR=blue>foo.browser</FONT>
(where <FONT COLOR=blue>foo</FONT> is the name of the executable you are creating).
Alternatively, you can use the <FONT COLOR=blue>&ndash;browserdir</FONT> option to CCured to specify in
which directory it should place the browser. 
That
directory contains HTML files and Javascript programs that you can use to find
the reasoning that CCured has used during pointer kind inference. To start the
browser, point your web browser (Mozilla or IE; Netscape was broken beyond
belief when we checked last in September 2002) to the file
<FONT COLOR=blue>foo.browser/index.html</FONT> and get going.<BR>
<BR>
The browser will show you the preprocessed and merged file with annotations
about the pointer kinds. The file that you will see also has the result
of processing the polymorphism directives (see Section&nbsp;<A HREF="#sec-poly">7.1</A>) and the wrappers
(see Chapter&nbsp;<A HREF="#ch-wrapper">8</A>). <BR>
<BR>
The documentation for the pointer browser is at <A HREF="browser_help.html"><TT>browser_help.html</TT></A>.<BR>
<BR>
There is an alternative lower-level way to inspect the result of the
inference, which is described in Appendix&nbsp;<A HREF="#ch-graph">A</A>.<BR>
<BR>
<!--TOC chapter Using CCured-->

<H1 CLASS="chapter"><A NAME="htoc30">Chapter&nbsp;6</A>&nbsp;&nbsp;Using CCured</H1><!--SEC END -->
<A NAME="ch-examples"></A>
In this chapter we describe the typical steps that must be taken to use
CCured on a new software package. For each step we give general instructions.
Then, we look at a few concrete software packages and we describe all the
steps that were necessary. We describe the warnings and the errors that we ran
into and how we solved them. Most of these warnings and errors are also
discussed in Chapter&nbsp;<A HREF="#ch-warn">10</A>. Take a look there if the explanation here is too
terse.
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<B>Regular build</B> First try to download the sources and build them in
the regular manner (using <FONT COLOR=blue>gcc</FONT>). It might be a good idea to setup a CVS
repository right after you download the sources, in order to better keep track
of the changes you are making.<BR>
<BR>
<LI CLASS="li-enumerate"><B>Build using CIL</B> Next you should try to build the package using CIL
(the front-end that CCured uses). This step is optional but is a good idea
just in case your software package exposes a bug in CIL. To perform this step
you should edit the Makefile as follows (assuming it uses CC to invoke the
compiler <EM>and</EM> the linker):
<PRE CLASS="verbatim">
ifdef CCURED
 CC:=/home/necula/ccured/bin/ccured
endif
ifdef NOCURE
 CC+= --nocure
endif
ifdef NOMERGE
 CC+= --nomerge
endif
</PRE>
 If your project includes a more complicated setup, you must make the
necessary changes to use the above commands instead of <FONT COLOR=blue>gcc</FONT> (both for
compiling and for linking). <BR>
<BR>
Then you can run:
<PRE CLASS="verbatim">
make clean
make CCURED=1 NOCURE=1 NOMERGE=1
</PRE>
 This should build your project as before, except that each source file is
first preprocessed, then passed through the <FONT COLOR=blue>ccured.asm.exe</FONT> executable to
produce the CIL output (a file with suffix <FONT COLOR=blue>cil.c</FONT> that contains the source
of your program after being processed by the CIL front-end), then preprocessed
again and then finally passed to <FONT COLOR=blue>gcc</FONT>. Here is an example of what you
should see for the file <FONT COLOR=blue>util.c</FONT> from the <FONT COLOR=blue>mathopd</FONT> package:
<PRE CLASS="verbatim">
/home/necula/ccured/bin/ccured --nocure --nomerge -c -O -Wall -DHAVE_CRYPT_H util.c -o util.o
gcc -D_GNUCC -E  -O -DHAVE_CRYPT_H util.c -o ./util.i
/home/necula/ccured/obj/x86_LINUX/ccured.asm.exe --cilout ./utilcil.c --nocure --warnall ./util.i
gcc -D_GNUCC -E  -O -DHAVE_CRYPT_H -I/home/necula/ccured/include ./utilcil.c -o ./utilcil.i
gcc -D_GNUCC -c -O -DHAVE_CRYPT_H -Wall -o util.o ./utilcil.i
</PRE>
 At this point you should ensure that the executable still works as expected.
If it does not then you have found a bug in the CIL front-end or in the
<FONT COLOR=blue>ccured</FONT> Perl script that tries to impersonate <FONT COLOR=blue>gcc</FONT>. CIL has been tested
extensively, so you can consider yourself truly unfortunate. Please let us know
about your problem.<BR>
<BR>
Next, we try the same thing, but this time with merging. In this mode of
operation, the CIL front-end will attempt to create a single C source file
from all of the files in your project. In this case, when <FONT COLOR=blue>make</FONT> invokes
<FONT COLOR=blue>ccured</FONT> to compile a source file, the resulting object file will contain
just the preprocessed version of the source. And when <FONT COLOR=blue>ccured</FONT> is invoked to
link the executable then all of the preprocessed sources are merged into a
single file (with the suffix combcil.c), which is processed as before. Here is
an example of what you should see for the <FONT COLOR=blue>mathopd</FONT> package:
<PRE CLASS="verbatim">
make clean
make CCURED=1 NOCURE=1
...
gcc -D_GNUCC -E  -O -DHAVE_CRYPT_H util.c -o ./util.i
/home/necula/ccured/bin/ccured --nocure  -o mathopd base64.o cgi.o config.o core.o dump.o imap.o log.o main.o redirect.o request.o util.o -lcrypt
/home/necula/ccured/obj/x86_LINUX/ccured.asm.exe --cilout ./mathopd_combcil.c --nocure  base64.o cgi.o config.o core.o dump.o imap.o log.o main.o redirect.o request.o util.o
gcc -D_GNUCC -E -I/home/necula/ccured/include ./mathopd_combcil.c -o ./mathopd_combcil.i
gcc -D_GNUCC -c  -o mathopd_comb.o ./mathopd_combcil.i
gcc -D_GNUCC  -o mathopd mathopd_comb.o -lcrypt
</PRE>
 You should again try to run your executable. If it does not work as expected
then you have found a bug in the merger. This is again unlikely, but if it
happens, let us know. <BR>
<BR>
If your project is built by first creating some libraries then merging works
in a slightly different way. Take a look at the UCSPI TCP example
(Section&nbsp;<A HREF="#sec-ucspi">6.2</A>) next to see how that goes.<BR>
<BR>
<LI CLASS="li-enumerate"><B>Build with CCured</B>
 Now we start using CCured:
<PRE CLASS="verbatim">
make clean
make CCURED=1
</PRE>
 The sequence of operations is the same as in the case of CIL with merging,
except that this time, after the sources are merged into <FONT COLOR=blue>foo_comb.c</FONT>, the
<FONT COLOR=blue>ccured.asm.exe</FONT> engine is invoked.
CCured will print information about the stages that it goes through. You
should watch for warnings and error messages, especially in the &#8220;Inference&#8221;
stage and in the &#8220;Curing&#8221; stage. If you are lucky the above steps are enough
to build the executable. However, many times CCured will stop with some error.
The first thing you should do in that case is to scan the warnings that lead
to the error and proceed as explained in Chapter&nbsp;<A HREF="#ch-warn">10</A>. <BR>
<BR>
<LI CLASS="li-enumerate"><B>Write the wrappers</B><BR>
<BR>
If curing succeeds the resulting file (with suffix <FONT COLOR=blue>cured.c</FONT>) is passed to
<TT>gcc</TT> for compilation and linking. Often you will see linking errors that
mean that CCured has changed the interface of a function in a way that is
incompatible with the library version of the function. See the examples below
and Chapter&nbsp;<A HREF="#ch-wrapper">8</A> for a tutorial on writing wrappers.<BR>
<BR>
<LI CLASS="li-enumerate"><B>Run and debug the cured code</B>
 Now that you have build your executable with CCured you should run it on as
many examples as possible. Remember that CCured is engineered to catch the
majority of the bugs at run-time (it is designed with the philosophy that the
C programmer is better than the CCured static analyzer, so CCured just
silently inserts a run-time checks when it cannot ensure statically that what
the program is doing is guaranteed to be correct). <BR>
<BR>
When you get an error message from CCured you should investigate it to see if
it is a false alarm or a true bug. <BR>
<BR>
You can tell CCured to continue the execution after it encounters an error if
you set the environment variable <FONT COLOR=blue>CCURED_CONTINUE_ON_ERROR</FONT>.</OL>
Next we look at concrete examples. If you want to try your hand at using
CCured on real code you might want to try it on these packages and then use
the instructions when you get stuck.<BR>
<BR>
<!--TOC section Example: <TT>mathopd</TT> HTTP server-->

<H2 CLASS="section"><A NAME="htoc31">6.1</A>&nbsp;&nbsp;Example: <TT>mathopd</TT> HTTP server</H2><!--SEC END -->
<A NAME="sec-mathopd"></A>
<!--TOC subsection Step 1: Regular Build-->

<H3 CLASS="subsection"><A NAME="htoc32">6.1.1</A>&nbsp;&nbsp;Step 1: Regular Build</H3><!--SEC END -->

From the README file: &#8220;This is Mathopd, a fast, lightweight, non-forking HTTP
 server for UN*X systems.&#8221;<BR>
<BR>
We describe here the steps required for processing the version 1.4-gamma of
mathopd (a development version). This package contains of 5000 lines of code. <BR>
<BR>
We download <FONT COLOR=blue>mathopd-1.4-gamma.tar.gz</FONT>, unpack, change the Makefile as
required for Linux and then we try it out: 
<PRE CLASS="verbatim">
cd src
make
</PRE>
 Next we edit the configuration file (<FONT COLOR=blue>doc/sample.cfg</FONT>) so that we can run
the server on port 8000. Right after the line <FONT COLOR=blue>Server {</FONT> we add <FONT COLOR=blue>Port
 8000</FONT>. Then we must become root and create a directory for the log:
<PRE CLASS="verbatim">
su root
mkdir /var/mathopd
chmod 777 /var/mathopd
exit
./mathopd &lt;../doc/sample.cfg
</PRE>
 Now from another machine (make sure you have &nbsp;/public_html/index.html on the
 server machine):
<PRE CLASS="verbatim">
explorer http://manju.cs.berkeley.edu:8000/~necula/
</PRE>
 and we see that it works.<BR>
<BR>
<!--TOC subsection Step 2: Build with CIL-->

<H3 CLASS="subsection"><A NAME="htoc33">6.1.2</A>&nbsp;&nbsp;Step 2: Build with CIL</H3><!--SEC END -->

Completely uneventful.<BR>
<BR>
<!--TOC subsection Step 3: Build with CCured-->

<H3 CLASS="subsection"><A NAME="htoc34">6.1.3</A>&nbsp;&nbsp;Step 3: Build with CCured</H3><!--SEC END -->

For <FONT COLOR=blue>mathopd</FONT> we saw the warning:
<PRE CLASS="verbatim">
Warning: Generated automatic vararg descriptor for log_d: struct autoVarargDescr_log_d : char const   */* __attribute__((___ptrnode__(922))) */,
uid_t
If this is a printf-like function you should declare it!
</PRE>
 As explained in Chapter&nbsp;<A HREF="#ch-warn">10</A>, we take a look at the implementation of
<FONT COLOR=blue>log_d</FONT> (we find it in the merged file <FONT COLOR=blue>mathopd_comb.c</FONT>) to make sure
CCured did not miss anything. Sure enough, <FONT COLOR=blue>log_d</FONT> is a printf warning.
Same thing for <FONT COLOR=blue>die</FONT>. We fix this by adding the following pragma in
<FONT COLOR=blue>main.c</FONT> (see Section&nbsp;<A HREF="#sec-manualvararg">9.6.1</A> for details):
<PRE CLASS="verbatim">
#pragma ccuredvararg("log_d", printf(1))
#pragma ccuredvararg("die", printf(2))
</PRE>
 In the process of doing mathopd, we encountered the warning:
<PRE CLASS="verbatim">
/home/necula/ccured/include/netdb_wrappers.h:329: Warning: Solver: changing User Specified SAFE node 1371 (the local variable p_ith_alias) to WILD
</PRE>
 This turned out to be a bug in the wrapper for the socket functions. We found
it using the browser (see Section&nbsp;<A HREF="#sec-browser">5.1</A>). <BR>
<BR>
Then we saw a warning:
<PRE CLASS="verbatim">
/usr/include/sys/socket.h:156: Warning: sendmsg appears to be external
  (it has a wrapper), yet it has a mangled name: sendmsg_scsws_.
  Did you forget to use __ptrof and a version of __mkptr?
 For more information, consult the online documentation on
  "Writing Wrappers".
</PRE>
 This turned out to be due to the same socket wrapper error.<BR>
<BR>
Another warning you might see when you run CCured is:
<PRE CLASS="verbatim">
3 incompatible types flow into node void  *1127
  Type struct iovec_LEAN  *1178 at /home/necula/ccured/include/socket_wrappers.h:237
  Type char */* __NODE(1371) __ROSTRING  */ *1372 at /home/necula/ccured/include/netdb_wrappers.h:332
  Type struct iovec_LEAN  *1146 at /home/necula/ccured/include/socket_wrappers.h:219
</PRE>This means that a <FONT COLOR=blue>void *</FONT> node is cast to several incompatible types. When
you investigate this (using the browser, for example, or just following the
line numbers) you discover that the <FONT COLOR=blue>__trusted_add_iov</FONT> issue is the
cause of this also. <BR>
<BR>
Once we fix the above problem we notice that there are no more <TT>WILD</TT>
pointers: 
<PRE CLASS="verbatim">
ptrkinds: Graph contains 12886 nodes
ptrkinds:   SAFE - 9256 ( 72\%)
ptrkinds:   SEQ - 429 (  3\%)
ptrkinds:   FSEQ - 3201 ( 25\%)
</PRE>
 <!--TOC subsection Step 4: Write the wrappers-->

<H3 CLASS="subsection"><A NAME="htoc35">6.1.4</A>&nbsp;&nbsp;Step 4: Write the wrappers</H3><!--SEC END -->

We see now that there are some missing functions:
<PRE CLASS="verbatim">
mathopd_comb.o: In function `log_request':
mathopd_comb.o(.text+0x1b02d): undefined reference to `asctime_qs'
</PRE>
 See Chapter&nbsp;<A HREF="#ch-wrapper">8</A> for information on how to write this wrapper: Essentially
this is what we had to add to <FONT COLOR=blue>time_wrappers.h</FONT> file:
<PRE CLASS="verbatim">
#pragma ccuredwrapper("asctime_wrapper", of("asctime"))
__inline static
char *asctime_wrapper(const struct tm *timep) {
  struct tm *thinTimep = __ptrof(timep);
  char *thinRet = asctime(thinTimep);
  return __mkptr_string(thinRet);
}
</PRE>
 <!--TOC subsection Step 5: Run and Debug the cured code-->

<H3 CLASS="subsection"><A NAME="htoc36">6.1.5</A>&nbsp;&nbsp;Step 5: Run and Debug the cured code</H3><!--SEC END -->

We ran the <FONT COLOR=blue>mathopd</FONT> server and we get an error right away:
<PRE CLASS="verbatim">
Failure at config.c:924: new_pool(): Ubound
Aborted
</PRE>
 We look at the code and we see this code in <FONT COLOR=blue>config.c</FONT>:
<PRE CLASS="verbatim"><FONT COLOR=blue>
p-&gt;ceiling = t + s;
</FONT></PRE>
This looks like the pointer that is stored in the <FONT COLOR=blue>ceiling</FONT> field is
outside bounds, that that is Ok. This field is never used as a pointer. So, we
change its type to <FONT COLOR=blue>long</FONT> instead. We could change it to <TT>FSEQ</TT> as well.
See Chapter&nbsp;<A HREF="#ch-warn">10</A> for more possible solutions. <BR>
<BR>
Now mathopd seems to work!! But of course you should be using it for real in
order to find the bugs. <BR>
<BR>
<!--TOC section Example: UCSPI TCP Suite-->

<H2 CLASS="section"><A NAME="htoc37">6.2</A>&nbsp;&nbsp;Example: UCSPI TCP Suite</H2><!--SEC END -->
<A NAME="sec-ucspi"></A>
<!--TOC subsection Step 1: Regular Build-->

<H3 CLASS="subsection"><A NAME="htoc38">6.2.1</A>&nbsp;&nbsp;Step 1: Regular Build</H3><!--SEC END -->

This is a package that provides &#8220;tcpserver&#8221; and &#8220;tcpclient&#8221;. From their
web page (<A HREF="javascript:loadTop('http://cr.yp.to/ucspi-tcp.html')">)</A>: &#8220;they are easy-to-use
command-line tools for building TCP client-server applications.&#8221; The package
also includes a number of clients built using these tools. There are 6700
lines of code in this package. We actually found one bug in this library. <BR>
<BR>
We downloaded the version 0.88 (as of January 9, 2003). Following the
instructions:
<PRE CLASS="verbatim">
gunzip ucspi-tcp-0.88.tar
tar -xf ucspi-tcp-0.88.tar
cd ucspi-tcp-0.88
make
</PRE>
 Before we install it, we edit the file conf_home to point to the current
directory (we do not want to mess up the /usr/local). Then we continue:
<PRE CLASS="verbatim">
make setup check
</PRE>
 And now the big moment:
<PRE CLASS="verbatim">
./http@ www.yahoo.com
</PRE>
 Bingo!<BR>
<BR>
<!--TOC subsection Step 2: Build with CIL-->

<H3 CLASS="subsection"><A NAME="htoc39">6.2.2</A>&nbsp;&nbsp;Step 2: Build with CIL</H3><!--SEC END -->

This software package has a strange build interface. The Makefile contains
things like:
<PRE CLASS="verbatim">
addcr.o: \
compile addcr.c buffer.h exit.h
        ./compile addcr.c

compile: \
warn-auto.sh conf-cc
        ( cat warn-auto.sh; \
        echo exec "`head -1 conf-cc`" '-c $${1+"$$@"}' \
        ) &gt; compile
        chmod 755 compile
</PRE>
 What is happening is that the compile script is created from the first line
of <FONT COLOR=blue>conf-cc</FONT> and then used as a compiler. That line contains <FONT COLOR=blue>gcc -O2</FONT>
right now. We change that file to use instead the value of the CC environment variable:
<PRE CLASS="verbatim">
$CC -O2
</PRE>
 (You might want to also change warn-auto.sh to add a -v argument to /bin/sh
 so that you see what is going on.)<BR>
<BR>
Then we add the stuff to Makefile to define CC (and export it to child
scripts). It turns out that this file also was missing a clean target, so we
add that as well:
<PRE CLASS="verbatim">
export CC:=gcc
ifdef CCURED
 CC:=/home/necula/ccured/bin/ccured
endif
ifdef NOCURE
 CC+= --nocure
endif
ifdef NOMERGE
 CC+= --nomerge
endif

clean:
        rm -f *.i *.o *.a
        rm -f *cil.c *infer.c *comb.c *cured.c
        rm http@ tcpclient tcpserver
</PRE>
 Just to test the new setup we make it again and test it again. <BR>
<BR>
Now we try to make it with CIL.
<PRE CLASS="verbatim">
make clean
make CCURED=1 NOCURE=1 NOMERGE=1
</PRE>
 Now we get an error:
<PRE CLASS="verbatim">
tcpserver.o: In function `main':
tcpserver.o(.text+0xa29): undefined reference to `env_get'
tcpserver.o(.text+0xa50): undefined reference to `env_get'
</PRE>
 Clearly we have done something wrong. A quick investigation reveals that
tcpserver.c does need <FONT COLOR=blue>env_get</FONT>, which is defined in env.c, but seems to
be missing from <FONT COLOR=blue>envcil.c</FONT>. This means that the CIL front-end has dropped
this function. This is an embarrassing CIL bug. Now, when you have things
disappear then the fault is most often in the algorithm that CIL uses to
remove &#8220;unnecessary&#8221; things (such as locals or prototypes that are not
used). To disable that stage, pass the <FONT COLOR=blue>&ndash;keepunused</FONT> flag to CCured.<BR>
<BR>
Anyway, we fix that bug and now everything works. We now have to try the
merging. For this we must also intervene in the way the Makefile links
libraries and executables. It uses the scripts <FONT COLOR=blue>makelib</FONT> to make a library
and <FONT COLOR=blue>load</FONT> to make an executable. <BR>
<BR>
For the <FONT COLOR=blue>load</FONT> script all we need to change is the <FONT COLOR=blue>conf-ld</FONT> to use
<FONT COLOR=blue>$CC</FONT> instead of <FONT COLOR=blue>gcc</FONT>. We do this and we run with merging. We get this
error:
<PRE CLASS="verbatim">
gcc -D_GNUCC  -o tcpserver -s tcpserver_comb.o cdb.a dns.a time.a unix.a byte.a
cdb.a: could not read symbols: Archive has no index; run ranlib to add one
</PRE>
 As explained in Chapter&nbsp;<A HREF="#ch-warn">10</A>, this is because we should not use <FONT COLOR=blue>ar</FONT> to
archive files in the merging mode, but we should use <FONT COLOR=blue>ccured &ndash;mode=AR</FONT>. We
achieve this by changing the Makefile, which creates the <FONT COLOR=blue>makelib</FONT> script.
We change it such that the <FONT COLOR=blue>makelib</FONT> script uses the environment variable
<FONT COLOR=blue>AR</FONT> instead of <FONT COLOR=blue>ar</FONT>. And we defined AR in the Makefile as follows:
<PRE CLASS="verbatim">
export AR:=ar
ifdef CCURED
  ifndef NOMERGE
    AR:=/home/necula/ccured/bin/ccured --mode=AR
  endif
endif

</PRE>
 We run again in merging mode and now we get:
<PRE CLASS="verbatim">
ranlib: cdb.a: File format not recognized
</PRE>
 You look at <FONT COLOR=blue>cdb.a</FONT> and find that it is a merged source file. You should
not use <FONT COLOR=blue>ranlib</FONT> on such files. We edit the Makefile again and rerun. <BR>
<BR>
Now we get this error message when trying to merge <FONT COLOR=blue>rblsmtpd</FONT> from a number
of object files and libraries:
<PRE CLASS="verbatim">
/usr/include/sys/socket.h:189: Error: Incompatible declaration for accept (4). Previous was at rblsmtpd.c:103 (0) (different type constructors: void  vs. int )
</PRE>
 What happens is that the file <FONT COLOR=blue>rblsmtpd.c</FONT> defines its own global <FONT COLOR=blue>accept</FONT>
(luckily, with a different type than the one in the library; otherwise CCured
would not have noticed!). Yet, one of the
other files that are merged (<FONT COLOR=blue>socket_accept.c</FONT>) uses the standard
library's accept. This looks like a bug. When the linker puts everything
together the references to the &#8220;accept&#8221; from <FONT COLOR=blue>socket_accept</FONT> will be
resolved to the &#8220;accept&#8221; from <FONT COLOR=blue>rblsmtpd</FONT> (which is clearly not an
acceptable replacement for the socket function). <BR>
<BR>
We change the name of the &#8220;accept&#8221; in <FONT COLOR=blue>rblsmtpd</FONT> and we rerun and now
everything works. A result of your work so far is that for all of the utility
programs that make up this package you have their sources in one source file
(e.g. <FONT COLOR=blue>tcpclient_comb.c</FONT>. And, we have found a bug even before we started
to use the actual CCured!<BR>
<BR>
<!--TOC subsection Step 3: Build with CCured-->

<H3 CLASS="subsection"><A NAME="htoc40">6.2.3</A>&nbsp;&nbsp;Step 3: Build with CCured</H3><!--SEC END -->

The first thing we see when we enable CCured on this package is:
<PRE CLASS="verbatim">
chkshsgr.c:8: Warning: Calling function getgroups without proper prototype: will be WILD.
  getgroups has type void * __attribute__((___ptrnode__(12))) /* /* missing proto */  */()
chkshsgr.c:8: Warning: Calling function _exit with 1 arguments when expecting 0: will be WILD.
  _exit has type void ()
</PRE>
 Two warnings, both due to missing or incomplete prototypes. In the cast of
<FONT COLOR=blue>getgroups</FONT> it is a missing prototype. We add to <FONT COLOR=blue>chkshgr.c</FONT> the following:
<PRE CLASS="verbatim">
#include &lt;unistd.h&gt; // For getgroups
#include &lt;grp.h&gt;    // For setgroups
</PRE>
 We also exit the prototype of <FONT COLOR=blue>_exit</FONT> in <FONT COLOR=blue>exit.h</FONT>:
<PRE CLASS="verbatim">
extern void _exit(int); // The "int" was missing
</PRE>
 Now CCured succeeds in making this executable and proceeds to make
<FONT COLOR=blue>tcpserver</FONT>. Here we find this one:
<PRE CLASS="verbatim">
tcpserver.c:352: Error: You did not turn on the handling of inline assembly. Better hide this assembly somewhere else!
</PRE>
 This is interesting! We look at the inline assembly (a good place to look in
is <FONT COLOR=blue>tcpserver_comb.c</FONT>, you'll see them all in there). One is a use of
<FONT COLOR=blue>ntohs</FONT>, which is harmless because it does not involve pointers. We'll
leave this alone. <BR>
<BR>
But the other 5 or 6 such things are uses of the macros <FONT COLOR=blue>FD_SET</FONT> and
friends from <FONT COLOR=blue>&lt;sys/select.h&gt;</FONT>. We investigate and we find that these macros
are defined in <FONT COLOR=blue>&lt;bits/select.h&gt;</FONT>, and luckily that file also provides
regular C implementation for them, along the following lines:
<PRE CLASS="verbatim">
#if defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 2

# define __FD_ZERO(fdsp) \
  do {                                                                        \
    int __d0, __d1;                                                           \
    __asm__ __volatile__ ("cld; rep; stosl"                                   \
                          : "=c" (__d0), "=D" (__d1)                          \
                          : "a" (0), "0" (sizeof (fd_set)                     \
                                          / sizeof (__fd_mask)),              \
                            "1" (&amp;__FDS_BITS (fdsp)[0])                       \
                          : "memory");                                        \
  } while (0)
#else   /* ! GNU CC */
# define __FD_ZERO(set)  \
  do {                                                                        \
    unsigned int __i;                                                         \
    fd_set *__arr = (set);                                                    \
    for (__i = 0; __i &lt; sizeof (fd_set) / sizeof (__fd_mask); ++__i)          \
      __FDS_BITS (__arr)[__i] = 0;                                            \
  } while (0)

#endif  /* GNU CC */
</PRE>
 I am going to patch that include file to make the conditional test always
false and thus ensure that the C version is used always. 
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
First, we tell CCured that <FONT COLOR=blue>&lt;bits/select.h&gt;</FONT> is a file that must be
patched (you can see that it is not patched already because it is not present
in the directory <FONT COLOR=blue>cil/include/gcc_2.95.3</FONT>; by the time you read this it this
whole patching business should have been done already). We go into
<FONT COLOR=blue>cil/Makefile.gcc</FONT> and add to the list of <FONT COLOR=blue>PATCH_SYSINCLUDES</FONT> the name
<FONT COLOR=blue>bits/select.h</FONT> (but we do it only in the Linux section). 
<LI CLASS="li-enumerate">Then, we specify the patch. We add the following to the file <FONT COLOR=blue>cil/ccured_GNUCC.patch</FONT>:
<PRE CLASS="verbatim">
&lt;&lt;&lt; file=bits/select.h, system=linux
#if defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 2
===
#if 0 &amp;&amp; defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 2
&gt;&gt;&gt; 
</PRE>This says that the specified patch should be applied to the file
 <FONT COLOR=blue>bits/select.h</FONT> when CCured is run on a Linux system. (Not all
 platforms have bits/select.h.)
Matching is done whitespace-insensitive. Now you rebuild CCured (just run
<FONT COLOR=blue>make</FONT>) and you should find the patched file in the
<FONT COLOR=blue>cil/include/gcc_2.95.3/bits</FONT>. Make sure it is as you need. More information
about the patcher is at <A HREF="../cil/patcher.html"><TT>../cil/patcher.html</TT></A>
</OL>
And since we have left one inline assembly in, we must tell CCured to accept
it as is. We change the Makefile to pass the <FONT COLOR=blue>&ndash;allowInlineAssembly</FONT> to
CCured.<BR>
<BR>
Now we find more missing prototype problems:
<PRE CLASS="verbatim">
tcpserver.c:210: Warning: Calling function close with 1 arguments when expecting 0: will be WILD.
  close has type int ()
</PRE>
 In fact, <FONT COLOR=blue>close</FONT> does not have a prototype at all. CCured has supplied one
without arguments while making <FONT COLOR=blue>unix.a</FONT>! We add the &#8220;#include &lt;unistd.h&gt;&#8221;
to <FONT COLOR=blue>tcpserver.c</FONT> and go on. <BR>
<BR>
We add a few more prototypes and then we get:
<PRE CLASS="verbatim">
buffer_get.c:10: Warning: Calling function (*op) with 3 arguments when expecting 0: will be WILD.
  (*op) has type int ()
</PRE>
 We find in <FONT COLOR=blue>buffer.h</FONT> and <FONT COLOR=blue>buffer_get</FONT> a function pointer type declared
as &#8220;int (*op)()&#8221;. Again the missing argument types. We fill those in. <BR>
<BR>
Now starts the real fun, chasing away the <TT>WILD</TT> pointers (see
Chapter&nbsp;<A HREF="#ch-nowild">7</A> for general techniques). We see this message:
<PRE CLASS="verbatim">
** 1: Bad cast at cdb_make.c:36 (char  *510 -&gt;struct cdb_hplist  *1376)
** 2: Bad cast at pathexec_env.c:42 (char  *510 -&gt;char */* __NODE(2537)  */ *2538)
** 3: Bad cast at pathexec_env.c:67 (char */* __NODE(2537)  */ *2538 -&gt;char  *2553)
** 4: Bad cast at sig.c:12 (void (int  ) *2695 -&gt;void () *2694)
** 5: Bad cast at sig_catch.c:9 (void () *673 -&gt;void (int  ) *2711)
ptrkinds: Graph contains 4383 nodes
ptrkinds:   SAFE - 3142 ( 72%)
ptrkinds:   SEQ - 15 (  0%)
ptrkinds:   FSEQ - 127 (  3%)
ptrkinds:   WILD - 1099 ( 25%)
535 pointers are void*
5 bad casts of which 0 involved void* and 2 involved function pointers
1 (20%) of the bad casts are downcasts
0 incompatible equivalence classes
</PRE>
 The casts 4 and 5 are due to missing argument types function types. We edit
sig.h to add the &#8220;int&#8221; as the argument type for signal handler. <BR>
<BR>
We investigate cast number 2 and we find something like this:
<PRE CLASS="verbatim">
 e = (char **) alloc((elen + 1) * sizeof(char *));
</PRE>
 This is a custom allocator. We must declare it (in alloc.h):
<PRE CLASS="verbatim">
extern void *alloc(unsigned int);
#pragma ccuredalloc("alloc", nozero, sizein(1)) // We added this line
</PRE>
 We run CCured again and no more bad casts (it looks like all the others were
due to <FONT COLOR=blue>alloc</FONT>), but still a bunch of <TT>WILD</TT>:
pointers: 
<PRE CLASS="verbatim">
ptrkinds: Graph contains 4575 nodes
ptrkinds:   SAFE - 3324 ( 73%)
ptrkinds:   SEQ - 41 (  1%)
ptrkinds:   FSEQ - 150 (  3%)
ptrkinds:   WILD - 1060 ( 23%)
579 pointers are void*
0 bad casts of which 0 involved void* and 0 involved function pointers
No bad casts, so no downcasts
2 incompatible types flow into node void  *518
  Type char */* __NODE(2549)  */ *2550 at pathexec_env.c:67
  Type char  *102 at dns_transmit.c:63
2 incompatible equivalence classes
</PRE>
 Notice that we have more pointers in the program. This is due to the
allocator, which is now polymorphic and is duplicated several times. But we
also have incompatible equivalence classes. This is because there is a <FONT COLOR=blue>void
*</FONT> pointer that is used with several incompatible types (in this case <FONT COLOR=blue>char
*</FONT> and <FONT COLOR=blue>char **</FONT>). See Section&nbsp;<A HREF="#sec-poly">7.1</A> for more details on this. This turns
out to be because the function <FONT COLOR=blue>alloc_free</FONT> with a declared argument of
type <FONT COLOR=blue>void *</FONT> is used in two places with different argument types. We simply
declare that function to be polymorphic (in <FONT COLOR=blue>alloc.h</FONT>):
<PRE CLASS="verbatim">
#pragma ccuredpoly("alloc_free")
</PRE>Finally, CCured succeeds, with no <TT>WILD</TT> pointers, but there still is a
warning that we have not looked at:
<PRE CLASS="verbatim">
pathexec_env.c:42: Warning: Encountered sizeof(char */* __attribute__((___ptrnode__(2595))) */) when type contains pointers. Use sizeof expression. Type has a disconnected node.
</PRE>
 As explained in Section&nbsp;<A HREF="#sec-sizeof">9.5</A> we should take a look at the code. We find
this typical example, and we fix it accordingly:
<PRE CLASS="verbatim">
  e = (char **) alloc((elen + 1) * sizeof(* e)); // Was sizeof(char *)
</PRE>
 <!--TOC subsection Step 4: Write the wrappers-->

<H3 CLASS="subsection"><A NAME="htoc41">6.2.4</A>&nbsp;&nbsp;Step 4: Write the wrappers</H3><!--SEC END -->

In this package there in an interesting case:
<PRE CLASS="verbatim">
tcpserver_comb.o: In function `env_get_qf':
tcpserver_comb.o(.text+0x15d10): undefined reference to `environ_qq'
</PRE>
 This time the global that needs a wrapper is a pointer to data, not a
function. You cannot write a wrapper for this, but you can replace its
accesses with functions. <BR>
<BR>
Since the program accesses <FONT COLOR=blue>environ</FONT> always with an index operation
<FONT COLOR=blue>environ[i]</FONT>, we can write a function <FONT COLOR=blue>environ_idx</FONT> that takes an integer
and returns the <I>i</I><SUP><I>th</I></SUP> element in <FONT COLOR=blue>environ</FONT>. I show below the case where
it appropriate to trust that the index is within the bounds:
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern char ** environ;
char* environ_idx(int i) {
  char * __SAFE * __SAFE p_environ = __trusted_add(environ, i);
  // We are going to believe that i is within bounds
  return __mkptr_string(* p_environ);
  
}
</FONT></PRE>
<!--TOC subsection Step 5: Run and debug the cured code-->

<H3 CLASS="subsection"><A NAME="htoc42">6.2.5</A>&nbsp;&nbsp;Step 5: Run and debug the cured code</H3><!--SEC END -->

We have built the suite of tools and now we run it. Right away we get a
run-time error, so we set <FONT COLOR=blue>CCURED_CONTINUE_ON_ERROR</FONT>
(Section&nbsp;<A HREF="#sec-errorhandle">4.2</A>) to see them all. 
<PRE CLASS="verbatim">
Failure STORE_SP at pathexec_env.c:47: pathexec_qq(): Storing stack address
...
Failure STORE_SP at /home/necula/ccured/include/functions/deepcopy_stringarray.h:70: __deepcopy_stringarray_to_compat___0_ssqq(): Storing stack address
</PRE>
 There are two distinct errors. We'll fix them, but here is a way to silence
CCured if you are lazy: we can use
<FONT COLOR=blue>CCURED_ERROR_HANDLERS</FONT> to specify that we want to ignore all
<FONT COLOR=blue>STORE_SP</FONT> errors in those two functions. For this we write a text file
(ucspi.handlers):
<PRE CLASS="verbatim">
ignore STORE_SP at *:*:pathexec_qq
ignore STORE_SP at *:*:__deepcopy_stringarray_to_compat___0_ssqq
</PRE>
 Now we run as follows:
<PRE CLASS="verbatim">
CCURED_ERROR_HANDLERS=ucspi.handlers ./http@
</PRE>
 and <TT>http@</TT> seems to work.<BR>
<BR>
Let's go back to fixing these errors. These errors are all trying to store
strings that are obtained from the <FONT COLOR=blue>environ</FONT> variable. It turns out that
those strings are on the stack (allocated before <FONT COLOR=blue>main</FONT> is invoked). The
solution would be to copy those strings on the heap. But right after I saw
this error I realized that CCured should not complain if the address that is
being stored is in the stack frame of <FONT COLOR=blue>main</FONT> or at higher addresses. So, I
added this feature to CCured and now you will not see these particular errors.
But if you run <TT>http@ www.yahoo.com</TT> you will get:
<PRE CLASS="verbatim">
Failure STORE_SP at dns_transmit.c:213: dns_transmit_start_sqqff(): Storing stack address
</PRE>
 It does not take much to find that this is due to the following code:
<PRE CLASS="verbatim">
# 5 "dns_resolve.c"
int dns_resolve(char *q,char qtype[2])
{
  struct taia stamp;
  struct taia deadline;
  char servers[64];

  if (dns_transmit_start(&amp;dns_resolve_tx,servers,1,q,qtype,"\0\0\0\0") == -1) return -1;
</PRE>
 <TT>dns_transmit_start</TT> then stores the address of the array <FONT COLOR=blue>servers</FONT>
into the heap. The solution here is to move the <FONT COLOR=blue>servers</FONT> array into the
heap (or make it a global). We can achieve the former by declaring:
<PRE CLASS="verbatim">
 char servers[64]  __HEAPIFY;
</PRE>
 and CCured will move it to the heap (see Section&nbsp;<A HREF="#sec-storeptr">3.5</A>).<BR>
<BR>
Bingo! It seems to work. Now, you can start measuring performance and, if
desired, you can try to make CCured infer better checks for your code. <BR>
<BR>
<!--TOC section Example: PING-->

<H2 CLASS="section"><A NAME="htoc43">6.3</A>&nbsp;&nbsp;Example: PING</H2><!--SEC END -->

In this section I describe what it took to do the <TT>ping</TT> utility from
<TT>netkit-base-0.17</TT>. <BR>
<BR>
We download, compile, test it. Then we setup the Makefiles to use ccured
instead of <TT>gcc</TT> and we test that it works in the <TT>&ndash;nocure</TT> mode. Then we
turn on curing. <BR>
<BR>
First we see two errors pointing out that there is inline assembly in
<TT>ping</TT>. CCured also prints the instructions and we see that they are just
bit manipulations. So, we just pass <TT>&ndash;allowInlineAssembly</TT> to ccured and go
on. <BR>
<BR>
Now we get:
<PRE CLASS="verbatim">
Failure UBOUND at ping.c:1303: main(): Ubound
</PRE>
 To investigate this one we can use <TT>CCURED_SLEEP_ON_ERROR</TT> (see
Chapter&nbsp;<A HREF="#ch-invoke">4</A>). The fragment of code that causes this error is similar to the
following code:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct icmp {
   int various;
   char data[1];
};
char outpack[65536];

char foo() {
 // Get the 8th data character
 return ((struct icmp*)outpack)-&gt;data[8];
}
</FONT></PRE>
The problem is that once <FONT COLOR=blue>outpack</FONT> is cast to a <FONT COLOR=blue>struct icmp *</FONT> it looses
the ability to access most element in the original array. The solution for
this particular error involves a slight rewrite of the access as:
<PRE CLASS="verbatim"><FONT COLOR=blue>
char foo() {
 // Get the offset of the 8th data character
 int off = (int) &amp; ((struct icmp*)0)-&gt;data[8];
 return outpack[off];
}
</FONT></PRE>
We need to fix that problem in all accesses to the <TT>data</TT> field. After
that, we run into another problem:
<PRE CLASS="verbatim">
Failure ALIGNSEQ at ./ping_combcured.c:3923: pinger(): Creating an unaligned sequence
</PRE>
 This is because at some point we create a sequence pointer whose home area
does not contain a whole number of elements. See Section&nbsp;<A HREF="#sec-checkseq">3.6.3</A> for the
various ways to address this problem. We choose to simply tell CCured to allow
partial elements in structures and to adapt its checks accordingly. To achieve
this we pass <TT>&ndash;allowPartialElementsInSequence</TT> to CCured.<BR>
<BR>
Now it works, we are done.<BR>
<BR>
<!--TOC section Example: THTTPD Server-->

<H2 CLASS="section"><A NAME="htoc44">6.4</A>&nbsp;&nbsp;Example: THTTPD Server</H2><!--SEC END -->

In this section, we take a look into how to cure thttpd, described by its 
author as &#8220;a simple, small, portable, fast, and secure HTTP server.&#8221; It 
is currently the fifth most popular HTTP server on the net. You can get it 
at <A HREF="javascript:loadTop('http://www.acme.com/software/thttpd/')">.</A> The version I work 
with is 2.23 beta 1.<BR>
<BR>
<!--TOC subsection Step 1: Regular Build-->

<H3 CLASS="subsection"><A NAME="htoc45">6.4.1</A>&nbsp;&nbsp;Step 1: Regular Build</H3><!--SEC END -->

First, we unpack the files:
<PRE CLASS="verbatim">
gunzip thttpd-2.23beta1.tar.gz
tar -xvf thttpd-2.23beta1.tar
</PRE>
Look into the directory for the file <FONT COLOR=blue>configure</FONT>. We don't want to mess up 
the /usr/local/ folder, so go into <FONT COLOR=blue>configure</FONT> and delete the folder path 
from <FONT COLOR=blue>ac_default_prefix</FONT>. Now Makefile should make thttpd to the folder 
where the source code resides. Run <FONT COLOR=blue>configure</FONT>.
<PRE CLASS="verbatim">
./configure
</PRE>
The file should do some work and generate a few files. <BR>
<BR>
There is also another modification we should make to avoid conflicts with any 
existing http servers (e.g. Apache). In <FONT COLOR=blue>config.h</FONT>, go-to Line 321 and 
change the default port from 80 to something like 7500. <BR>
<BR>
Now we can run make. The compiler does work and should produce a file named 
<FONT COLOR=blue>thttpd</FONT>. Run the program and test the server from another computer. In my 
case, I steered my browser to <FONT COLOR=blue>http://manju.cs.berkeley.edu:7500/&nbsp;andypang/</FONT>.
<PRE CLASS="verbatim">
make
</PRE>a few seconds later...
<PRE CLASS="verbatim">
./thttpd
</PRE>
If you see your homepage, thttpd is working. If not, make sure you have a 
public_html folder. If you are lazy, there is another way to check if thttpd 
is working. Check whether the site for the server is up at the port you 
specified (e.g. <FONT COLOR=blue>http://manju.cs.berkeley.edu:7500/</FONT>). A page with a green 
background should appear notifying you that thttpd is running.<BR>
<BR>
<!--TOC subsection Step 2: Build with CIL-->

<H3 CLASS="subsection"><A NAME="htoc46">6.4.2</A>&nbsp;&nbsp;Step 2: Build with CIL</H3><!--SEC END -->

It's time to look into that <FONT COLOR=blue>Makefile.in</FONT> that came with thttpd. 
<FONT COLOR=blue>Makefile.in</FONT> is the file from which <FONT COLOR=blue>configure</FONT> generates <FONT COLOR=blue>Makefile</FONT>, 
which in turn is used to build the application. <BR>
<BR>
Below the line that says &#8220;You shouldn't need to edit anything below here,&#8221; 
we make the same changes to the <FONT COLOR=blue>CC</FONT> variable as in the other tutorials.
<PRE CLASS="verbatim">
ifdef CCURED
 CC:=/home/andypang/cil/bin/ccured
endif
ifdef NOCURE
 CC+= --nocure
endif
ifdef NOMERGE
 CC+= --nomerge
endif
</PRE>
Be sure to insert these ifdefs below the block of variable declarations (below 
line 60). Otherwise, gcc would be used to compile the files.<BR>
<BR>
There will also be more files to clean after CIL/CCured is run, so I added 
the following to clean up the CIL files and folders that will be generated:
<PRE CLASS="verbatim">
CIL =           $(SRC:.c=.i) *cil*

COMB =          *comb*
</PRE>
I modified the variable CLEANFILES to include those files.
<PRE CLASS="verbatim">
CLEANFILES =    $(ALL) $(OBJ) $(GENSRC) $(GENHDR) $(CIL) $(COMB)
</PRE>
Now we are ready to compile using CIL. First, we run <FONT COLOR=blue>configure</FONT> again to 
update the Makefile.
<PRE CLASS="verbatim">
./configure
make clean
make CCURED=1 NOCURE=1 NOMERGE=1
</PRE>
Ensure the application still works correctly. It should. Now build with 
merging.
<PRE CLASS="verbatim">
make clean
make CCURED=1 NOCURE=1
</PRE>
Again, check for proper functionality.<BR>
<BR>
<!--TOC subsection Step 3: Build with CCured-->

<H3 CLASS="subsection"><A NAME="htoc47">6.4.3</A>&nbsp;&nbsp;Step 3: Build with CCured</H3><!--SEC END -->

The big moment.
<PRE CLASS="verbatim">
make clean
make CCURED=1
</PRE>
You should see a number of errors and warnings. Many of these will involve 
a warning of a &#8220;malformed format string&#8221; looking something like this:
<PRE CLASS="verbatim">
libhttpd.c:226: Warning: Malformed format string [child wait - %m]
</PRE>
If you take a look at the string, the warning stems from a call to syslog 
with a %m. This is safe, and can be safely ignored. ***********<BR>
<BR>
Now we see a prototyping warning:
<PRE CLASS="verbatim">
thttpd.c:437: Warning: Calling function sigset without proper prototype: will be WILD.
  sigset has type void * __attribute__((___ptrnode__(1666))) /* /* missing proto */  */()
</PRE>
At this point we realize that some files are read-only. We chmod the thttp folder from its 
parent directory so that we can write to any file in the directory:
<PRE CLASS="verbatim">
chmod -R u+w thttpd-2.23beta1
</PRE>
Back to the problem at hand. If one punches in <FONT COLOR=blue>sigset</FONT> on Google, one 
will that it is a function in <FONT COLOR=blue>signal.h</FONT>. Add the following <FONT COLOR=blue>thttpd.c</FONT> 
to remedy the warning:
<PRE CLASS="verbatim">
extern void *sigset(int, void*);
</PRE>
Although the warning also appeared for the file <FONT COLOR=blue>libhttpd.c</FONT>, the 
prototype in <FONT COLOR=blue>thttpd.c</FONT> will work for all files in the project.<BR>
<BR>
The next most prevalent warning should be a sscanf error, where CCured 
warns that it does not expect the type <FONT COLOR=blue>char *</FONT>. CCured does not accept 
strings in sscanf because one could potentially read in an unbounded 
string. This characteristic could be used for malicious intentions. <BR>
<BR>
Although <FONT COLOR=blue>%400[a-zA-Z]</FONT> is used and hence strings that are accepted by 
sscanf will be limited to 400 bytes, CCured currently does not support this. 
This may change in the future, because this method of scanning strings is 
not suspectible to the same problems as simply using <FONT COLOR=blue>%s</FONT>.<BR>
<BR>
To fix this error, use CCured's sscanf/fscanf functions in place of 
the ones in <FONT COLOR=blue>stdio.h</FONT>. Please refer to Section&nbsp;<A HREF="#sec-scanf-like">9.6.3</A> 
for more details. As an example, the following is how I modified the code 
at Line 213 in <FONT COLOR=blue>tdate_parse.c</FONT>.
<PRE CLASS="verbatim">
    /* DD-mth-YY HH:MM:SS GMT */
    if ( 
        (resetSScanfCount(cp), 
         tm_mday = ccured_fscanf_int(ccured_sscanf_file, "$d-"),
         ccured_fscanf_string(ccured_sscanf_file, "%400[a-zA-Z]-", str_mon),
         tm_year = ccured_fscanf_int(ccured_sscanf_file, "$d "),
         tm_hour = ccured_fscanf_int(ccured_sscanf_file, "$d:"),
         tm_min = ccured_fscanf_int(ccured_sscanf_file, "$d:"),
         tm_sec = ccured_fscanf_int(ccured_sscanf_file, "$d GMT"),
         getScanfCount()) == 6 &amp;&amp;
        /*
        sscanf( cp, "%d-%400[a-zA-Z]-%d %d:%d:%d GMT",
                &amp;tm_mday, str_mon, &amp;tm_year, &amp;tm_hour, &amp;tm_min,
                &amp;tm_sec ) == 6 &amp;&amp;
        */
            scan_mon( str_mon, &amp;tm_mon ) )
        {
</PRE>
Then we see several warnings regarding the use of sizeof:
<PRE CLASS="verbatim">
libhttpd.c:2782: Warning: Encountered sizeof(char */* __attribute__((___ptrnode__(5491))) */) when type contains pointers. Use sizeof expression. Type has a disconnected node.
</PRE>
We take a look at this line and find that it is a function call to <FONT COLOR=blue>RENEW</FONT>. 
<PRE CLASS="verbatim">
nameptrs = RENEW( nameptrs, char*, maxnames );
</PRE>
The definition of <FONT COLOR=blue>RENEW</FONT> can be found in <FONT COLOR=blue>libhttpd.h</FONT>. 
<PRE CLASS="verbatim">
#define RENEW(o,t,n) ((t*) realloc( (void*) o, sizeof(t) * (n) ))
</PRE>
The warning arises from the fact that the CCured inferencer cannot make
the connection between <FONT COLOR=blue>nameptrs</FONT> and <FONT COLOR=blue>char *</FONT>'s. See Section&nbsp;<A HREF="#sec-sizeof">9.5</A> 
for more details.<BR>
<BR>
To fix the warning, we let CCured inference the argument in <FONT COLOR=blue>sizeof</FONT> 
to <FONT COLOR=blue>nameptr</FONT> by modifying the code in the following way:<BR>
<BR>
In libhttpd.c
<PRE CLASS="verbatim">
nameptrs = RENEW( nameptrs, nameptr*, maxnames );
</PRE>
In libhttpd.h
<PRE CLASS="verbatim">
#define RENEW(o,t,n) (realloc( (void*) o, sizeof(t) * (n) ))
</PRE>
Now CCured will know that we are allocating memory based on the size of 
the pointers to <FONT COLOR=blue>nameptr</FONT>. <BR>
<BR>
The macro <FONT COLOR=blue>NEW</FONT> is defined one line before <FONT COLOR=blue>RENEW</FONT>, and we fix a couple 
of calls to <FONT COLOR=blue>NEW</FONT> in the same way. <BR>
<BR>
We now face a number of warnings of the following form:
<PRE CLASS="verbatim">
libhttpd.c:2519: Warning: Solver: changing User Specified SAFE node 5283 (an unnamed location (often an inserted cast)) to FSEQ
</PRE>
A quick look at <FONT COLOR=blue>libhttpd.c</FONT> shows that a call to <FONT COLOR=blue>qsort</FONT> is made. 
The wrapper for qsort can be found in <FONT COLOR=blue>stdlib_wrappers.h</FONT>, and there 
appears to be two versions of <FONT COLOR=blue>qsort</FONT>. One versions supports polymorphism 
and the other does not. Add <FONT COLOR=blue>-DUSE_POLYMORPHIC_QSORT</FONT> in <FONT COLOR=blue>Makefile.in</FONT> 
after we make the call to <FONT COLOR=blue>cil/bin/ccured</FONT>, so that CCured will know to 
use the polymorphic qsort. <BR>
<BR>
This fixes the problems in <FONT COLOR=blue>libhttpd.c</FONT> but not <FONT COLOR=blue>tdate_parse.c</FONT>. We go 
to Line 113 and find a call to qsort. At first it looks like a problem with 
sizeof, but fixing the calls to sizeof proves to be fruitless (although still 
a good programming practice). <BR>
<BR>
Let's turn to the browser to track down the bad cast for us. Looking at the 
problematic node will show us that it is in the arguments passed into the 
comparator for qsort. The arguments of the comparator are declared as <FONT COLOR=blue>char *</FONT>, 
but they are also cast to <FONT COLOR=blue>struct strlong *</FONT> in the function. This is a 
bad cast. Change the types of the accepted arguments to <FONT COLOR=blue>void *</FONT> and 
the problem is solved. <BR>
<BR>
Next we tackle a similar problem in <FONT COLOR=blue>tdate_parse.c</FONT>:
<PRE CLASS="verbatim">
** 1: Bad cast (seq) at tdate_parse.c:202 (struct tm  *7100 -&gt;char  *7136)
</PRE>
Once again, we use the browser to track down the problem, and find a cast 
from a <FONT COLOR=blue>struct tm *</FONT> to a <FONT COLOR=blue>char *</FONT>. We change the <FONT COLOR=blue>char *</FONT> to a 
<FONT COLOR=blue>void *</FONT> and the bad cast disappears.
<PRE CLASS="verbatim">
    (void) memset( (void*) &amp;tm, 0, sizeof(struct tm) );
</PRE>
The last bad cast:
<PRE CLASS="verbatim">
** 1: Bad cast at timers.h:41 (void */* __NODE(346)  */ *347 -&gt;long  *349)
</PRE>
Going to Line 41 reveals a union of <FONT COLOR=blue>void *</FONT>, <FONT COLOR=blue>int</FONT>, and <FONT COLOR=blue>long</FONT>. This 
cannot possibly be safe because <FONT COLOR=blue>i</FONT> could later be used as a pointer 
with <FONT COLOR=blue>p</FONT>. We change this union to a tagged union as instructed in 
Section&nbsp;<A HREF="#sec-taggedunion">9.7</A>.
<PRE CLASS="verbatim">
union ClientData {
    void* p;
    int i;
    long l;
} __TAGGED;
typedef union ClientData ClientData;
</PRE>
<!--TOC chapter How to Eliminate WILD Pointers-->

<H1 CLASS="chapter"><A NAME="htoc48">Chapter&nbsp;7</A>&nbsp;&nbsp;How to Eliminate WILD Pointers</H1><!--SEC END -->
<A NAME="ch-nowild"></A>
As explained in the tutorial, you can use the <TT>WILD</TT> pointer types to do
most of the things that you can do with pointers in C. And, in fact, CCured's
inferencer will turn some of your pointers into <TT>WILD</TT> pointers if you use
them in unusual ways. <BR>
<BR>
<TT>WILD</TT> pointers are bad. Every time you access them you have to also access
the tags. And what makes them really annoying is that they spread very
quickly. Even a few bad casts in your program can lead to a contamination of
30% of the pointers with <TT>WILD</TT>ness. And that means that you'll have to
write lots of wrappers, and hard ones. (In fact, the support that we provide
for writing wrappers does not work in all cases in the presence of <TT>WILD</TT>
pointers.) <BR>
<BR>
So, we recommend that you take a look at the warnings and messages that
CCured gives and try to address the bad casts. In this chapter, we describe
a few tricks that you can use to change the code, and a few features that
CCured has to help you do that. <BR>
<BR>
First, a few notes:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Do not use functions without prototypes. They will be <TT>WILD</TT> along with
their arguments and result values.<BR>
<BR>
<LI CLASS="li-itemize">Fill in the full type of functions and pointers. In C it is technically
sufficient to leave the argument part of a function type empty, and this
allows to call the function with whatever arguments you feel like. CCured will
accept that but will make the function <TT>WILD</TT>!<BR>
<BR>
<LI CLASS="li-itemize">If your program has custom memory allocators (generally wrappers around
<FONT COLOR=blue>malloc</FONT> and friend), you must declare them (Section&nbsp;<A HREF="#sec-malloc">7.2</A>).<BR>
<BR>
<LI CLASS="li-itemize">If you have functions that use pointers polymorphically, make sure those
pointer types are <FONT COLOR=blue>void *</FONT> (not <FONT COLOR=blue>char *</FONT> as it was common before ANSI C). 
</UL>
When it notices bad casts, CCured will print something like this:
<PRE CLASS="verbatim">
** 1: Bad cast at cdb_make.c:36 (char  *510 -&gt;struct cdb_hplist  *1376)
** 2: Bad cast at pathexec_env.c:42 (char  *510 -&gt;char */* __NODE(2537)  */ *2538)
** 3: Bad cast at pathexec_env.c:67 (char */* __NODE(2537)  */ *2538 -&gt;char  *2553)
** 4: Bad cast at sig.c:12 (void (int  ) *2695 -&gt;void () *2694)
** 5: Bad cast at sig_catch.c:9 (void () *673 -&gt;void (int  ) *2711)
ptrkinds: Graph contains 4383 nodes
ptrkinds:   SAFE - 3142 ( 72%)
ptrkinds:   SEQ - 15 (  0%)
ptrkinds:   FSEQ - 127 (  3%)
ptrkinds:   WILD - 1099 ( 25%)
535 pointers are void*
5 bad casts of which 0 involved void* and 2 involved function pointers
1 (20%) of the bad casts are downcasts
0 incompatible equivalence classes
</PRE>
 This means that there are 5 bad casts (which contaminate 25% of your
pointers). There are no incompatible equivalence classes in this case. <BR>
<BR>
You can either go directly at the line numbers in which the bad casts are
reported, or you can use the browser (Section&nbsp;<A HREF="#sec-browser">5.1</A>).<BR>
<BR>
Bad cast number 4 and 5 in the example above are clear indications that there
are some incomplete function types in your program. Go and add the argument
types. <BR>
<BR>
The other bad casts are due to an undeclared memory allocator. After we fix
 those we rerun and we get:
<PRE CLASS="verbatim">
ptrkinds: Graph contains 4575 nodes
ptrkinds:   SAFE - 3324 ( 73%)
ptrkinds:   SEQ - 41 (  1%)
ptrkinds:   FSEQ - 150 (  3%)
ptrkinds:   WILD - 1060 ( 23%)
579 pointers are void*
0 bad casts of which 0 involved void* and 0 involved function pointers
No bad casts, so no downcasts
2 incompatible types flow into node void  *518
  Type char */* __NODE(2549)  */ *2550 at pathexec_env.c:67
  Type char  *102 at dns_transmit.c:63
2 incompatible equivalence classes
</PRE>
 Notice that we have more pointers in the program. This is due to the
allocator, which is now polymorphic and is duplicated several times. But we
also have incompatible equivalence classes. This is because there is a <FONT COLOR=blue>void
*</FONT> pointer that is used with several incompatible types (in this case <FONT COLOR=blue>char
*</FONT> and <FONT COLOR=blue>char **</FONT>). See Section&nbsp;<A HREF="#sec-poly">7.1</A> for more details on this. <BR>
<BR>
<!--TOC section Polymorphism-->

<H2 CLASS="section"><A NAME="htoc49">7.1</A>&nbsp;&nbsp;Polymorphism</H2><!--SEC END -->
<A NAME="sec-poly"></A>
Polymorphism is the ability a program fragment to operate on data of
different types. This is a useful thing to be able to do and since C does not
have special support for it, each programmer implements polymorphism by
extensive use of casting. But not all casts are equal. Consider for example a
function that just returns its argument:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int identity_bad(int x) { return x; }
</FONT></PRE>
This function can be used with any type that fits in an integer, provided the
appropriate casts from the type to <FONT COLOR=blue>int</FONT> and back are inserted. But as we
have already discussed in Section&nbsp;<A HREF="#sec-castint">9.4</A> this won't work in CCured because
the pointers you get out are not usable. <BR>
<BR>
A better way to do this is as follows:
<PRE CLASS="verbatim"><FONT COLOR=blue>
void* identity(void* x) { return x; }
</FONT></PRE>
It is a common paradigm in C to use <FONT COLOR=blue>void*</FONT> for a &#8220;pointer to I don't know
what&#8221; type. CCured supports this view directly by considering each use of
<FONT COLOR=blue>void *</FONT> in the program as an occurrence of an unknown type. The CCured
inferencer will try to find a replacement type that makes sense in that
context. For example, in the following code fragment CCured will think of both
occurrences of <FONT COLOR=blue>void *</FONT> as actually being <FONT COLOR=blue>int * *</FONT>.
<PRE CLASS="verbatim"><FONT COLOR=blue>
void* identity(void* x) { return x; }

int main() {
    int * * p = 0;
    int * * res = identity(p);
}
</FONT></PRE>
<a target="_blank" href="examples/ex31.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex31.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
This model works for even very complicated code, such as the following
fragment that
defines a function <FONT COLOR=blue>apply</FONT> which applies a function pointer to some
arguments (see in the output that all pointers are inferred <TT>SAFE</TT>):
<PRE CLASS="verbatim"><FONT COLOR=blue>
// Applies a function to an argument
void * apply(void* (*f)(void*), void *arg) {
   return f(arg);
}

// A simple dereference function
int * deref(int * * addr) {
    return *addr;
} 

int  main() {
     int * x = 0;
     int * res = apply(deref, &amp; x);
}
</FONT></PRE>
<a target="_blank" href="examples/ex32.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex32.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
In the above example there are four occurrences of <FONT COLOR=blue>void *</FONT> in the
definition of <FONT COLOR=blue>apply</FONT>. Based on the actual usage of <FONT COLOR=blue>apply</FONT> the first two
are mapped to <FONT COLOR=blue>int *</FONT> and the latter two are mapped to <FONT COLOR=blue>int * *</FONT>.<BR>
<BR>
This very flexible scheme breaks down when you have inconsistent usage of a
<FONT COLOR=blue>void *</FONT> type, such as in the following code:
<PRE CLASS="verbatim"><FONT COLOR=blue>
void* identity(void* x) { return x; }

int main() {
    int * p = 0;
    int * * res_pp = identity(&amp; p);
    int * res_p    = identity(p);
}
</FONT></PRE>
<a target="_blank" href="examples/ex33.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex33.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
In the above code the <FONT COLOR=blue>identity</FONT> function is used both with <FONT COLOR=blue>int *</FONT> and
<FONT COLOR=blue>int **</FONT> argument. Since CCured cannot find any single non-<TT>WILD</TT> type that
is compatible with all contexts in which the <FONT COLOR=blue>void *</FONT> is used, it is going
to infer that the type of the <FONT COLOR=blue>void *</FONT> argument is <TT>WILD</TT>. And since the
argument is assigned to the result (implicitly due to the <FONT COLOR=blue>return</FONT>
statement) the result type is also <TT>WILD</TT>. (You can use the browser to see
all the different incompatible types that &#8220;flow&#8221; into a <FONT COLOR=blue>void *</FONT>). It
seems that we need a way to tell CCured to treat the two invocations
separately.<BR>
<BR>
CCured has a crude but effective mechanism for doing just that. First, you
have to tell CCured that a function is polymorphic:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredpoly("identity")
</FONT></PRE>
(you can list multiple names in one <FONT COLOR=blue>ccuredpoly</FONT> pragma. The pragma can
 appear anywhere in your program.).<BR>
<BR>
If you tell CCured that a function is polymorphic it will take the following
steps:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
For each call site of the function, CCured will create a copy of the
function and it will assign it the name <FONT COLOR=blue>/*15*/identity</FONT>, where the number
15 is a running counter to ensure that the names are different. 
<LI CLASS="li-enumerate">Then it will perform the usual inference in which case each copy of the
<FONT COLOR=blue>identity</FONT> function is used only once. 
<LI CLASS="li-enumerate">Finally, for each combination of pointer kinds in the
various flavors of <FONT COLOR=blue>identity</FONT> CCured will keep one copy and erase all the
others. 
</OL>
Consider as an example the code from above, in which all pointers are now
<TT>SAFE</TT>. The output contains calls to <FONT COLOR=blue>/*1*/identity</FONT> and <FONT COLOR=blue>/*2*/identity</FONT>
but since they both have the same pointer kinds for the arguments and results,
only the body of <FONT COLOR=blue>/*1*/identity</FONT> is kept:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredpoly("identity")
void* identity(void* x) { return x; }

int main() {
    int * p = 0;
    int * * res_pp = identity(&amp; p);
    int * res_p    = identity(p);
}
</FONT></PRE>
<a target="_blank" href="examples/ex34.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex34.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If the copies of the polymorphic function do not all have the same pointer
kind then multiple definitions are kept, as in the code below where we have
both a <TT>SAFE</TT> and a <TT>WILD</TT> copy of the <FONT COLOR=blue>identity</FONT> function:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredpoly("identity")
void* identity(void* x) { return x; }

int main() {
    int * __WILD p = 0;
    int * * res_pp = identity(&amp; p);
    int * res_p    = identity(p);
}
</FONT></PRE>
<a target="_blank" href="examples/ex35.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex35.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
<!--TOC paragraph Polymorphic types-->

<H5 CLASS="paragraph">Polymorphic types</H5><!--SEC END -->
 
A similar mechanism is also available for types. You can add in the arguments
of the <FONT COLOR=blue>ccuredpoly</FONT> pragma strings like <FONT COLOR=blue>"struct list"</FONT> to say that a copy of
<FONT COLOR=blue>struct list</FONT> must be created for each occurrence in the program. The
inference will then find out which of the copies have to be compatible and at
the very end will keep only one copy for each kind. Note however that this
form of polymorphism does not have any run-time cost because only types are
duplicated. It will however slow down the CCured type inference. <BR>
<BR>
Note: If the polymorphism directives do not seem to take any effect, pass the
 <TT>-verbose</TT> to ccured to see how it parses them.<BR>
<BR>
For example, here is how you would write polymorphic list length:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredpoly("length", "struct list")
struct list {
   void *car;
   struct list *cdr;
};

int length(struct list *l) {
  for(int i = 0; l; i ++, l=l-&gt;cdr) ;
}

int main() {
    struct list list_of_int = { 5, 0 };
    struct list list_of_wild_ptr = { (int * __WILD)5, 0 };
    struct list wild_list = { 5 , (struct list * __WILD)0 };

    int l1 = length(&amp; list_of_int);
    int l2 = length(&amp; list_of_wild_ptr);
    int l3 = length(&amp; wild_list);
}
</FONT></PRE>
<a target="_blank" href="examples/ex36.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex36.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
You can see in the browser information that the references to <TT>struct list</TT>
have been replaced with separate names such as <TT>struct /*45*/list</TT>. <BR>
<BR>
In the case of recursive structures (whose name is refered directly or
indirectly in the name of the fields), the fields use the same version of the
structure as the structure itself. <BR>
<BR>
CCured has polymorphism for types and for functions because those are the
entities that can be copied legally in C. <EM>There is no similar
polymorphism for data variables, nor should there be.</EM>. <BR>
<BR>
If you have a type name for a polymorphic structure, then CCured will replace
 all occurrences of the type name with a reference to the structure itself,
 meaning that each use of the type name gets its own independent copy. <BR>
<BR>
<!--TOC section User-defined memory allocators-->

<H2 CLASS="section"><A NAME="htoc50">7.2</A>&nbsp;&nbsp;User-defined memory allocators</H2><!--SEC END -->
<A NAME="sec-malloc"></A>
If your program has a user-defined memory allocator that is used to allocate
data of different types then its return type will be <TT>WILD</TT> and so will be
all of the pointers you store with the allocated area. Declaring such a
function to be polymorphic will likely not help because the function is
probably using a global data structure (the allocation buffer) that is shared
by all polymorphic copies of the function.<BR>
<BR>
CCured allows you to declare a function to be a user-defined memory allocator
using one of the following pragmas:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredalloc("myfunc", &lt;zerospec&gt;, &lt;sizespec&gt;)
&lt;zerospec&gt; ::= zero | nozero
&lt;sizespec&gt; ::= sizein(k) | sizemul(k1, k2)
</FONT></PRE>
The <FONT COLOR=blue>zero</FONT> argument means that the allocator zeroes the allocated area.
Otherwise CCured will zero it itself, if it contains pointers. The
<FONT COLOR=blue>sizein(k)</FONT> argument means that the allocator is being passed the size (in
bytes) of the area to be allocated in argument number <I>k</I> (counting starts at
1). The <FONT COLOR=blue>sizemul(k1, k2)</FONT> argument means that the allocator allocates a
number of bytes equal to the product of the arguments number <I>k</I>1 and <I>k</I>2.<BR>
<BR>
For example the following are the pragmas for the standard library allocators
<FONT COLOR=blue>malloc</FONT> and <FONT COLOR=blue>calloc</FONT>:
<PRE CLASS="verbatim"><FONT COLOR=blue>
void* malloc(unsigned int size);
#pragma ccuredalloc("malloc", nozero, sizein(1))
void* calloc(unsigned int nr_elems, unsigned int size);
#pragma ccuredalloc("calloc", zero, sizemul(1, 2))
</FONT></PRE>
A memory allocator should have return type <FONT COLOR=blue>void *</FONT>. In the pre-ANSI C days 
allocators were written with the type <FONT COLOR=blue>char *</FONT>. Once you declare a function
to be allocator, its return type will be changed to <FONT COLOR=blue>unsigned long</FONT>. At all
call sites CCured will examine what kind of data is being allocated and will
construct the metadata for it. <BR>
<BR>
Note that declaring a function an allocator has the effect of also making it
polymorphic. This means that CCured will create as many copies of your
allocators as you have allocation sites. (After curing only copies with
distinct calling convention will be kept, however.)<BR>
<BR>
Note that when you declare a custom-memory allocator as such, CCured will
trust that you are not going to re-use the memory area that you return. This
means that you can use this feature to write unsafe programs in CCured. The
following program will succeed in trying to dereference the address 5!
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma curealloc("myalloc", sizein(1), zero)
int data[8];
void* myalloc(int sz) {
  return data;
}
int main() {
 int ** p = (int **)myalloc(8);
 data[1] = 5; 
 return *p[1]; // Will dereference 5 !!!
}
</FONT></PRE>
<a target="_blank" href="examples/ex37.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex37.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Most often the custom-memory allocators are just wrappers around the system
<TT>malloc</TT>. In that case there is no danger of unsoundness. <BR>
<BR>
Note also that CCured relies on the fact that the result of the custom-memory
allocators is assigned to a variable of the right type. It is from the
type of the destination of the allocator, or from the type cast with which the
allocators is used, that CCured knows what kind of metadata to create. <BR>
<BR>
<!--TOC section Pointers with Run-Time Type Information-->

<H2 CLASS="section"><A NAME="htoc51">7.3</A>&nbsp;&nbsp;Pointers with Run-Time Type Information</H2><!--SEC END -->
<A NAME="sec-rtti"></A>
There are many C programs in which <FONT COLOR=blue>void *</FONT> pointers are used
non-parametrically. An example is a global variable (of type <FONT COLOR=blue>void *</FONT>) that
is used to store values of different types at different times. Consider for
example the following code, where CCured is forced to infer that the <FONT COLOR=blue>g</FONT>
pointer has kind <TT>WILD</TT> because the <FONT COLOR=blue>struct foo</FONT> and <FONT COLOR=blue>struct bar</FONT> are
incompatible:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct foo { 
  int f1;
} gfoo;

struct bar {
  int * f1;
  int f2;
} gbar;

void * g;

int main() {
  int acc = 0;
  g = (void *)&amp;gfoo; 
  acc += ((struct foo *)g)-&gt;f1;
  g = (void *)&amp;gbar; 
  acc += ((struct bar *)g)-&gt;f2;
  return acc;
}
</FONT></PRE>
<a target="_blank" href="examples/ex38.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex38.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
In this example <FONT COLOR=blue>g</FONT> is used polymorphically but not in a way that could be
handled through our support of polymorphism. (This form of polymorphism is
called non-parametric polymorphism.) CCured will consider the casts on <FONT COLOR=blue>g</FONT>
as bad and will mark those pointers <TT>WILD</TT>. <BR>
<BR>
CCured contains special support for handling such cases, by tagging the
polymorphic values with information about their actual type. To enable this
behavior you must use the <TT>RTTI</TT> pointer kind qualifier on the polymorphic
pointer. Consider again the example from before but with a <FONT COLOR=blue>RTTI</FONT>
annotation:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct foo { 
  int f1;
} gfoo;

struct bar {
  int * f1;
  int f2;
} gbar;

void * __RTTI g;

int main() {
  int acc = 0;
  g = (void *)&amp;gfoo; 
  acc += ((struct foo *)g)-&gt;f1;
  g = (void *)&amp;gbar; 
  acc += ((struct bar *)g)-&gt;f2;
  return acc;
}
</FONT></PRE>
<a target="_blank" href="examples/ex39.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex39.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If you use the browser, you will see that there are no more bad casts and no
<TT>WILD</TT> pointers in this example. If you also look at the CCured output for
the above example you will see that instead the <FONT COLOR=blue>g</FONT> variable is now
represented using two words, one to store its value and another to store the
actual type of the pointer it contains. This type is created when <FONT COLOR=blue>g</FONT> is
assigned to and is checked when <FONT COLOR=blue>g</FONT> is used. <BR>
<BR>
CCured can work with run-time type information only for certain pointer
types. We call such types as <EM>extensible</EM> and for each type we also
construct a name. Specifically, the extensible types are:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>void</FONT>, named <FONT COLOR=blue>"void"</FONT>
<LI CLASS="li-itemize">A structure or union type, in which case the name is the letter <FONT COLOR=blue>"S"</FONT>
followed by the name of the structure or union type. Equivalently it can be a
<FONT COLOR=blue>typedef</FONT> name for a structure or union type. 
<LI CLASS="li-itemize">A <FONT COLOR=blue>typedef</FONT> (that <EM>does not</EM> refer to a structure or union type),
in which case the name is the letter <FONT COLOR=blue>"T"</FONT> followed by the type name.
However, since CCured eagerly unrolls typedefs, you  bf should give the
<FONT COLOR=blue>__NOUNROLL</FONT> attribute:
<PRE CLASS="verbatim">
typedef int * MY_TYPE_NAME __NOUNROLL;
</PRE></UL>
<TT>RTTI</TT> pointers can be created on by casting from a scalar or a <TT>SAFE</TT> pointer to an
extensible type and can be cast only to scalars and a <TT>SAFE</TT> pointer to an extensible
type. In the example above, <FONT COLOR=blue>struct boo</FONT> and <FONT COLOR=blue>struct bar</FONT> are extensible
pointers and we can cast pointers to these structs to <FONT COLOR=blue>void * RTTI</FONT> and
back. <BR>
<BR>
CCured also supports the <TT>RTTI</TT> pointer kind on pointers whose base type is
different from <FONT COLOR=blue>void</FONT>. Consider the following example: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct foo {
   int *f1;
   int  f2;    
} gfoo;

struct bar {
   int *f3;
   int  f4;
   int  f5;
} gbar;

#pragma ccured_extends("Sbar", "Sfoo")

struct foo * __RTTI g;

int main() {
  int acc = 0;
  g = (struct foo *)&amp;gfoo; 
  acc += g-&gt;f2;
  g = (struct foo *)&amp;gbar; 
  acc += g-&gt;f2;
  acc += ((struct bar *)g)-&gt;f5;
  gfoo.f1 ++; // To make foo.f1 and bar.f3 both FSEQ pointers
  return acc;
}
</FONT></PRE>
<a target="_blank" href="examples/ex40.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex40.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Notice that the <TT>RTTI</TT> pointer kind is used with the base kind <FONT COLOR=blue>struct
foo</FONT>. An <TT>RTTI</TT> pointer is strictly more powerful than a <TT>SAFE</TT> pointer of
the same base type. This means that <FONT COLOR=blue>g</FONT> in the code above can be used to
access the field <FONT COLOR=blue>f1</FONT> and <FONT COLOR=blue>f2</FONT> without any overhead. This is because
CCured enforces the requirement that an <TT>RTTI</TT> pointer of base type
<FONT COLOR=blue>T</FONT> contains only pointer values whose base type <EM>extends</EM> <FONT COLOR=blue>T</FONT>. The
extension relationship is a subset of the physical subtyping relationship: we
say that type <FONT COLOR=blue>T</FONT> <EM>extends</EM> type <FONT COLOR=blue>Q</FONT> if:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Both <FONT COLOR=blue>T</FONT> and <FONT COLOR=blue>Q</FONT> are extensible, and
<LI CLASS="li-itemize">Either <FONT COLOR=blue>T</FONT> and <FONT COLOR=blue>Q</FONT> are the same type, or
<LI CLASS="li-itemize"><FONT COLOR=blue>Q</FONT> is <FONT COLOR=blue>void</FONT>, or
<LI CLASS="li-itemize">There exists a pragma <FONT COLOR=blue>ccured_extends(T, T')</FONT> and <FONT COLOR=blue>T'</FONT> <EM>extends</EM>
<FONT COLOR=blue>Q</FONT>. In this case CCured verifies that it is safe to cast a pointer to <FONT COLOR=blue>T</FONT>
to a pointer to <FONT COLOR=blue>T'</FONT>, using the usual physical subtyping relationships. 
</UL>
The <FONT COLOR=blue>ccured_extends</FONT> pragmas use extensible type names to declare a
extension hierarchy (similar to a single-inheritance class hierarchy) in which
<FONT COLOR=blue>void</FONT> is the top. Note that only extensible types can appear in the
hierarchy and an extensible type can appear at most once on the left-side of a
<FONT COLOR=blue>ccured_extends</FONT> pragma. An <TT>RTTI</TT> pointer can contain values that are
pointers to some extensible base type that extends that of the <TT>RTTI</TT> pointer
itself.<BR>
<BR>
The <TT>RTTI</TT> pointer kind can be applied only to base types that are either
<FONT COLOR=blue>void</FONT> or non-leaf in the extension hierarchy.<BR>
<BR>
For example, in the following code
<PRE CLASS="verbatim">
struct foo { int x; }
struct bar { int y; int z; }
typedef int MY_INT __NOUNROLL;
#pragma ccured_extends("Sbar", "Sfoo")
#pragma ccured_extends("Sfoo", "TMY_INT")
</PRE>
 we can use the <TT>RTTI</TT> pointer kind for <FONT COLOR=blue>struct foo *</FONT> and <FONT COLOR=blue>MY_INT *</FONT>
but not for <FONT COLOR=blue>struct bar</FONT>. Notice that in all declared extension
relationships physical subtyping is respected. <BR>
<BR>
The inferencer will spread the <TT>RTTI</TT> pointer kind backwards through
assignments but only on pointers that can be <TT>RTTI</TT>. If you want to cut short
the propagation of the <TT>RTTI</TT> pointer king you can use the <TT>SAFE</TT> pointer
kind. <BR>
<BR>
To summarize, <TT>RTTI</TT> pointers can be used with the following constraints:
<UL CLASS="itemize"><LI CLASS="li-itemize">
The <TT>RTTI</TT> pointer kind is never inferred by the CCured inferencer. You
must specify it on some pointers and then the inferencer will propagate it. <BR>
<BR>
<LI CLASS="li-itemize">The <TT>RTTI</TT> pointer kind is not able to carry bounds information. Thus
you cannot use it on pointers that are involved in pointer arithmetic. <BR>
<BR>
<LI CLASS="li-itemize">Only pointers to extensible types can be cast to and from <FONT COLOR=blue>RTTI</FONT>
pointer types. Additionally, you may cast scalars into <FONT COLOR=blue>RTTI</FONT> pointers. <BR>
<BR>
<LI CLASS="li-itemize">You must use <FONT COLOR=blue>ccured_extends</FONT> pragmas to declare the extension
hierarchy. <BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=blue>void*</FONT> polymorphism is turned off for the __RTTI types.
</UL>
Interestingly enough the <TT>RTTI</TT> pointer kind can be used to implement in a
type-safe way virtual method dispatch, as shown in the example below:
<PRE CLASS="verbatim"><FONT COLOR=blue>
typedef struct parent {
  void * __RTTI * vtbl; // virtual table, with various types of functions
  int  *f1;             // some field
} Parent;

#pragma ccured_extends("Schild", "Sparent")

typedef struct child {
  void * __RTTI * vtbl;
  int  *f2;
  int   f3;
} Child;

// virtual method foo for class P
// notice that the self parameter is an RTTI. It must 
// be of base type void to ensure that foo_P and foo_C have the 
// same type
int* foo_P(void * __RTTI self_rtti, Parent *x) {
  Parent * self = (Parent *)self_rtti; // downcast
  return self-&gt;f1;
}

// virtual method bar for class P
int * bar_P(void * __RTTI self_rtti) {
  Parent * self = (Parent *)self_rtti;
  return self-&gt;f1;
}

int* foo_C(void * __RTTI self_rtti, Parent *x) {
  Child * self = (Child *)self_rtti;
  return self-&gt;f2 + self-&gt;f3;
}

// Name the types of the virtual methods, to make them extensible
typedef int * FOO_METHOD(void *, Parent *) __NOUNROLL;
typedef int * BAR_METHOD(void *) __NOUNROLL;

// Now the virtual tables
void * vtbl_P[] = { (void*) (FOO_METHOD *)foo_P,
                    (void*) (BAR_METHOD *)bar_P };


// child inherits bar_P
void * vtbl_C[] = { (void*) (FOO_METHOD *)foo_C,
                    (void*) (BAR_METHOD *)bar_P };


int array[8];

// Now the constructors
void ctor_P(Parent * p) {  p-&gt;vtbl = vtbl_P; p-&gt;f1 = array; }

void ctor_C(Child * c) {  c-&gt;vtbl = vtbl_C;  c-&gt;f2 = array;  c-&gt;f3 = 5; }

int main() {
  Parent p;
  Child c;
  Parent * pp = &amp;p, * pc = &amp;c;
  Child  * pc1;
      
  // Construct
  ctor_P(&amp;p); ctor_C(&amp;c);

  // Now try a downcast
  pc1 = (Child * __RTTI)pc;
  // Now invoke some virtual methods
  {
    FOO_METHOD *pfoo = (FOO_METHOD *) pp-&gt;vtbl[0];
    pfoo((void *)pp, pc);
    pfoo = (FOO_METHOD *) pc-&gt;vtbl[0];
    pfoo1((void *)pc, pp);  
   }
}
</FONT></PRE>
<a target="_blank" href="examples/ex41.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex41.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Notice the use of the <FONT COLOR=blue>__NOUNROLL</FONT> typedefs for the function types. <BR>
<BR>
<!--TOC subsection Implementation Details-->

<H3 CLASS="subsection"><A NAME="htoc52">7.3.1</A>&nbsp;&nbsp;Implementation Details</H3><!--SEC END -->

CCured collects all extensible types in your program (either those declared
using the <FONT COLOR=blue>ccured_extends</FONT> pragma or those that are used in casts to and
from <TT>RTTI</TT> pointers) and constructs the extension hierarchy. An encoding of
this hierarchy is dumped in the resulting code in the array <FONT COLOR=blue>RTTI_ARRAY</FONT>.
Each entry in the array corresponds to an extensible type and it contains the
difference between the entry corresponding to the parent of the extensible
entry and the index of th current entry. The root of the extension hierarchy
is always at index 0 and that entry contains 0. The function
<FONT COLOR=blue>CHECK_RTTICAST</FONT> is used to walk this encoding to verify a cast from a
<TT>RTTI</TT> pointer into a <TT>SAFE</TT> pointer or another <TT>RTTI</TT> pointer. <BR>
<BR>
<!--TOC section Specifying Trusted Code-->

<H2 CLASS="section"><A NAME="htoc53">7.4</A>&nbsp;&nbsp;Specifying Trusted Code</H2><!--SEC END -->
<A NAME="sec-trusted"></A>
In this section we describe a few mechanisms that you can use to override
CCured's reasoning. These are powerful mechanisms but you can use them to
write unsafe code. <BR>
<BR>
<!--TOC subsection Trusted casts-->

<H3 CLASS="subsection"><A NAME="htoc54">7.4.1</A>&nbsp;&nbsp;Trusted casts</H3><!--SEC END -->

Occasionally there are casts in your program that are judged as bad, yet you
know that they are sound and it is too inconvenient to change the program to
expose the soundness to CCured. In that case, you can use the
<FONT COLOR=blue>__trusted_cast</FONT> built-in function. In the following example we know that
the <FONT COLOR=blue>boxedint</FONT> type can encode an integer (if odd) or a pointer to a
<FONT COLOR=blue>boxedint</FONT> if even. We could use <TT>RTTI</TT> pointers to encode this safely in
CCured. Or, we can use a trusted cast:
<PRE CLASS="verbatim"><FONT COLOR=blue>
typedef int boxedint; // If even, then a pointer to a boxedint
int unroll(boxedint x) {
  if(x &amp; 1) return x;
  return unroll(* (int*)__trusted_cast(x));
}
</FONT></PRE>
<a target="_blank" href="examples/ex42.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex42.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
CCured will not complain if the argument and result type of
<FONT COLOR=blue>__trusted_cast</FONT> are incompatible. However, it will ensure the following:
<UL CLASS="itemize"><LI CLASS="li-itemize">
A <FONT COLOR=blue>__trusted_cast</FONT> acts as a cast from the point of view of
 propagating the <TT>SEQ</TT> and <TT>FSEQ</TT> requirement. This means that both the
 argument and the result type will have the same kind. 
</UL>
For example, in the following example, the variable <FONT COLOR=blue>q</FONT> and the field
<FONT COLOR=blue>f1</FONT> in <FONT COLOR=blue>struct foo</FONT> are made <TT>FSEQ</TT>. The <TT>FSEQ</TT> constraint propagates
back through <FONT COLOR=blue>__trusted_cast</FONT> to <FONT COLOR=blue>p</FONT>.
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct foo {
   int   * f1;
   int     f2;
};
struct bar {
   int   * f1; // This is FSEQ !
   int   * f2;
};
int main(struct bar * p) {
    struct foo * q = __trusted_cast(p);
    p-&gt;f1 ++;        // Make foo.f1 FSEQ
    return q[1].f2; // Make q FSEQ
}
</FONT></PRE>
<a target="_blank" href="examples/ex43.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex43.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If you look carefully at the above examples you will see one of the potential
dangers of using <FONT COLOR=blue>__trusted_cast</FONT>: you are on your own to ensure that the
argument type and the result type match. In the above example, this is not
true because the field <FONT COLOR=blue>f1</FONT> in <FONT COLOR=blue>struct bar</FONT> is <TT>SAFE</TT> while the field
<FONT COLOR=blue>f1</FONT> in <FONT COLOR=blue>struct foo</FONT> is <TT>FSEQ</TT>!<BR>
<BR>
If you want to prevent a pointer arithmetic operation from generating
sequence pointers, you can use the <FONT COLOR=blue>__trusted_add</FONT> function:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int foo(int *p) {
    int * q = __trusted_add(p, 4);
    return *q;
}
</FONT></PRE>
<a target="_blank" href="examples/ex44.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex44.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
You can use a <FONT COLOR=blue>__trusted_cast</FONT> to cast an integer into a pointer. This
works as expected if the type of the resulting pointer is <TT>SAFE</TT> (as in the
example with <FONT COLOR=blue>boxedint</FONT> earlier in this section). But if it is <TT>FSEQ</TT> or
<TT>SEQ</TT> then you will get exactly the same effect as if the
<FONT COLOR=blue>__trusted_cast</FONT> was not there: you will obtain a pointer with null
metadata and thus unusable for memory dereference.<BR>
<BR>
A better way to cast an integer (or a <TT>SAFE</TT> pointer into a <TT>SEQ</TT> or
<TT>FSEQ</TT> one) is to use the <FONT COLOR=blue>__mkptr</FONT> built-in function. This function
takes as a second argument some other pointer whose metadata is used in
constructing the result: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int g[8];
int main() {
  int * __SAFE pg = &amp; g[2];
  int * __SEQ sg = __mkptr(pg, g); // We know that the home area of pg and g
                                   // are the same
  int pg1 = (int) &amp; g[3];
  int * __SEQ sg1 = __mkptr(pg1, g);
  return sg[1] + sg1[1];
}
</FONT></PRE>
<a target="_blank" href="examples/ex45.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex45.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Another useful built-in function is <FONT COLOR=blue>__mkptr_size</FONT>. It allows you to
specify the size of the home area in which a pointer lives:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int g[8];
int main() {
  int * __SAFE pg = &amp; g[2];
  // We know that there is are at least 2 more integers after pg
  int * __SEQ sg = __mkptr_size(pg, 2 * sizeof(int)); 
                                   // are the same
  return sg[1];
}
</FONT></PRE>
<a target="_blank" href="examples/ex46.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex46.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
There are other built-in functions that you can use to achieve various things
behind CCured's back. Those are mostly intended for use in wrappers for the
library functions (which you have to trust anyway). These are described in
Chapter&nbsp;<A HREF="#ch-wrapper">8</A> and declared in <A HREF="ccured.h"><TT>ccured.h</TT></A>. <BR>
<BR>
<!--TOC subsection Turning off curing-->

<H3 CLASS="subsection"><A NAME="htoc55">7.4.2</A>&nbsp;&nbsp;Turning off curing</H3><!--SEC END -->

You can turn the curing off for a fragment of a source file, for a function,
or for a block statement. <BR>
<BR>
You can use the <TT>cure</TT> pragma to turn curing off for a fragment of a source
file (in CCured pragmas can only appear at global scope and therefore you
cannot use this mechanism to turn curing off for part of the definition of a
global function):
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * g; // This is a pointer to several integers
         // but we do not want to make it SEQ
#pragma ccured(off)
int foo() {
   return g[2]; // CCured won't see this and will leave g SAFE
                // But also CCured won't check this code
}
#pragma ccured(on)
</FONT></PRE>
<a target="_blank" href="examples/ex47.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex47.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Alternatively, you can add the <TT>nocure</TT> attribute to a function to tell
CCured to not cure this function:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * g; // This is a pointer to several integers
         // but we do not want to make it SEQ

// We must put the attribute in a prototype
int foo(void) __NOCURE;
int foo(void) {
   return g[2]; // CCured won't see this and will leave g SAFE
                // But also CCured won't check this code
}
</FONT></PRE>
<a target="_blank" href="examples/ex48.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex48.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
At a finer-grained level, you can use the <TT>__NOCUREBLOCK</TT> attribute with
a block statement:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * g; // This is a pointer to several integers
         // but we do not want to make it SEQ

int foo(void) { 
   int res;
   { __NOCUREBLOCK
     res = g[2]; // CCured won't see this and will leave g SAFE
   }
   return res; 
}
</FONT></PRE>
<a target="_blank" href="examples/ex49.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex49.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
In all of these cases, the CCured inferencer does not even look at the
non-cured portions of the code. However, CCured will at least change the
non-cured code to access the fat pointers properly. For example, in the
following example the global <FONT COLOR=blue>g</FONT> is a sequence pointer. While CCured will
not complain about the unsafe cast to <FONT COLOR=blue>int **</FONT>, it will make sure that at
least the proper component of <FONT COLOR=blue>g</FONT> is used:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * g; // This will be FSEQ

int ** foo(void) { 
   int res = g[2]; // Make g FSEQ
   { __NOCUREBLOCK
     return (int **)g; // But not WILD
   }
}
</FONT></PRE>
<a target="_blank" href="examples/ex50.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex50.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Finally, to avoid curing a whole source file (say <TT>trusted_foo.c</TT>), you can
use the <TT>&ndash;leavealone=trusted</TT> argument to CCured. All source files whose
names start with the given &#8220;leave alone&#8221; prefix, are not merged and are not
scanned by CCured at all. Instead they are compiled with <TT>gcc</TT> and linked in
the final executable. <BR>
<BR>
<!--TOC chapter Writing Wrappers-->

<H1 CLASS="chapter"><A NAME="htoc56">Chapter&nbsp;8</A>&nbsp;&nbsp;Writing Wrappers</H1><!--SEC END -->
<A NAME="ch-wrapper"></A>
C programs require linking with external libraries before they can be run.
Most often this is just the standard C library but occasionally your program
might want to use other libraries as well. Often you do not want to
process the library code with CCured, either because you do not have the
source code or because it would be inconvenient to do so. There are several
problems that arise when you link code that was cured with regular code:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Since CCured does not inspect the library code it is possible for your
program to be unsafe. This can happen even for correctly written libraries if
the client code passes the wrong arguments. 
<LI CLASS="li-itemize">Much more seriously, CCured alters the layout of some data structures to
insert the metadata for the pointers that they contain. This essentially means
that CCured alters the calling convention for functions whose parameter or
return types involve pointers. Linking cured code with a regular library
is a disaster waiting to happen. CCured detects at link time when this is a
problem but it is up to you to provide a solution, as explained in the rest
of this chapter.
</UL>
Both of the above problems can be solved by interposing small <EM>wrapper</EM>
functions around calls to the external functions. Such a wrapper function can
perform the necessary checks on the arguments (thus addressing the first
problem above) and can also perform some conversions on the arguments and
result values before and after invoking the external function (thus addressing
the second problem above). However, to write a wrapper you must understand the
input-output behavior of the function (i.e., you must read the <FONT COLOR=blue>man</FONT>-page
entry for that function). When writing wrappers you can use a number of
built-in functions described in Section&nbsp;<A HREF="#sec-wrapperhelper">8.5</A>.<BR>
<BR>
Before we look at how one writes wrapper functions, we'll explain how CCured
detects the need for a wrapper and how it reports it to you. CCured changes
the name of all functions that it processes by adding a suffix describing the
kinds of the pointers involved in the prototype of the function. This process
is called name mangling and is described in Section&nbsp;<A HREF="#sec-mangling">8.1</A>. For example,
consider the <FONT COLOR=blue>strchr</FONT> function from the standard library
(it returns NULL or a pointer
to the first occurrence of <FONT COLOR=blue>chr</FONT> into the <FONT COLOR=blue>str</FONT> argument):
<PRE CLASS="verbatim"><FONT COLOR=blue>
char* strchr(char* str, int chr);
</FONT></PRE>
Most likely CCured will view code that uses the returned pointer as a 
manipulating a pointer to a sequence,
and will require that the result of <FONT COLOR=blue>strchr</FONT> be a <TT>FSEQ</TT> pointer. In the
cured code you will see the following prototype for <FONT COLOR=blue>strchr</FONT> in that case:
<PRE CLASS="verbatim"><FONT COLOR=blue>
fseqp_char strchr_fs(char* __SAFE str, int chr);
</FONT></PRE>
Note that CCured has added a suffix <FONT COLOR=blue>_fs</FONT> to the name of the function to
say that its return value is a <TT>FSEQ</TT> pointer. When the code is passed to
<FONT COLOR=blue>gcc</FONT> to link you will likely see the following error message:
<PRE CLASS="verbatim"><FONT COLOR=blue>
main.c: undefined reference to `strchr_fs`
</FONT></PRE>
This is how you learn that the cured code requires a <FONT COLOR=blue>strchr</FONT> with a
different calling convention than the one provided by the library. (If CCured
had left alone both the type and the name of <FONT COLOR=blue>strchr</FONT> the linker would
not have complained but the program would have behaved incorrectly at
run-time.). <BR>
<BR>
In the next section we describe in detail the name mangling algorithm, even
though it is probably better to use the browser to inspect the type of the
undefined mangled functions. <BR>
<BR>
<!--TOC section Name Mangling-->

<H2 CLASS="section"><A NAME="htoc57">8.1</A>&nbsp;&nbsp;Name Mangling</H2><!--SEC END -->
<A NAME="sec-mangling"></A>
There are two forms of mangling: shallow and deep. Shallow mangling
differentiates types without descending into structures. It is less verbose
and is used on all functions and variables defined in the code being cured.
Deep mangling does consider the types of the structure fields and is used for
imported (used but not defined) symbols. (The <FONT COLOR=blue>&ndash;shallowMangling</FONT> command
line option causes all symbols to be mangled using shallow mangling.)<BR>
<BR>
The mangling algorithm scans the type of a global and produces a suffix
that is appended to the name of the global. 
<UL CLASS="itemize"><LI CLASS="li-itemize">
The mangling of a scalar type is empty.<BR>
<BR>
<LI CLASS="li-itemize">The mangling of a function type consists of the mangling of the result
 type followed by the mangling of the formal argument types in order.
 (For <FONT COLOR=blue>vararg</FONT> functions CCured also considers the fields of the
 descriptor structure as if they were formal arguments in place of the
 &#8220;<FONT COLOR=blue>...</FONT>&#8221;. See Section&nbsp;<A HREF="#sec-vararg">9.6</A> for details in vararg functions). <BR>
<BR>
<LI CLASS="li-itemize">The mangling of a pointer type consists of one letter that encodes the
kind of pointer, followed by the mangling of the base type, as
follows: 
 <UL CLASS="itemize"><LI CLASS="li-itemize">
 <FONT COLOR=blue>s</FONT> for <TT>SAFE</TT>
 <LI CLASS="li-itemize"><FONT COLOR=blue>f</FONT> for <TT>FSEQ</TT>
 <LI CLASS="li-itemize"><FONT COLOR=blue>q</FONT> for <TT>SEQ</TT>
 <LI CLASS="li-itemize"><FONT COLOR=blue>i</FONT> for <TT>INDEX</TT>
 <LI CLASS="li-itemize"><FONT COLOR=blue>w</FONT> for <TT>WILD</TT>
 <LI CLASS="li-itemize"><FONT COLOR=blue>rs</FONT> for <TT>RTTI</TT> (a <TT>SAFE</TT>pointer with RTTI information)
 <LI CLASS="li-itemize"><FONT COLOR=blue>rf</FONT> for <TT>FSEQR</TT> (an <TT>FSEQ</TT>pointer with RTTI information)
 <LI CLASS="li-itemize"><FONT COLOR=blue>rs</FONT> for <TT>SEQR</TT> (a <TT>SEQ</TT>pointer with RTTI information)
 <LI CLASS="li-itemize"><FONT COLOR=blue>v</FONT> for a <FONT COLOR=blue>va_list</FONT> in a vararg function. 
 <LI CLASS="li-itemize"><FONT COLOR=blue>t</FONT> for a tagged function. If you get a linker error on
 &#8220;<TT>foo_t</TT>&#8221;, it probably means you are missing the declaration for
 function &#8220;foo&#8221; (and as a result the inference algorithm made worst-case
 assumptions about it).
 </UL><BR>
<BR>
<LI CLASS="li-itemize">The mangling of an array is the mangling of the element type, preceded
by <FONT COLOR=blue>l</FONT> (lowercase L) if the array has a length word.<BR>
<BR>
<LI CLASS="li-itemize">The mangling of a structure or union type is empty for shallow mangling.
For deep mangling it is <FONT COLOR=blue>c</FONT> (for &#8220;composite&#8221;) followed by the mangling
of field types (only the widest field for a union) followed by a matching
<FONT COLOR=blue>_</FONT>. As an exception, if the mangling of the field types is empty or
consisting only of <FONT COLOR=blue>s</FONT> (structure whose fields are scalars or <TT>SAFE</TT>
pointers to scalars) then the mangling of the structure is empty. Note that
under deep mangling only the first occurrence of the structure type in a
global's type is mangled. 
</UL>
The mangling computed as above is appended to the global name, following a
<FONT COLOR=blue>_</FONT> character. As an exception, if the mangling is empty or contains only
<FONT COLOR=blue>s</FONT> characters, then no mangling occurs (and no <FONT COLOR=blue>_</FONT> is inserted). <BR>
<BR>
Here are a few of examples of mangling:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct list {
 void * __WILD data;
 struct list * __SAFE next;
};
struct hash {
 int count;
 struct list * __FSEQ buckets;
};
struct list * __FSEQ getBuckets(struct hash * __SAFE);
// has deep mangling      getBuckets_fcws_scf_
// has shallow mangling   getBuckets_fs

struct twolists {
  struct list * __SEQ  one;
  struct list * __SAFE two;
};
struct twolists * __SAFE getTwoLists(void);
// has deep mangling     getTwoLists_scqcws_s_
// has shallow mangling  getTwoLists

int main() {
  printf("Mangling of struct list = %s\n", CCURED_MANGLING_OF(struct list));
  printf("Mangling of getBuckets = %s\n", CCURED_MANGLING_OF(getBuckets));
}
</FONT></PRE>
Note that types are mangled recursively (you can have nested constructions
<FONT COLOR=blue>c..._</FONT> but a structure is mangled only once in a global's type. <BR>
<BR>
The general rule is that the shallow mangling can be obtained from the deep
mangling be removing all <FONT COLOR=blue>c..._</FONT> sequences (including nested ones). If what
remains is a sequence of <FONT COLOR=blue>s</FONT>'s then the shallow mangling is empty.<BR>
<BR>
CCured has a facility for inquiring about the mangling of a type or variable
at run-time, as shown at the end of the above code. You can use the macro
<FONT COLOR=blue>CCURED_MANGLING_OF</FONT> applied to a type or variable (i.e. anything that can
be the argument of <FONT COLOR=blue>sizeof</FONT>) to obtain a string literal that encodes the
mangling. Perhaps the most important use of this is to detect at run-time
whether a global is compatible with the library or not (its mangling should be
the empty string). We shall see how this is done later in this chapter. CCured
also defines the macro <FONT COLOR=blue>CCURED_HAS_EMPTY_MANGLING</FONT> that yields 1 if its
parameter has empty mangling. This is equivalent to <FONT COLOR=blue>0 == *
CCURED_MANGLING_OF</FONT> but is a compile-time constant (after curing).<BR>
<BR>
<!--TOC section Writing Simple Wrappers-->

<H2 CLASS="section"><A NAME="htoc58">8.2</A>&nbsp;&nbsp;Writing Simple Wrappers</H2><!--SEC END -->

Returning to our <FONT COLOR=blue>strchr</FONT> example, what do we do if the linker complains that
it needs the <FONT COLOR=blue>strchr_fs</FONT> version of the function? The basic idea is that
we write the function <FONT COLOR=blue>strchr_fs</FONT> that in turn calls <FONT COLOR=blue>strchr</FONT> from the
library. The problem with this approach is that over time you might have to
write many versions of <FONT COLOR=blue>strchr</FONT> (such as <FONT COLOR=blue>strchr_qs</FONT>,
<FONT COLOR=blue>strchr_qq</FONT> and many more). CCured provides a relatively simple mechanism
by which you write a wrapper specification and it generates all the required
versions automatically from your specification. Furthermore, the wrapper
specification looks just like a C function (along with some indication to
CCured that this is a wrapper):
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern char* strchr(char*, int);  // Make sure you have a prototype for the 
                                  // function you are wrapping
extern void exit(int);

                                  // Now tell CCured that strchr_wrapper is 
                                  // a wrapper for strchr
#pragma ccuredwrapper("strchr_wrapper", of("strchr"))
char* strchr_wrapper(char* str, int chr) // must match strchr's signature
{
  char* result;
  result = strchr(str, chr);       // Call the underlying function.
  return __mkptr_string(result);   // result should be 0 or a string
}

void foo(char* s){
  char* res = strchr(s, 'q');
  // Taking the address of a wrapped function is handled, too
  char * (*p_strchr)(char *, int) = &amp; strchr;

  if(res != (*p_strchr)(s, 'q')) exit(1);

  res ++; // Make sure res is __FSEQ
}
</FONT></PRE>
<a target="_blank" href="examples/ex51.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex51.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Notice that we have used the <FONT COLOR=blue>__mkptr_string</FONT> helper function that takes
in a standard null-terminated C string and produces any required fat pointer
to it. This is done using a simple trick: we let CCured mangle the helper
function name as needed and we provide in <FONT COLOR=blue>ccuredlib.c</FONT> all the required
versions. Since the argument should always be a SAFE pointer the versions that
we provide are: <FONT COLOR=blue>__mkptr_string_fs</FONT>, <FONT COLOR=blue>__mkptr_string_qs</FONT> and, of
course, <FONT COLOR=blue>__mkptr_string</FONT>, which is the identity function. These
functions produce the necessary metadata by looking for the null-termination.
Call the <FONT COLOR=blue>__mkptr_string</FONT> function only on the result of trusted library
functions, or else bad things might happen (e.g., because the string
argument may not actually be null-terminated).<BR>
<BR>
Now, if you click the &#8220;Browse&#8221; link for the above code fragment you will
see several things:
<UL CLASS="itemize"><LI CLASS="li-itemize">
CCured creates a new instance of <FONT COLOR=blue>strchr_wrapper</FONT> for each call site
or place where the address of <FONT COLOR=blue>strchr</FONT> is taken, whose names differ in the
<FONT COLOR=blue>/*xxx*/</FONT> prefix. Each instance has its own body. In other words, all
wrappers are polymorphic (see Section&nbsp;<A HREF="#sec-poly">7.1</A>) which means that the constraints
from one call site will not pollute other call-sites.<BR>
<BR>
<LI CLASS="li-itemize">CCured replaces all occurrences of <FONT COLOR=blue>strchr</FONT> (either in call sites, or
where their address is taken with a distinct instance of the
<FONT COLOR=blue>strchr_wrapper</FONT>). (Note, this means that you should not compare the
address of such functions.)<BR>
<BR>
<LI CLASS="li-itemize">Since <FONT COLOR=blue>res</FONT> is required to be <TT>FSEQ</TT> the return type of the first
instance of the <FONT COLOR=blue>strchr</FONT> wrapper must also have a <TT>FSEQ</TT> kind. But the
return type of the second instance is <TT>SAFE</TT>. 
</UL>
Now if you look at the CCured output for the above example you will see that
the code has two instances of the wrapper, one for each calling convention.
(If you had more calls sites for <FONT COLOR=blue>strchr</FONT> CCured will coalesce all wrappers
that end up having the same mangling.)<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
 It is very important to write the wrappers such that the actual call to the
underlying function has arguments and result values that are <TT>SAFE</TT> (i.e.,
values that use the standard C representation)! This
means two things:
<UL CLASS="itemize"><LI CLASS="li-itemize">
You must &#8220;isolate&#8221; the arguments and result values of the actual call
from the corresponding elements of the wrapper. Otherwise, CCured will flow
the constraints of the latter straight to the prototype for the underlying
function, which ends up with a mangled name again. <BR>
<BR>
Consider the following (wrong) version of wrapper:
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern char* strchr(char*, int); 
#pragma ccuredwrapper("strchr_wrapper2", of("strchr"))
char* strchr_wrapper2(char* str, int chr)
{
  char* result;
  result = strchr(str, chr);
  return result;                   // !! We return the result directly
}

void foo(char* s){
  char* res = strchr(s, 'q');
  res ++; // Force res to be __FSEQ
}
</FONT></PRE>
<a target="_blank" href="examples/ex52.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex52.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
You get the following error message from CCured:
<PRE CLASS="verbatim">
main.c:10: Error: strchr appears to be external
  (it has a wrapper), yet it has a mangled name: strchr_fs.
  Did you forget to use __ptrof and a version of __mkptr?
 For more information, consult the online documentation on
  "Writing Wrappers" chapter.
</PRE>
 Click the &#8220;Browse&#8221; link for this code to see that <FONT COLOR=blue>strchr</FONT> has a <TT>FSEQ</TT>
return type and that this happens because of the return instruction in the
<FONT COLOR=blue>strchr_wrapper</FONT>. The solution is to always &#8220;isolate&#8221; the return values
using one of the <FONT COLOR=blue>__mkptr</FONT>, <FONT COLOR=blue>__mkptr_size</FONT> and <FONT COLOR=blue>__mkptr_string</FONT>
(all documented in <A HREF="ccured.h"><TT>ccured.h</TT></A>), as we have done in the first
wrapper we wrote. <BR>
<BR>
But even the supposedly good wrapper has similar problems. The argument
<FONT COLOR=blue>str</FONT> is passed directly to <FONT COLOR=blue>strchr</FONT>, so it is possible that some
constraints on that argument from the client program will flow to the
underlying <FONT COLOR=blue>strchr</FONT>. To prevent this problem you should change the wrapper
as follows:
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern char* strchr(char*, int); 
#pragma ccuredwrapper("strchr_wrapper3", of("strchr"))
char* strchr_wrapper3(char* str, int chr)
{
  char* result;
  result = strchr(__ptrof_nocheck(str), chr); // Isolate the argument str 
  return __mkptr_string(result);
}

void foo(char* s){
  char* res = strchr(s, 'q');
  res ++; // Force res to be __FSEQ
}
</FONT></PRE>
<a target="_blank" href="examples/ex53.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex53.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The <FONT COLOR=blue>__ptrof_nocheck</FONT> function (described in <A HREF="ccured.h"><TT>ccured.h</TT></A>)
extracts the pointer value from a potentially fat pointer. As its
name says, it does no checks on that value. We'll describe other variants that
do some checking later on. <BR>
<BR>
<LI CLASS="li-itemize">Another way to flow un-<TT>SAFE</TT> pointers into the call to the underlying
function is to perform pointer arithmetic or casts in the wrapper code.
Consider this example of wrapper that does all sorts of bad things:
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern char* strchr(char*, int);
extern int strlen(char *); 
#pragma ccuredwrapper("strchr_wrapper4", of("strchr"))
char* strchr_wrapper4(char* str, int chr)
{
  char * __SAFE result;
  char * __SAFE safestr = __ptrof_nocheck(str);
  result ++; // Make it FSEQ! Bad
  result = __trusted_add(result, 1); // Do this if you want to add

  result = (int***)result; // Cast, make it WILD! Bad
  result = (int***)__trusted_cast(result); // Do this if you want to cast
  
  result = strchr(safestr, chr);
  return __mkptr_string(result);
}

void foo(char* s){
  char* res = strchr(s, 'q');
  res ++; // Force res to be __FSEQ
}
</FONT></PRE>
<a target="_blank" href="examples/ex54.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex54.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If you need to do pointer arithmetic or casts you must do them behind CCured's
back (e.g. using __trusted_add or __trusted_cast). No new unsoundness
is introduced by calling potentially unsafe functions in the
wrapper, since the wrapper itself must be trusted. See Chapter&nbsp;<A HREF="#ch-nowild">7</A> for
other methods to work behind CCured's back.
</UL>
So far we have addressed the issue of compatibility with the library but it
is still possible for the client program to call <FONT COLOR=blue>strchr</FONT> with the wrong
arguments, thus provoking a memory safety violation in the library itself. To
prevent this we add to the wrapper code that verifies that the input argument
is a valid string (all the characters up to and including the null-termination
are in the home area):
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern char* strchr(char*, int); 
#pragma ccuredwrapper("strchr_wrapper5", of("strchr"))
char* strchr_wrapper5(char* str, int chr)
{
  char* result;
  result = strchr(
                  __stringof(str), // Check that str is a string
                  chr              
                  );
  return result;                   //Passing the return value directly
}

void foo(char* s){
  char* res = strchr(s, 'q');
  res ++; // Force res to be __FSEQ
}
</FONT></PRE>
<a target="_blank" href="examples/ex55.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex55.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The <FONT COLOR=blue>__stringof</FONT> function first checks that str is a valid string and
then returns the pointer value (leaving the metadata behind). Alternatively,
the <FONT COLOR=blue>__ptrof</FONT> function performs bounds checks on <TT>FSEQ</TT> and <TT>SEQ</TT>
pointers and null checks as well. <BR>
<BR>
If you browse the above example you will observe that now the &#8220;s&#8221; argument
of the <FONT COLOR=blue>foo</FONT> function is not <TT>SAFE</TT> anymore but is <TT>FSEQ</TT>. If you
investigate you find that this is required by the <FONT COLOR=blue>__string_of</FONT> function
itself (in order to be able to perform safely the check that there is a
null-character before the end of the memory area!). <BR>
<BR>
There are quite a few helper functions that you can use in the wrapper.
They are all documented in <A HREF="ccured.h"><TT>ccured.h</TT></A>. <BR>
<BR>
<BR>
<BR>
<BR>
<BR>
 We have not yet discussed the issue of where to put the wrappers that you
write. The rule is that the wrapper, along with the #pragma that declares it,
must appear somewhere in the project (CCured merges all files together so it
will eventually see it). You should put the pragma next to the wrapper
function because otherwise the CIL front-end might think that the wrapper is
not used and will remove it from the code!<BR>
<BR>
To ensure that you have the wrapper available whenever you want to use the
library it is a good idea to put the wrapper in the header file that declares
the corresponding function (in that case we suggest you use &#8220;__inline
static&#8221; as declaration specifiers). We also suggest that you put the wrappers
at the end of such header files to ensure that you have the prototypes for the
wrapper functions already. We have done just that with the wrappers
that we wrote for the standard C library. You can find them in files in
<FONT COLOR=blue>cil/include</FONT> directory. For example the <FONT COLOR=blue>stdio_wrappers.h</FONT> file contains
the wrappers for the <FONT COLOR=blue>stdio.h</FONT> standard header (We use a patched version of
<FONT COLOR=blue>stdio.h</FONT> that includes <FONT COLOR=blue>stdio_wrappers</FONT> at the end.) We suggest that you
look through those files to find more examples of wrappers. <BR>
<BR>
<!--TOC section Writing Complex Wrappers-->

<H2 CLASS="section"><A NAME="htoc59">8.3</A>&nbsp;&nbsp;Writing Complex Wrappers</H2><!--SEC END -->

For most wrappers the description from the previous section should be enough.
Some wrappers, however, are more complicated. We discuss in this section some
of these complications, along with the CCured mechanisms that address them,
for a function similar to the <FONT COLOR=blue>sendmsg</FONT> function (defined in
<FONT COLOR=blue>&lt;socket.h&gt;</FONT>). Here are the required declarations, along with a code
fragment that uses <FONT COLOR=blue>sendmsg</FONT> in such a way that its <FONT COLOR=blue>msg_iov</FONT> field
becomes FSEQ.:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int sendmsg(int fd, struct msghdr * msg, int flags);
struct msghdr {
     void         * msg_name;       /* optional address */
     int            msg_namelen;    /* size of address */
     struct iovec * msg_iov;        /* scatter/gather array */
     int            msg_iovlen;     /* # elements in msg_iov */
     void         * msg_control;    /* ancillary data, see below */
     int            msg_controllen; /* ancillary data buffer len */
     int            msg_flags;      /* flags on received message */
};
struct iovec {
     char*   iov_base;  /* The base address of the fragment */
     int     iov_len;   /* Length in bytes of the fragment */
};

int foo(int fd, struct iovec *array, int array_len) {
    struct msghdr msg = { 0, 0, array, array_len, 0, 0, 0};
    // Make the msg_iov be FSEQ
    struct iovec * foo = msg.msg_iov + 1;
    return sendmsg(fd, &amp;msg, 0);
}
</FONT></PRE>
<a target="_blank" href="examples/ex56.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex56.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Since our code does arithmetic on the <FONT COLOR=blue>msg_iov</FONT> field, it becomes <TT>FSEQ</TT>
and the required mangling for <FONT COLOR=blue>sendmsg</FONT> is <FONT COLOR=blue>sendmsg_scsfs</FONT> (all the other
pointers in the prototype remain <TT>SAFE</TT>). Let us try the wrapper-writing
method from above (isolate the arguments of <FONT COLOR=blue>sendmsg</FONT>):
<PRE CLASS="verbatim"><FONT COLOR=blue>
int sendmsg(int fd, struct msghdr * msg, int flags);
struct msghdr {
     void         * msg_name;       /* optional address */
     int            msg_namelen;    /* size of address */
     struct iovec * msg_iov;        /* scatter/gather array */
     int            msg_iovlen;     /* # elements in msg_iov */
     void         * msg_control;    /* ancillary data, see below */
     int            msg_controllen; /* ancillary data buffer len */
     int            msg_flags;      /* flags on received message */
};
struct iovec {
     char*   iov_base;  /* The base address of the fragment */
     int     iov_len;   /* Length in bytes of the fragment */
};

int foo(int fd, struct iovec *array, int array_len) {
    struct msghdr msg = { 0, 0, array, array_len, 0, 0, 0};
    // Make the msg_iov be FSEQ
    struct iovec * foo = msg.msg_iov + 1;
    return sendmsg(fd, &amp;msg, 0);
}

#pragma ccuredwrapper("sendmsg_wrapper1", of("sendmsg"))
__inline static
int sendmsg_wrapper1(int fd, struct msghdr * msg, int flags) {
  return sendmsg(fd, __ptrof(msg), flags);
}
</FONT></PRE>
<a target="_blank" href="examples/ex57.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex57.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
We still get the error:
<PRE CLASS="verbatim">
ccuredcode.tmp/ex44.c:1: Error: sendmsg appears to be external
  (it has a wrapper), yet it has a mangled name: sendmsg_scsfs_.
  Did you forget to use __ptrof and a version of __mkptr?
 For more information, consult the online documentation on
  "Writing Wrappers".
</PRE>
 This happens because the wrapper and the true <FONT COLOR=blue>sendmsg</FONT> still share all of
the pointer nodes in the <FONT COLOR=blue>struct msghdr</FONT> and <FONT COLOR=blue>struct iovec</FONT>. We must have
two versions of at least <FONT COLOR=blue>struct msghdr</FONT>: one that the client code uses and
one that the library is using. If you browse the above code and look at the
prototype for the <FONT COLOR=blue>sendmsg</FONT> function (not the wrapper) you will see that
CCured has tried to address this issue by creating the structures
<FONT COLOR=blue>msghdr_COMPAT</FONT> and <FONT COLOR=blue>iovec_COMPAT</FONT> (called <FONT COLOR=blue>_COMPAT</FONT> because they
are reachable from the prototype of the wrapped function). But that was not
sufficient in this case: if you browse the code you will see that even the
<FONT COLOR=blue>msg_iov</FONT> field of the new <FONT COLOR=blue>msghdr_COMPAT</FONT> is <TT>FSEQ</TT>. And you get
the following error message:
<PRE CLASS="verbatim">
Error: The suffix for the compatible version of msghdr_COMPAT is sfs. 
This means that you have misused this compatible version. Please check your code.
</PRE>The problem in this case is subtle: because <FONT COLOR=blue>sendmsg</FONT> is declared to take a
<FONT COLOR=blue>struct msghdr</FONT> argument and the result type of <FONT COLOR=blue>__ptrof</FONT> is <FONT COLOR=blue>void *</FONT>,
the CIL front-end has inserted a cast <FONT COLOR=blue>(struct msghdr*)</FONT> in the call to
<FONT COLOR=blue>sendmsg</FONT> in the wrapper. When CCured later decides to change the prototype
of <FONT COLOR=blue>sendmsg</FONT> it does not change the cast also, which makes it appear that an
argument of type <FONT COLOR=blue>struct msghdr *</FONT> is assigned to a formal of type <FONT COLOR=blue>struct
msghdr_COMPAT</FONT>. To prevent this from happening, you must store the result of
the <FONT COLOR=blue>__ptrof</FONT> function in a local variable, whose type you write:
<FONT COLOR=blue>struct msghdr __COMPAT *</FONT>. Note that <FONT COLOR=blue>__COMPAT</FONT> is here an attribute
to the structure name, not part of the name; CCured will do the right thing
when it creates the compatible version of <FONT COLOR=blue>msghdr</FONT>. So, we try the
following:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int sendmsg(int fd, struct msghdr * msg, int flags);
struct msghdr {
     void         * msg_name;       /* optional address */
     int            msg_namelen;    /* size of address */
     struct iovec * msg_iov;        /* scatter/gather array */
     int            msg_iovlen;     /* # elements in msg_iov */
     void         * msg_control;    /* ancillary data, see below */
     int            msg_controllen; /* ancillary data buffer len */
     int            msg_flags;      /* flags on received message */
};
struct iovec {
     char*   iov_base;  /* The base address of the fragment */
     int     iov_len;   /* Length in bytes of the fragment */
};

int foo(int fd, struct iovec *array, int array_len) {
    struct msghdr msg = { 0, 0, array, array_len, 0, 0, 0};
    // Make the msg_iov be FSEQ
    struct iovec * foo = msg.msg_iov + 1;
    return sendmsg(fd, &amp;msg, 0);
}

#pragma ccuredwrapper("sendmsg_wrapper2", of("sendmsg"))
__inline static
int sendmsg_wrapper2(int fd, struct msghdr * msg, int flags) {
  struct msghdr __COMPAT *msg1 = __ptrof(msg);
  return sendmsg(fd, msg1, flags);
}
</FONT></PRE>
<a target="_blank" href="examples/ex58.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex58.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Using <FONT COLOR=blue>__ptrof</FONT> is not enough, however, since the object still has
a <TT>FSEQ</TT> field. CCured detects this and changes the compat version
to have the same <TT>FSEQ</TT> field, so we get the same error as before.
What we should do instead is to make a copy of the structure pointed to
by <FONT COLOR=blue>msg</FONT> and copy the fields one by one. There are several ways in which
CCured can help with that. First, there are some macros that you can use.<BR>
<BR>
You can replace the declaration of <FONT COLOR=blue>msg1</FONT> above with:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  __DECL_COMPAT_STACK(msg1, msghdr, msg);
</FONT></PRE>
This macro (defined and explained in <A HREF="ccured.h"><TT>ccured.h</TT></A>) first
reserves some storage for a <FONT COLOR=blue>struct msghdr_COMPAT</FONT> on the stack (hence the
STACK in the name). Then it declares the <FONT COLOR=blue>msg1</FONT> variable and it copies the
contents of the <FONT COLOR=blue>struct msghdr</FONT> pointed to by <FONT COLOR=blue>msg</FONT> into the local copy.
This copying is done only if necessary (the <FONT COLOR=blue>msg</FONT> pointer is not null and
the structure it points to is not already compatible). Here is the expansion
of the above macro invocation:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  /* Declare the __deepcopy function that we need */                        
  void __deepcopy_msghdr_to_compat(struct msghdr __COMPAT * compat, struct msghdr * fat);
  /* Declare the place where we'll make the copy */                         
  struct msghdr __COMPAT msg1_area;
  struct msghdr * msg1__ptrof = __ptrof_nocheck(msg);
  struct msghdr __COMPAT * msg1 =
    /* We are done if we have NULL or an already compat struct */
    (msg1__ptrof &amp;&amp; (! CCURED_HAS_EMPTY_MANGLING(struct msghdr))) ?
      /* Now do the copying as specified in the argument */
      (__deepcopy_msghdr_to_compat(&amp; msg1__area, msg1__ptrof), &amp; msg1__area)
    : /* No copying is needed. Use a trusted_cast to prevent CCured from 
         connecting the two versions of the structure */
      (struct msghdr __COMPAT *)__trusted_cast(msg1__ptrof);
</FONT></PRE>
Notice that care is taken to avoid copying if not necessary and also to
prevent CCured from connecting directly the two versions of the struct. <BR>
<BR>
There are more macros like <FONT COLOR=blue>__DECL_COMPAT_STACK</FONT>, that allow you to
allocate the space on the heap instead of the stack, or even to avoid copying.
We'll discuss these later. Now we look again at the <FONT COLOR=blue>sendmsg</FONT> wrapper in
which we use the new macro:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int sendmsg(int fd, struct msghdr * msg, int flags);
struct msghdr {
     void         * msg_name;       /* optional address */
     int            msg_namelen;    /* size of address */
     struct iovec * msg_iov;        /* scatter/gather array */
     int            msg_iovlen;     /* # elements in msg_iov */
     void         * msg_control;    /* ancillary data, see below */
     int            msg_controllen; /* ancillary data buffer len */
     int            msg_flags;      /* flags on received message */
};
struct iovec {
     char*   iov_base;  /* The base address of the fragment */
     int     iov_len;   /* Length in bytes of the fragment */
};

int foo(int fd, struct iovec *array, int array_len) {
    struct msghdr msg = { 0, 0, array, array_len, 0, 0, 0};
    // Make the msg_iov be FSEQ
    struct iovec * foo = msg.msg_iov + 1;
    return sendmsg(fd, &amp;msg, 0);
}

#pragma ccuredwrapper("sendmsg_wrapper3", of("sendmsg"))
__inline static
int sendmsg_wrapper3(int fd, struct msghdr * msg, int flags) {
  __DECL_COMPAT_STACK(msg1, msghdr, msg);
  return sendmsg(fd, msg1, flags);
}
</FONT></PRE>
<a target="_blank" href="examples/ex59.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex59.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If you browse this code you will see that in addition to the macro expansion
there is now a definition for the function
<FONT COLOR=blue>__deepcopy_msghdr_to_compat</FONT>. CCured recognizes this name in a
prototype (which is added by the <FONT COLOR=blue>__DECL_COMPAT</FONT> macros) and fills in the
body with code that tries to copy one field at a time from a <FONT COLOR=blue>struct msghdr</FONT>
to a <FONT COLOR=blue>struct msghdr_COMPAT</FONT>. <BR>
<BR>
Here is how CCured fills in the code of deepcopy functions:
<UL CLASS="itemize"><LI CLASS="li-itemize">
For any fields (except those of array types) that do not contain
pointers (i.e. a scalar field, or a substructure with no pointers), an
assignment is generated.
<LI CLASS="li-itemize">For a pointer field, CCured generates code that detects whether a
deepcopy is necessary (the pointer is non-null and it points to a structure
that is not compatible). If a deepcopy is not necessary then an assignment is
generated (with care to avoid connections between the compatible and
incompatible structures). If a deepcopy would be necessary, CCured generates
code that aborts the execution with an error message. 
<LI CLASS="li-itemize">For an array field, CCured generates a loop that iterates over the
elements and generates code that copies each element. 
<LI CLASS="li-itemize">For a structure field, CCured first checks if a corresponding deepcopy
function has been declared or defined. If so, it produces a call to that
function. Otherwise it iterates over the fields and produces code to copy the
fields. 
<LI CLASS="li-itemize">For other kinds of pointers, CCured fails at compile time.
</UL>
For our example, the deepcopy code that CCured generates would do. But such
code might not be what you need. If the <FONT COLOR=blue>iov_base</FONT> pointer in the <FONT COLOR=blue>iovec</FONT>
struct becomes non-<TT>SAFE</TT> then the default deepcopy function will abort. In
that case, you can write the parts of the deepcopy function that you care
about and let CCured fill in the rest. In the next example we show the full
wrapper for <FONT COLOR=blue>sendmsg</FONT>, that works even when the embedded <FONT COLOR=blue>struct iovec</FONT> is
mangled:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int sendmsg(int fd, struct msghdr * msg, int flags);
struct msghdr {
     void         * msg_name;       /* optional address */
     int            msg_namelen;    /* size of address */
     struct iovec * msg_iov;        /* scatter/gather array */
     int            msg_iovlen;     /* # elements in msg_iov */
     void         * msg_control;    /* ancillary data, see below */
     int            msg_controllen; /* ancillary data buffer len */
     int            msg_flags;      /* flags on received message */
};
struct iovec {
     char*   iov_base;  /* The base address of the fragment */
     int     iov_len;   /* Length in bytes of the fragment */
};

int foo(int fd, struct iovec *array, int array_len) {
    struct msghdr msg = { 0, 0, array, array_len, 0, 0, 0};
    // Make the msg_iov be FSEQ
    struct iovec * foo = msg.msg_iov + 1;
    return sendmsg(fd, &amp;msg, 0);
}

extern void* malloc(int);
extern void  free(void*);
#pragma ccuredwrapper("sendmsg_wrapper4", of("sendmsg"))
__inline static
int sendmsg_wrapper4(int fd, struct msghdr * msg, int flags) {
    __DECL_COMPAT_STACK(msg1, msghdr, msg);
    int result = sendmsg(fd, msg1, flags);
    // We can now free the msg_iov (if it was allocated)
    if(msg1-&gt;msg_iov != msg-&gt;msg_iov) {
      free(msg1-&gt;msg_iov);
    }
    return result;
}


__inline static
__DEEPCOPY_TO_COMPAT_PROTO(iovec) {
  compat-&gt;iov_base = __ptrof_nocheck(fat-&gt;iov_base);
}

__inline static
__DEEPCOPY_TO_COMPAT_PROTO(msghdr) {
  // We leave the msg_name and msg_control to CCured
  
  if(CCURED_HAS_EMPTY_MANGLING(* fat-&gt;msg_iov)) {
    // We do not need to copy the msg_iov array
    compat-&gt;msg_iov = __ptrof(fat-&gt;msg_iov);
  } else {
    int len = fat-&gt;msg_iovlen;
    int v;
    compat-&gt;msg_iov = malloc(len * sizeof(compat-&gt;msg_iov[0])); 
    for (v=0; v&lt;len; v++) {
      struct iovec __COMPAT *iptr = __trusted_add(compat-&gt;msg_iov, v);
      __deepcopy_iovec_to_compat(iptr, &amp; fat-&gt;msg_iov[v]);
    } 
  }
}
</FONT></PRE>
<a target="_blank" href="examples/ex60.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex60.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Notice several important things in the bodies for the deepcopy functions:
<UL CLASS="itemize"><LI CLASS="li-itemize">
We use special macros to declare the prototype. These macros always
introduce two formals, one called &#8220;compat&#8221; (of type pointer to compatible
structure), and one called &#8220;fat&#8221; (of type pointer to regular structure). It
is a good idea to use these macros, because they ensure that at least the
prototype is right.<BR>
<BR>
<LI CLASS="li-itemize">In the <FONT COLOR=blue>TO_COMPAT</FONT> function we always assign to the fields pointed to
by the <FONT COLOR=blue>compat</FONT> formal.<BR>
<BR>
<LI CLASS="li-itemize">In each function we assign only the fields for which we want to override
CCured's automatically generated code. CCured scans the body that you wrote
and looks for assignments of the form <FONT COLOR=blue>compat-&gt;fieldname = ...</FONT>. For all
such fields that it finds, it assumes that you are taking care of that field
and does not generate code. Note that you are then responsible for writing the
code for all elements of that field (if it is a structure or array)! Note also
that you should not change the value of the <FONT COLOR=blue>compat</FONT> formal and should not
use some other variable to do the assignment, or else CCured will not notice
it. <BR>
<BR>
<LI CLASS="li-itemize">As in any wrapper, you must be careful to not mix the two versions of
the structure. Thus you must use <FONT COLOR=blue>__trusted_cast</FONT> and <FONT COLOR=blue>__ptrof</FONT> to do
assignments between pointers to different versions of structures. Notice also
that we use <FONT COLOR=blue>__trusted_add</FONT> instead of pointer arithmetic on the
compatible pointer types.<BR>
<BR>
<LI CLASS="li-itemize">You should avoid copying as much as possible (i.e. use the
<FONT COLOR=blue>CCURED_MANGLING_OF</FONT> macro).<BR>
<BR>
<LI CLASS="li-itemize">The code that CCured generates automatically is inserted <EM>before</EM>
the code that you write. But you should not rely on that!</UL>
Now we look briefly at the companion method <FONT COLOR=blue>recvmsg</FONT>. Instead of sending a
message, it receives one. This means that the <FONT COLOR=blue>msg_iov</FONT> data is an output
value, not an input. We use the following wrapper in this case:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int recvmsg(int fd, struct msghdr * msg, int flags);
struct msghdr {
     void         * msg_name;       /* optional address */
     int            msg_namelen;    /* size of address */
     struct iovec * msg_iov;        /* scatter/gather array */
     int            msg_iovlen;     /* # elements in msg_iov */
     void         * msg_control;    /* ancillary data, see below */
     int            msg_controllen; /* ancillary data buffer len */
     int            msg_flags;      /* flags on received message */
};
struct iovec {
     char*   iov_base;  /* The base address of the fragment */
     int     iov_len;   /* Length in bytes of the fragment */
};

int foo(int fd, struct iovec *array, int array_len) {
    struct msghdr msg = { 0, 0, array, array_len, 0, 0, 0};
    // Make the msg_iov be FSEQ
    struct iovec * foo = msg.msg_iov + 1;
    return recvmsg(fd, &amp;msg, 0);
}

extern void* malloc(int);
extern void  free(void*);

#pragma ccuredwrapper("recvmsg_wrapper", of("recvmsg"))
__inline static
int recvmsg_wrapper(int s, struct msghdr *fat_msg, int flags) {
  __DECL_COMPAT_STACK(lean_msg, msghdr, fat_msg);
  int result = recvmsg(s, lean_msg, flags);
  // Copy the contents of lean_msg into fat_msg
  __COPYOUT_FROM_COMPAT(lean_msg, msghdr, fat_msg);
  if(lean_msg-&gt;msg_iov != fat_msg-&gt;msg_iov) {
    // If we allocated new space for msg_iov, free it now
    free(lean_msg-&gt;msg_iov);
  }
  return result;
} 


__inline static
__DEEPCOPY_FROM_COMPAT_PROTO(iovec) {
  // Notice how we use iov_len to construct the metadata for the iov field
  fat-&gt;iov_base = __mkptr_size(compat-&gt;iov_base, compat-&gt;iov_len);
}

__inline static
__DEEPCOPY_FROM_COMPAT_PROTO(msghdr) {
  fat-&gt;msg_name    = __mkptr_size(compat-&gt;msg_name, compat-&gt;msg_namelen);
  fat-&gt;msg_control = __mkptr_size(compat-&gt;msg_control, compat-&gt;msg_controllen);

  if(CCURED_HAS_EMPTY_MANGLING(* fat-&gt;msg_iov)) {
    // We do not need to copy the msg_iov array
    fat-&gt;msg_iov = __mkptr_size(compat-&gt;msg_iov,
                                compat-&gt;msg_iovlen * sizeof(fat-&gt;msg_iov[0]));
  } else {
    int len = compat-&gt;msg_iovlen;
    int v;
    fat-&gt;msg_iov = malloc(len * sizeof(fat-&gt;msg_iov[0])); 
    for (v=0; v&lt;len; v++) {
      struct iovec __COMPAT *iptr = __trusted_add(compat-&gt;msg_iov, v);
      __deepcopy_iovec_from_compat(&amp; fat-&gt;msg_iov[v], iptr);
    } 
  }
}
</FONT></PRE>
<a target="_blank" href="examples/ex61.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex61.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
For <FONT COLOR=blue>recvmsg</FONT> we use the companion functions that copy <FONT COLOR=blue>_FROM_COMPAT</FONT>.
We declare the deepcopy functions as before, except that now we must assign to
the <FONT COLOR=blue>fat</FONT> fields, and we must use the <FONT COLOR=blue>__mkptr</FONT> family of functions to
construct the metadata. Notice that for the output argument of <FONT COLOR=blue>recvmsg</FONT> we
copy the data from the stack-allocated <FONT COLOR=blue>lean_msg</FONT> into <FONT COLOR=blue>msg</FONT>. <BR>
<BR>
The above macros are written without close attention to memory leaks.
However, these are just examples that are intended to show you how to write
wrappers. <BR>
<BR>
The CCured library defines the functions
<FONT COLOR=blue>__deepcopy_stringarray_from_compat</FONT> and
<FONT COLOR=blue>__deepcopy_stringarray_to_compat</FONT> that operate on nul-terminated
sequences of pointers to nul-terminated strings (such as <FONT COLOR=blue>argv</FONT> in the
prototype for <FONT COLOR=blue>main</FONT>). To use these functions you must add:
<PRE CLASS="verbatim">
#include "functions/deepcopy_stringarray.h"
</PRE>
 <!--TOC section Wrappers for data-->

<H2 CLASS="section"><A NAME="htoc60">8.4</A>&nbsp;&nbsp;Wrappers for data</H2><!--SEC END -->

So far we looked at wrappers for functions. Sometimes the global that needs
to be wrapper is not a function but a name for a data area. In the standard
library that is very rare. One example is the <FONT COLOR=blue>environ</FONT> global variable of
type <FONT COLOR=blue>char **</FONT> that stores a pointer to a null-terminated sequence of
environment strings (like the sometimes-used third argument of <FONT COLOR=blue>main</FONT>).
If you access this variable directly you might get an error like this:
<PRE CLASS="verbatim">
tcpserver_comb.o: In function `env_get_qf':
tcpserver_comb.o(.text+0x15d10): undefined reference to `environ_qq'
</PRE>
 You cannot write wrappers for data! You MUST replace the access to the data
variable with a function. There are many ways in which you can write the
function. If the wrapped global had type <FONT COLOR=blue>char *</FONT> you could just write a
function:
<PRE CLASS="verbatim"><FONT COLOR=blue>
// This is for the cast when environ is a pointer to a string
char* get_environ(void) {
  return __mkptr_string(environ);
}
</FONT></PRE>
But this would not be enough for our case. In general, both of the pointer
types in <FONT COLOR=blue>environ</FONT> could be fat, so you must do a deepcopy:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#include "functions/deepcopy_stringarray.h"
// This is Ok, but allocated too often
char** get_environ(void) {
  return __deepcopy_stringarray_from_compat(environ);
}
</FONT></PRE>
If your program accesses the <FONT COLOR=blue>environ</FONT> variable a lot, you do not want to
make a deepcopy every time. So, you can make one and save it in a variable,
which you can then access at will. <BR>
<BR>
Or, maybe your program accesses <FONT COLOR=blue>environ</FONT> always with an index operation
<FONT COLOR=blue>environ[i]</FONT>. In that case you can avoid deepcopying altogether by writing a
function <FONT COLOR=blue>environ_idx</FONT> that takes an integer and returns the <I>i</I><SUP><I>th</I></SUP>
element in <FONT COLOR=blue>environ</FONT>. I show below the case where it appropriate to trust
that the index is within the bounds:
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern char ** environ;
char* environ_idx(int i) {
  char * __SAFE * __SAFE p_environ = __trusted_add(environ, i);
  // We are going to believe that i is within bounds
  return __mkptr_string(* p_environ);
  
}
</FONT></PRE>
<!--TOC section Wrapper Helper Functions-->

<H2 CLASS="section"><A NAME="htoc61">8.5</A>&nbsp;&nbsp;Wrapper Helper Functions</H2><!--SEC END -->
<A NAME="sec-wrapperhelper"></A>
<!--TOC subsection Helpers for incoming wrapper arguments-->

<H3 CLASS="subsection"><A NAME="htoc62">8.5.1</A>&nbsp;&nbsp;Helpers for incoming wrapper arguments</H3><!--SEC END -->

These functions have two purposes. First, they convert the incoming argument
(which may be a fat pointer) to a regular C pointer or data to be used in
run-time checks and for passing to C library functions. Second, these
functions direct CCured to request some minimal metadata to accompany the
pointer. For example, on entry to a string library function CCured will want
to request that the pointer be accompanied by extent, and the target of the
pointer be a null-terminated string buffer. 
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>__ptrof_nocheck</TT>: Returns the pointer value from a fat pointer. No
 constraints for type inference. No run-time checking. 
<LI CLASS="li-itemize"><TT>__ptrof</TT>: Returns the pointer value from a fat pointer. No
 constraints for type inference. Check that the pointer is in bounds, if the
 incoming pointer has bounds. 
<LI CLASS="li-itemize"><TT>__strlen</TT>: Returns the length of the string, not counting the
 terminating nul. Calls ccured_fail if ptr is null, or out of bounds.
 Requires that the argument be a string or a null-terminated sequence
 pointer. 
<LI CLASS="li-itemize"><TT>__verify_nul</TT>: This is like <TT>__strlen</TT>, but ignores the
 resulting length. 
<LI CLASS="li-itemize"><TT>__stringof</TT>: This is like <TT>__verify_nul</TT> followed by
 <TT>__ptrof</TT>. 
</UL>
<!--TOC subsection Helpers for outgoing wrapper return values-->

<H3 CLASS="subsection"><A NAME="htoc63">8.5.2</A>&nbsp;&nbsp;Helpers for outgoing wrapper return values</H3><!--SEC END -->

These functions allow you to construct fat pointers from regular C pointers.
These functions do not do any checking. 
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>__mkptr_size</TT>. Takes two arguments, a pointer and a length, and
 constructs a fat sequence pointer if needed (depending on how the return
 value is used). 
<LI CLASS="li-itemize"><TT>__mkptr_string</TT>. Takes an argument that is assumed to be a
 null-terminated string, and creates a fat pointer if needed. 
</UL>
<!--TOC section Final Notes on Wrappers-->

<H2 CLASS="section"><A NAME="htoc64">8.6</A>&nbsp;&nbsp;Final Notes on Wrappers</H2><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
The documentation for the wrapper helper functions is in
<A HREF="ccured.h"><TT>ccured.h</TT></A> (which lives in the <FONT COLOR=blue>cil/include</FONT> directory). That file
is included automatically in all cured files.<BR>
<BR>
<LI CLASS="li-itemize">Wrappers are automatically polymorphic. <BR>
<BR>
<LI CLASS="li-itemize">Wrapper-replacement is not performed inside a wrapper body!<BR>
<BR>
<LI CLASS="li-itemize">At the moment, wrappers do not work well for <TT>WILD</TT> pointers. You can
still write those wrapper manually but the <FONT COLOR=blue>__mkptr</FONT> functions do not work
well for those.<BR>
<BR>
<LI CLASS="li-itemize">At the moment, wrappers do not work well for variable argument
functions. However, this is possible in certain cases (see
<FONT COLOR=blue>stdio_wrappers.h</FONT> for the <FONT COLOR=blue>printf</FONT> wrapper).<BR>
<BR>
<LI CLASS="li-itemize">Note that there is no actual requirement that a wrapper call the
external function that it is intended to replace. If you wish, the wrapper can
call a different external function, or simply reimplement the entire routine.
For example, the wrapper for <FONT COLOR=blue>strdup</FONT> that comes with CCured calls
<FONT COLOR=blue>malloc</FONT> and <FONT COLOR=blue>strcpy</FONT> rather than the Standard Library's <FONT COLOR=blue>strdup</FONT>
because we wanted to ensure that any strings created could be managed by our
garbage collector.<BR>
<BR>
<LI CLASS="li-itemize">If you write wrappers for generally useful libraries (such as the
standard library), please give them to us so we can distribute them to other
interested persons. <BR>
<BR>
<LI CLASS="li-itemize">Remember that all of the structure types that are reachable from the
prototype of the wrapped function are converted to a compatible version, whose
pointers should be all of <TT>SAFE</TT> kind and whose name is obtained by adding to
the structure name the <FONT COLOR=blue>_COMPAT</FONT> attribute. <BR>
<BR>
<LI CLASS="li-itemize">The <FONT COLOR=blue>__DECL_COMPAT</FONT> macros all work as declarations, not
 statements. <BR>
<BR>
<LI CLASS="li-itemize">The wrappers for <FONT COLOR=blue>sendmsg</FONT> and <FONT COLOR=blue>recvmsg</FONT> are in the file
<FONT COLOR=blue>include/socket_wrappers.h</FONT>. Take a look also at
<FONT COLOR=blue>include/netdb_wrappers.h</FONT>. <BR>
<BR>
<LI CLASS="li-itemize">When you write wrappers, do not use functions that you are not sure have
a prototype (this is why we put the wrappers at the end of the include files).
Otherwise, you will generate warning and unnecessary <TT>WILD</TT>ness in the
code. If you need to use <FONT COLOR=blue>malloc</FONT>, use <FONT COLOR=blue>wrapperAlloc</FONT> instead (for
which we guarantee the existence of the prototype). </UL>
<!--TOC chapter Advanced CCured Issues-->

<H1 CLASS="chapter"><A NAME="htoc65">Chapter&nbsp;9</A>&nbsp;&nbsp;Advanced CCured Issues</H1><!--SEC END -->

In this chapter we discuss a collection of issues having to do with using
CCured on real programs. Some of the issues are related to sound handling of
dark corners of the C programming language (e.g. function pointers,
initialization of globals, variable argument functions). Other issues are
related to mechanisms to give hints to the CCured inferencer with the ultimate
goal of reducing the number of cases in which the inferencer gives up and
decided to use the conservative but expensive <TT>WILD</TT> pointers (e.g.
polymorphism, custom memory allocators). <BR>
<BR>
<!--TOC section Function Pointers-->

<H2 CLASS="section"><A NAME="htoc66">9.1</A>&nbsp;&nbsp;Function Pointers</H2><!--SEC END -->
<A NAME="sec-funptr"></A>
One of the signs that a C program is a &#8220;serious&#8221; one is the use of function
pointers. There would be nothing wrong or unsafe about that if it wasn't also
the case that most programmers do not feel necessary to use accurate types for
function pointers, or to even use function prototypes. This is probably due to
the fact that the syntax for function types in C is terrible. How often have
you declared your function pointers to have type <FONT COLOR=blue>void (*)()</FONT> when you
actually wanted to say <FONT COLOR=blue>int * (* (* x3))(int x)(float)</FONT> (a pointer to a
function that takes an <FONT COLOR=blue>int</FONT> and returns a pointer to a function that takes
a <FONT COLOR=blue>float</FONT> and returns a pointer to an <FONT COLOR=blue>int</FONT>).<BR>
<BR>
Of course, misusing function pointers can lead to the worst kind of errors.
Fortunately such error rarely go unnoticed in code that is executed. <BR>
<BR>
CCured supports two kinds of function pointers. The <TT>SAFE</TT> function pointers
can only be invoked with the same number of arguments. If the types of the
arguments are not right it is the argument that becomes <TT>WILD</TT> not the
function pointer. A <TT>SAFE</TT> function pointer can only be cast to an integer or
to the same function pointer type. We also have <TT>WILD</TT> function pointers
which you can (try to) use as you please. In fact a <TT>WILD</TT> function pointer
can be cast to any other <TT>WILD</TT> pointer type and can be stored in any tagged
area. For this reason its representation must match that of any <TT>WILD</TT>
pointer. However the capabilities of a <TT>WILD</TT> function pointer are typically
quite different from those of a regular function pointer. For example, you
should not be able to read or write from a function pointer. <BR>
<BR>
The next picture shows the meaning of the <FONT COLOR=blue>_b</FONT> field for a <TT>WILD</TT>
function pointer. <BR>
<BR>
<DIV CLASS="center">
<IMG SRC="ccuredpp004.png">
</DIV><BR>
<BR>
Any function whose address is taken and becomes <TT>WILD</TT>, or that is used
without a prototype (see the discussion at the end of this section) is a <EM>tagged function</EM> and has an associated descriptor that encodes the actual code
to the function and the number of arguments. Here is an example:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int taggedfun(int anint, int * aptr) {
    return anint + * aptr;
}

int main() {
  int * i = taggedfun; // Bad cast. wildfun becomes tagged
  // Now we invoke it
  ((void (*)(int,int*))i)(5, i);
}
</FONT></PRE>
<a target="_blank" href="examples/ex62.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex62.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The structure of a function descriptor is as shown below and a pointer to the
<FONT COLOR=blue>_pfun</FONT> field is used as the <FONT COLOR=blue>_b</FONT> field whenever the address of the
function is taken.
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct __functionDescriptor {
  unsigned int _len ; // Always 0
  void (* _pfun)() ; // Pointer to a function
  unsigned int _nrargs ; // The number of arguments
};
</FONT></PRE>
Since the <FONT COLOR=blue>_len</FONT> field is always initialized to zero, whenever this
<TT>WILD</TT> pointer is used for a read or a write it would appear that it points
into a zero-length tagged memory area, so the bounds check will fail. We then
have to protect against the pointer being subject to arithmetic prior to
invocation. We do this by storing in the function descriptor the actual
pointer to the function and checking at the time of a call through a <TT>WILD</TT>
function pointer that the <FONT COLOR=blue>_p</FONT> field of the pointer is equal to the
<FONT COLOR=blue>_pfun</FONT> field in the descriptor. <BR>
<BR>
Finally we have to ensure that the function is called with the right number
and kinds of arguments. There is no hope to be able to ensure this statically
because a <TT>WILD</TT> function pointer can be used very liberally as any other
<TT>WILD</TT> pointer. So, CCured conservatively forces
all arguments and the return type to be <TT>WILD</TT> pointers. This includes
arguments and return types that are actually scalars (see the example above
for how integers are wrapped into <TT>WILD</TT> pointers). This will ensure that the
types are the same (or compatible) and all we have to check is the right
number of arguments is passed to the function. To perform these checks we use
the following run-time support function:
<PRE CLASS="verbatim"><FONT COLOR=blue>
/* Check that a function pointer points to a valid tagged function and check
   that we are passing enough arguments. We allow the passing of more
   arguments than the function actually expects */
__CHECK_FUNCTIONPOINTER(void *_p, /* The _p field of the function pointer */
                        void *_b, /* The _b field */
                        int nrActualArgs); /* The number of actual arguments */
</FONT></PRE>
Also, <EM>always use prototypes for the external functions you are using</EM>.
Otherwise, it will appear to CCured that you are casting the function pointer
to various incompatible types corresponding to each use and the function will
be declared tagged (and pointers to such function to be <TT>WILD</TT>). You get some
help from CCured here because its whole-program merger will construct
prototypes for the functions that are defined somewhere in your program. But
when you use even simple things like <FONT COLOR=blue>printf</FONT> you must include the proper
header files. <BR>
<BR>
<!--TOC section The <FONT COLOR=blue>main</FONT> Function-->

<H2 CLASS="section"><A NAME="htoc67">9.2</A>&nbsp;&nbsp;The <FONT COLOR=blue>main</FONT> Function</H2><!--SEC END -->
<A NAME="sec-main"></A>
The <FONT COLOR=blue>main</FONT> function is the entry point to your program. The most general
type of the function is:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int main(int argc, char **argv, char **envp);
</FONT></PRE>
although when the arguments are not used it is common to not write them.
Depending on how you use the <FONT COLOR=blue>argv</FONT> and <FONT COLOR=blue>envp</FONT> arguments, CCured might
decide that they should be of some non-<TT>SAFE</TT> type. In that case CCured will
generate code that makes copies of appropriate kind of the <FONT COLOR=blue>argc</FONT> and
<FONT COLOR=blue>envp</FONT> arguments. <BR>
<BR>
Take a look at what happens for this example:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int main(int argc, char **argv) {
   for(; *argv; argv ++) { // Scan the args
      char *p = *argv;
      while( *p) { p ++; }
   }
}
</FONT></PRE>
<a target="_blank" href="examples/ex63.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex63.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
CCured will also insert a call to <FONT COLOR=blue>ccuredInit</FONT>, which initializes the
CCured run-time library. <BR>
<BR>
<!--TOC section Global Initialization-->

<H2 CLASS="section"><A NAME="htoc68">9.3</A>&nbsp;&nbsp;Global Initialization</H2><!--SEC END -->
<A NAME="sec-globinit"></A>
C has a very rich language of initializers for globals and locals. The
language is so rich that neither <FONT COLOR=blue>gcc</FONT> nor MSVC implement it fully. For a
discussion of how our front-end handles initialization, please see the <A HREF="../cil/index.html">the CIL documentation</A>.<BR>
<BR>
Once programs are presented to CCured all the initialization for locals is
turned into assignments, but most initialization code for globals is
preserved. However, in some cases CCured must insert some checks related to
the initializers. These checks are placed in a special function called a <EM>global initializer</EM>.<BR>
<BR>
The name of a global initializer starts with <FONT COLOR=blue>__globinit</FONT>. CCured will
try to insert a call to the global initializer that it creates in the <FONT COLOR=blue>main</FONT>
function to ensure that it is run before anything else in the program. If it
cannot find a <FONT COLOR=blue>main</FONT> it will emit a warning:
<PRE CLASS="verbatim">
Warning: Cannot find main to add global initializer __globinit_myfile
</PRE>
 If you see such warnings and intend to actually run the code, make sure
whoever invokes any function in the cured code calls the global initializer
first. <BR>
<BR>
<!--TOC section Casting Integers to Pointers-->

<H2 CLASS="section"><A NAME="htoc69">9.4</A>&nbsp;&nbsp;Casting Integers to Pointers</H2><!--SEC END -->
<A NAME="sec-castint"></A>
In CCured it is Ok to cast any kind of pointer to an integer, and in fact any
pointer comparison is performed after such a cast. But if you try to cast an
integer to a pointer the following two things happen:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The inferencer will not allow the destination pointer to be <TT>SAFE</TT>
unless the value you are casting is the constant 0. Any other kind of pointer
can be used. 
<LI CLASS="li-enumerate">More importantly, the resulting pointer will have metadata that will
prevent you from using the pointer in a memory dereference. For a <TT>FSEQ</TT>
pointer the <FONT COLOR=blue>_e</FONT> field will be null, for a <TT>SEQ</TT> both the <FONT COLOR=blue>_b</FONT> and the
<FONT COLOR=blue>_e</FONT> fields will be null and for a <TT>WILD</TT> the <FONT COLOR=blue>_b</FONT> field will be null.
</OL>
This means that such pointers cannot be used in memory dereferences. If your
program casts a pointer into an integer and then back to a pointer this will
be an issue. CCured will emit a warning whenever this happens. So far we have
very few programs that do this and even then in one of few forms.<BR>
<BR>
Some programs are just not careful about keeping pointers separate from
integers and gratuitously cast to integers. The solution in that case is to
change the type of the intermediate location to a <FONT COLOR=blue>void*</FONT> (or to a more
precise type of pointer if possible).<BR>
<BR>
Other programs cast pointers to integers because they want to do pointer
arithmetic and do not have to worry about the implicit scaling that C uses for
pointer arithmetic. Use <FONT COLOR=blue>char*</FONT> to do such arithmetic. <BR>
<BR>
Some other programs also want to do arithmetic but of a kind not allowed for
<FONT COLOR=blue>char*</FONT> such as the following code which tries to align a pointer to a 16
byte boundary:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int* alignit(int *x ) {
  return (int*)((int)x &amp; ~15);
}
</FONT></PRE>
<a target="_blank" href="examples/ex64.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex64.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
The solution here is a cute trick that can be used in some situations to cast
an integer into a pointer, <EM>provided you know that it has the same
metadata with some other legal pointer</EM>. Thus to cast the integer <FONT COLOR=blue>x</FONT> to a
pointer, while borrowing the metadata from pointer <FONT COLOR=blue>p</FONT>do:
<PRE CLASS="verbatim"><FONT COLOR=blue>
p + (x - (int)p);
</FONT></PRE>
Thus you are turning a cast into pointer arithmetic. CCured will force the
kind of the pointer to be either <TT>WILD</TT> or <TT>SEQ</TT> but everything will work as
expected. Of course you have to worry about scaling back the difference by the
size of the type pointed to by <FONT COLOR=blue>x</FONT>. Here is how the previous <FONT COLOR=blue>alignit</FONT>
function can be written:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int* alignit(int *x ) {
  int ix = (int)x &amp; ~15;
  return x + ((ix - (int)x) &gt;&gt; 2);
}

</FONT></PRE>
<a target="_blank" href="examples/ex65.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex65.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
If you are lazy and do not want to change your code you can ask CCured to
insert code that at every cast from a scalar to a pointer records the
line-number of the cast. Then when a non-pointer is dereference the CCured
run-time system will try to tell you which particular cast in your program
produced this fake pointer. Use the <FONT COLOR=blue>interceptCasts</FONT> pragma for this purpose
(see Section&nbsp;<A HREF="#sec-pragma">9.10</A>). We have not found this feature very useful because in
fact not too many programs cast integers to pointers. <BR>
<BR>
<!--TOC section The <FONT COLOR=blue>sizeof</FONT> Issue-->

<H2 CLASS="section"><A NAME="htoc70">9.5</A>&nbsp;&nbsp;The <FONT COLOR=blue>sizeof</FONT> Issue</H2><!--SEC END -->
<A NAME="sec-sizeof"></A>
It is obvious by now that CCured will change the layout of some datatypes.
That can lead to several kinds of problems. For example, if you are calling a
library that is not cured then you better not change the layout of the data
that is passed back and forth. This issue is discussed more in
Chapter&nbsp;<A HREF="#ch-wrapper">8</A>. Another problem is when the code is written assuming that
datatypes have a certain layout, such as the following code that accesses the 
<PRE CLASS="verbatim"><FONT COLOR=blue>
#include &lt;stdio.h&gt;
int *a[8];
void bad_code(int * *x) {
  int * pa = a; // Make a's elements WILD
  printf("a has %d elements", sizeof(a) / 4);
}
</FONT></PRE>
<a target="_blank" href="examples/ex66.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex66.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
This code will probably print 16 instead of 8 because each element of <FONT COLOR=blue>a</FONT>
is now 8 bytes long. Such code is very ill and it cannot be cured without
manual intervention. So, let's assume that we change the code to:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#include &lt;stdio.h&gt;
int *a[8];
void so_and_so_code(int * *x) {
  int * pa = a; // Make a's elements WILD
  printf("a has %d elements", sizeof(a) / sizeof(int *));
}
</FONT></PRE>
<a target="_blank" href="examples/ex67.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex67.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
As it turns out this code is perfectly fine but our inferencer cannot tell
that there is a connection between the type of the element of <FONT COLOR=blue>a</FONT> and the
<FONT COLOR=blue>int *</FONT> that appears in the argument of <FONT COLOR=blue>sizeof</FONT>. Even though the bad cast
will force the array elements to be <TT>WILD</TT> pointers the <FONT COLOR=blue>int *</FONT> that
appears in the argument of <FONT COLOR=blue>sizeof</FONT> will be a <TT>SAFE</TT> pointer. Thus this
code will also print 16. In fact, you will see a warning:
<PRE CLASS="verbatim">
pathexec_env.c:42: Warning: Encountered sizeof(int */* __attribute__((___ptrnode__(2595))) */) when type contains pointers. Use sizeof expression. Type has a disconnected node.
</PRE>
 If CCured says that the type has a connected node, then you are probably Ok.
It means that the node inside sizeof is connected to the other nodes, so it
will probably get the right kind. However, if CCured says that the type has
disconnected nodes then you should worry. <BR>
<BR>
To really point out the connection change the code as shown below. It can be
argued also that this code is clearer and thus should be used even if you do
not use CCured.
<PRE CLASS="verbatim"><FONT COLOR=blue>
#include &lt;stdio.h&gt;
int *a[8];
void good_code(int * *x) {
  int * pa = a; // Make a's elements WILD
  printf("a has %d elements", sizeof(a) / sizeof(a[0]));
}
</FONT></PRE>
<a target="_blank" href="examples/ex68.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex68.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Similar problems arise for any use of <FONT COLOR=blue>sizeof</FONT>, such as in the argument of
allocation functions.<BR>
<BR>
<!--TOC section Variable argument functions-->

<H2 CLASS="section"><A NAME="htoc71">9.6</A>&nbsp;&nbsp;Variable argument functions</H2><!--SEC END -->
<A NAME="sec-vararg"></A>
Variable-argument functions in C are inherently unsafe since there is no
language-level mechanism to ensure that the actual arguments agree in type and
number with the arguments that the function will be using. There are several
ways to implement variable argument functions in C and CCured supports some of
them quite well:
<UL CLASS="itemize"><LI CLASS="li-itemize">
You can try to implement such function by taking the address of a formal
argument and working your way through the stack frame. If you do this we wish
you luck and perseverance and you'll need them both while trying to figure out
why your program does not behave for compilers such as <FONT COLOR=blue>gcc</FONT>. CCured
certainly cannot allow this because this is exactly the kind of operation that
viruses would want to perform.
<LI CLASS="li-itemize">A better alternative is to use the <FONT COLOR=blue>__builtin_next_arg</FONT> function on
<FONT COLOR=blue>gcc</FONT> and then work your way up the stack. CCured does not support this
low-level implementation of variable argument functions, but see next.
<LI CLASS="li-itemize">You can write your variable argument functions using the standard macros
in <FONT COLOR=blue>&lt;stdarg.h&gt;</FONT> and <FONT COLOR=blue>&lt;vararg.h&gt;</FONT>. CCured supports most such functions with
minimal programmer intervention.
</UL>
There are two kinds of variable-argument functions in C:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Those that take an arbitrary number of arguments following the last
specified formal (their function type contains <FONT COLOR=blue>...</FONT> after the last formal).
We'll call these functions <EM>vararg</EM> functions. An example is <FONT COLOR=blue>printf</FONT>:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int printf(const char* format, ...)
</FONT></PRE><BR>
<BR>
<LI CLASS="li-itemize">Those that take as arguments one or more pointers to lists of arguments.
We'll call these functions <EM>valist</EM> functions. An example is <FONT COLOR=blue>vprintf</FONT>:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int vprintf(const char* format, va_list args)
</FONT></PRE>
</UL>
CCured supports both kinds of functions and will scan the program to find out
for each function what types of arguments are passed. In Section&nbsp;<A HREF="#sec-manualvararg">9.6.1</A>
we describe how the programmer can prevent this automatic inference by
specifying the set of types of arguments. <BR>
<BR>
CCured redefines the macros in <FONT COLOR=blue>&lt;stdarg.h&gt;</FONT> and <FONT COLOR=blue>&lt;vararg.h&gt;</FONT> to do
special bookkeeping. In vararg functions, the macro <FONT COLOR=blue>va_start</FONT> is used to
initialize an <FONT COLOR=blue>va_list</FONT> variable to point to the trailing arguments. CCured
checks that the second argument is the last formal before the <FONT COLOR=blue>...</FONT>.<BR>
<BR>
Both in vararg and valist functions the macro <FONT COLOR=blue>va_arg</FONT> can be used, as
follows: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
 T x = va_arg(args, T)
</FONT></PRE>
<FONT COLOR=blue>args</FONT> must be a <FONT COLOR=blue>va_list</FONT> variable and <FONT COLOR=blue>T</FONT> must be compatible after
the usual actual argument promotions (e.g. <FONT COLOR=blue>char</FONT> and <FONT COLOR=blue>short</FONT> to <FONT COLOR=blue>int</FONT>
and <FONT COLOR=blue>float</FONT> to <FONT COLOR=blue>double</FONT>) with one of the types in the <FONT COLOR=blue>struct</FONT> associated
with <FONT COLOR=blue>args</FONT>. CCured checks this at run-time.<BR>
<BR>
The CCured support for variable argument functions is quite flexible.
Multiple variable argument lists can be processed in parallel, an argument
list can be re-initialized with <FONT COLOR=blue>va_start</FONT> and processed multiple times. A
function can even work with variable argument lists that have different sets
of types accepted (but for this you need to specify manually the set of types
of arguments as explained in Section&nbsp;<A HREF="#sec-manualvararg">9.6.1</A>). Variable argument lists
can be passed down but the regular CCured checks for stack allocated variables
will prevent the passing of these lists up the call chain and also their
storing in the heap.<BR>
<BR>
The main thing that is not supported in CCured is the fetching of an argument
with a different type than it was stored. It remains to be seen if this is a
problem. We have looked at several variable argument functions (including full
implementations of <FONT COLOR=blue>printf</FONT> and <FONT COLOR=blue>sprintf</FONT>) and so far we have found that
CCured accepts those functions without any change except for the specification
of the <FONT COLOR=blue>struct</FONT> of the accepted argument types (as explained below).<BR>
<BR>
<!--TOC subsection Programmer control over vararg functions-->

<H3 CLASS="subsection"><A NAME="htoc72">9.6.1</A>&nbsp;&nbsp;Programmer control over vararg functions</H3><!--SEC END -->

 <A NAME="sec-manualvararg"></A>
If you do not want CCured to find automatically all the types that can be
passed to a function, you can specify the set of types that can be used for
arguments. Also, you should not let CCured infer the argument types for
<FONT COLOR=blue>printf</FONT>-like functions, but you should instead use the special support for
them, as explained in Section&nbsp;<A HREF="#sec-printf">9.6.2</A>.<BR>
<BR>
You can declare the argument types by declaring a descriptor. This is a
<FONT COLOR=blue>struct</FONT> data type whose fields have the types that can be passed to the
function. The order and the names of the fields do not matter. For example,
such a struct for <FONT COLOR=blue>printf</FONT> would be the following (this structure is defined
in <TT>ccured.h</TT>):
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct printf_arguments {
   int      f_int;
   double   f_double;
   char    *f_string;
};
</FONT></PRE>
The simplest way to specify that such a <FONT COLOR=blue>struct</FONT> describes the types of
arguments for a variable argument function is to use a pragma:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredvararg("myvarargfunction", sizeof(struct printf_arguments))
</FONT></PRE>
Notes:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Since most variable argument functions are <TT>printf</TT>-like, CCured
 provides special support for them. See Section&nbsp;<A HREF="#sec-printf">9.6.2</A> if your function is
 of this kind. <BR>
<BR>
<LI CLASS="li-itemize">Note that CCured predefines the <FONT COLOR=blue>struct printf_arguments</FONT> so you do
not have to redefine it.<BR>
<BR>
<LI CLASS="li-itemize">Like all CCured pragmas, you can put them anywhere in your project since
CCured is going to merge all files into one. However, I typically prefer to
put such pragmas in header files near the prototype for the function.<BR>
<BR>
<LI CLASS="li-itemize">This method does not work for specifying pointers to variable argument
 functions. You must use the attribute method described below.<BR>
<BR>
<LI CLASS="li-itemize">The <FONT COLOR=blue>sizeof</FONT> operator is there because the syntax of pragmas is pretty
much that of function calls and thus we cannot use types directly. <BR>
<BR>
<LI CLASS="li-itemize">This pragma can be used with both kinds of
variable argument functions. In the case of valist functions it specifies that
<EM>all</EM> formals and locals of type <FONT COLOR=blue>va_list</FONT> can hold arguments of the
given types. 
</UL>
An equivalent method is to associate the <FONT COLOR=blue>__CCUREDVARARG(struct
printf_arguments)</FONT> attribute with the type of the function
<FONT COLOR=blue>myvarargfunction</FONT>:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int (__CCUREDVARARG(struct printf_arguments) myvarargfunction)(int last, ...);
</FONT></PRE>
You have to use this method if you want to specify that a function pointer is
variable argument:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int (__CCUREDVARARG(struct printf_arguments) * myvarargptr)(int last, ...);
typedef int (_CCUREDVARARG(struct printf_arguments) fptr)(char *format,...);
</FONT></PRE>
A more fine-grained way to specify the same thing is to use the
<FONT COLOR=blue>__CCUREDVARARG</FONT> <EM>type attributes</EM> for <FONT COLOR=blue>va_list</FONT> every time it appears.
This allows you to specify different sets of types for different locals:
<PRE CLASS="verbatim"><FONT COLOR=blue>
va_list __CCUREDVARARG(struct printf_arguments) args1, 
        __CCUREDVARARG(struct some_other_type) args2;
</FONT></PRE>
<!--TOC subsection Printf-like functions-->

<H3 CLASS="subsection"><A NAME="htoc73">9.6.2</A>&nbsp;&nbsp;Printf-like functions</H3><!--SEC END -->
<A NAME="sec-printf"></A>
Since the vast majority of uses of variable argument functions if for
<FONT COLOR=blue>printf</FONT>-like functions, CCured contains special support for them.
Specifically if a vararg function is declared to be a <FONT COLOR=blue>printf</FONT>-like function
then all of its invocations in which the format string is a constant will be
checked statically. For the other invocations a wrapper for printf will be
called that will check the types of the actuals against the format string
before calling the real <FONT COLOR=blue>printf</FONT> function.<BR>
<BR>
To declare a function to be <FONT COLOR=blue>printf</FONT>-like use the following pragma:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredvararg("myprintf", printf(1))
</FONT></PRE>
where the last argument is the index of the format argument in the argument
list (starting with 1). Note that you will get a run-time error if you try to
use the <FONT COLOR=blue>va_arg</FONT> macro in the implementation of such a function. In those
implementations you should invoke functions like <FONT COLOR=blue>vprintf</FONT> and <FONT COLOR=blue>vsprintf</FONT>
instead.<BR>
<BR>
GCC already has support for communicating to the compiler that a function is
<FONT COLOR=blue>printf</FONT>-like. This is done as follows:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int myprintf(const char* format, ...) __attribute__((format(printf, 1, 2)))
</FONT></PRE>
where the &#8220;1&#8221; means that the first argument is the format string and the
&#8220;2&#8221; means that we should start checking with the second argument. CCured
recognizes this attribute and it considers it equivalent with the
<FONT COLOR=blue>ccuredvararg</FONT> from above. Note that the second argument in the
<FONT COLOR=blue>format</FONT> attribute is ignored in CCured.<BR>
<BR>
You can use the <TT>format</TT> attribute even for function pointers:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int (__attribute__((format(printf, 1, 2))) *myptr)(char *format, ...);
</FONT></PRE>
Note that CCured does not currently like passing pointers to <FONT COLOR=blue>printf</FONT> with
the intention of printing the pointer value. You should manually cast those
pointers to <FONT COLOR=blue>long</FONT> when passing them to <FONT COLOR=blue>printf</FONT>-like functions.<BR>
<BR>
Also, you should not let CCured infer automatically the descriptors for
<FONT COLOR=blue>printf</FONT>-like functions. Otherwise, it is quite likely that the descriptor
that will be inferred is different than the built-in descriptor
<FONT COLOR=blue>printf_arguments</FONT> (which the runtime library is using to check the calls
to <FONT COLOR=blue>printf</FONT>-like functions. CCured will warn you about all automatically
inferred descriptors and you should manually inspect all the functions
involved. <BR>
<BR>
As for the regular variable argument functions, the <TT>pragma</TT> works only for
named functions but not for pointers to functions. For that purpose you must
use attributes: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int (__CCUREDFORMAT(1) * myprintf)(char *format, ...);
typedef int (_CCUREDFORMAT(1) fptr)(char *format,...);
</FONT></PRE>
<!--TOC subsection Scanf-like functions-->

<H3 CLASS="subsection"><A NAME="htoc74">9.6.3</A>&nbsp;&nbsp;Scanf-like functions</H3><!--SEC END -->
<A NAME="sec-scanf-like"></A>
Since it proved too much trouble to handle <FONT COLOR=blue>scanf</FONT>-like functions in a safe
yet transparent way we currently require the programmer to rewrite the
invocations to <FONT COLOR=blue>scanf</FONT> using a number of functions that we provide. For
example instead of 
<PRE CLASS="verbatim"><FONT COLOR=blue>
  int entry;   double then;   char buffer[6];

 ... fscanf(file, "Entry:%d;  Then:%lf;  5 digits:%5[0-9]; useless text.", 
            &amp;entry, &amp;then, buffer) ...
</FONT></PRE>
you should write
<PRE CLASS="verbatim"><FONT COLOR=blue>
 ... (resetScanfCount(), 
      entry = ccured_fscanf_int(file, "Entry:%d"),
      then  = ccured_fscanf_double(file, ";  Then:%lf"),
      ccured_fscanf_string(file, ";  5 digits:%5[0-9]", buffer), 
      ccured_fscanf_nothing(file, "; useless text."), //advance the file pointer.
      getScanfCount ()) ...
</FONT></PRE>
The functions <FONT COLOR=blue>resetScanfCount</FONT> and <FONT COLOR=blue>getScanfCount</FONT> are necessary only
if you use the result of the call to <FONT COLOR=blue>fscanf</FONT> in the original code. Note
that our replacement <FONT COLOR=blue>scanf</FONT> functions can be used to return only one result
at a time, consequently the format string that is passed must contain only one
format specifier, possibly along with characters to be matched. <BR>
<BR>
The following are the <FONT COLOR=blue>scanf</FONT>-like functions that we currently support:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  extern int    ccured_fscanf_int(FILE *, char *format);
  extern double ccured_fscanf_double(FILE *, char *format);
  extern void   ccured_fscanf_string(FILE *, char *format, char *string);
  extern void   ccured_fscanf_nothing(FILE *, char *format);
</FONT></PRE>
If the original program uses <FONT COLOR=blue>scanf</FONT>, just consider that you are using
<FONT COLOR=blue>fscanf</FONT> from <FONT COLOR=blue>stdin</FONT>. If instead your program contains <FONT COLOR=blue>sscanf</FONT> then
you can use the function 
<PRE CLASS="verbatim"><FONT COLOR=blue>
void resetSScanfCount(char *string);
</FONT></PRE>
to dump the string to the temporary file <FONT COLOR=blue>ccured_sscanf_file</FONT>
then use the replacement for <FONT COLOR=blue>fscanf</FONT> from above. For example, 
<PRE CLASS="verbatim"><FONT COLOR=blue>
 ... (resetSScanfCount(inputString), 
      entry = ccured_fscanf_int(ccured_sscanf_file, "Entry:%d"),
      then  = ccured_fscanf_double(ccured_sscanf_file, ";   Then:%lf"),
      ccured_fscanf_string(ccured_sscanf_file, ";   5 digits:%5[0-9]", buffer), 
      getScanfCount ()) ...   //getScanfCount is required when using resetSScanfCount
</FONT></PRE>
<B>Note that the current support for <FONT COLOR=blue>scanf</FONT> is far from satisfactory and
 will likely change in the future</B><BR>
<BR>
<!--TOC subsection Implementation Issues-->

<H3 CLASS="subsection"><A NAME="htoc75">9.6.4</A>&nbsp;&nbsp;Implementation Issues</H3><!--SEC END -->

Almost all of the checking for variable-argument functions is done at
run-time. At the time of a call each actual argument is compared with the
types in the <FONT COLOR=blue>struct</FONT> associated with the vararg function. A global data
structure is filled with the number of arguments (in the global
<FONT COLOR=blue>__ccured_va_count</FONT> and a list of indices describing for each actual
argument the index within the <FONT COLOR=blue>struct</FONT> types (in <FONT COLOR=blue>__ccured_va_tags</FONT>). <BR>
<BR>
In the body of a vararg function, a data structure is allocated on the stack
to hold a copy of the global description of the arguments that was created by
the caller. The call to <FONT COLOR=blue>va_start</FONT> initializes this data structure and each
call to <FONT COLOR=blue>va_arg</FONT> checks that we are not reading past the end of the
actuals and also that the type of the fetched argument matches that of the
actual argument. <BR>
<BR>
<!--TOC section Tagged Unions-->

<H2 CLASS="section"><A NAME="htoc76">9.7</A>&nbsp;&nbsp;Tagged Unions</H2><!--SEC END -->
<A NAME="sec-taggedunion"></A>
As we have seen in Section&nbsp;<A HREF="#sec-union">3.2.2</A> CCured can handle union types whose
fields have compatible pointer types at corresponding offsets. If this
is not the case then you will need to tell CCured how to handle the
union. One option is to turn the union into a struct, but we do not
recommend this because it increases memory usage and can change the
behavior of your program if your code writes to one union field and
then reads from a different one. A better option is to declare that
the union is a <EM>tagged union</EM>. CCured actually supports two
forms of tagged unions: one in which CCured adds a tag field and
maintains it for you, and one in which your program maintains its own
tag, and CCured checks that it is used properly.<BR>
<BR>
<!--TOC subsection CCured-maintained tags-->

<H3 CLASS="subsection"><A NAME="htoc77">9.7.1</A>&nbsp;&nbsp;CCured-maintained tags</H3><!--SEC END -->
<A NAME="sec-taggedunion-ccured"></A>
You can declare a union to be tagged by adding the attribute
<TT>__TAGGED</TT> to its definition. CCured will expand the union to contain
a tag field. A tag is an RTTI value (Section&nbsp;<A HREF="#sec-rtti">7.3</A>) that encodes the
type of the last field written in each union value. Here is an example:
<PRE CLASS="verbatim"><FONT COLOR=blue>
union int_or_ptr {
  int   i;
  int  *p;
} __TAGGED; // We declare it tagged

int main() {
  union int_or_ptr x;
  int i;
  x.i = 5;
  i = x.i; // This will work
  i = * x.p; // This will fail
  x.p = &amp;i;
  i = x.i; // This will fail
  i = * x.p; // This will work
}
</FONT></PRE>
<a target="_blank" href="examples/ex69.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex69.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
You can see that CCured has defined the following structure:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct tagged_int_or_ptr {
   struct RTTI_ELEMENT *    __tag    ;
   union int_or_ptr __data    ;
} __TAGGED  ;
</FONT></PRE>
You can also see in the code that CCured generates assignments to the
<FONT COLOR=blue>__tag</FONT> field before each assignment to a union field. And CCured inserts
calls to <FONT COLOR=blue>CHECK_UNIONTAG</FONT> before each read-access to the field.<BR>
<BR>
Notes:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If you declare a union type to be tagged you cannot take the address of
 one of its fields. If your program takes the address of a union
 field, you should change the union to a struct or otherwise
 restructure the code.
<LI CLASS="li-itemize">If a field of a union type is a structured type itself, any access to an
 element of the field is treated (from the point of view of the tag
 manipulation) as an access to that entire field. This means that you cannot
 take the address of an element of a field either. 
<LI CLASS="li-itemize">You can call the function <FONT COLOR=blue>CCURED_HASUNIONTAG</FONT> to test the
 runtime value of a union tag. &#8220;<FONT COLOR=blue>CCURED_HASUNIONTAG(foo.bar)</FONT>&#8221;
 will return <TT>true</TT> if it is safe to read field <FONT COLOR=blue>bar</FONT> in object
 <FONT COLOR=blue>foo</FONT>, or false if such a read would cause a run-time error.
<LI CLASS="li-itemize">Tagged unions use the same tag mechanism as RTTI pointers
 (Section&nbsp;<A HREF="#sec-rtti">7.3</A>). This allows interoperability with RTTI pointers,
 and creates an exception to the general rule that you may only read
 from the most recently-written field of a tagged union. If two
 fields have pointer types, and one of those types is a subtype of
 the other, it is possible to write to one field and then read from a
 different field. (All pointers are subtypes of <FONT COLOR=blue>void*</FONT>. Other
 subtyping relationships can be declared as described in
 Section&nbsp;<A HREF="#sec-rtti">7.3</A>.) For example:
<PRE CLASS="verbatim"><FONT COLOR=blue>
typedef struct foo {
  int  *f1;
} Foo;

union ptrs {
  void * v;
  Foo * f;
  int * i;
} __TAGGED; // We declare it tagged

int main() {
  union ptrs u1, u2;
  Foo f;
  
  //We write to the "void*" field, and read from the "Foo*" field.
  //This works because rtti_ptr has Run-Time Typing Information.
  void* __RTTI rtti_ptr = &amp;f;
  u1.v = rtti_ptr;
  Foo* pf = u1.f;       // This will work
  int* pi = u1.i;       // This will fail

  //We can also write to the Foo* field, and read from the void* field a
  // pointer that has RTTI info. 
  u2.f = &amp;f;            //write to the "Foo*" field
  rtti_ptr = u2.v;      //  and read from the "void*" field
  pf = (Foo*)rtti_ptr;  //This checked downcast will succeed.

  return 0;
}
</FONT></PRE>
<a target="_blank" href="examples/ex70.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex70.cured.c">CCured output</A>
for this code fragment</UL>
<!--TOC subsection User-defined tags-->

<H3 CLASS="subsection"><A NAME="htoc78">9.7.2</A>&nbsp;&nbsp;User-defined tags</H3><!--SEC END -->

Many programs define their own tagged unions, in which a struct
contains a tag field and a union holding one of several types of
data. In these cases, using a CCured-supplied tag is redundant. You
can annotate a union to tell CCured what meaning you assign to various
tag values, and CCured will then check that the tags are maintained
properly.<BR>
<BR>
When a tag is modified, the &#8220;data&#8221; portion of the structure will be
zeroed. <EM>Therefore, when writing both the tag and data portions,
 programs must always modify the tag first, followed by the data.</EM><BR>
<BR>
When a program reads or writes the data part of a tagged union, CCured will
read the tag and check that it is appropriate for the union field
being accessed.<BR>
<BR>
Tags are defined by annotating each union field with
<FONT COLOR=blue>__SELECTEDWHEN(<I>exp</I>)</FONT> where <I>exp</I> is a boolean expression.
<I>exp</I> may contain integer arithmetic and comparisons, and it can refer
to the runtime value of a field in an enclosing struct by specifying
the name of that field. For example:
<PRE CLASS="verbatim"><FONT COLOR=blue>
enum tags {
  TAG_ZERO = 0,
};

struct host {
  short tag; // 0 for integer, 1 for structure, 10--12 for pointer to int
  union bar {
    int anint      __SELECTEDWHEN(tag == TAG_ZERO);

    struct str {
      int * * ptrptr;
      float f;
    } structure    __SELECTEDWHEN(tag == 1);

    int * ptrint   __SELECTEDWHEN(tag &gt;= 10 &amp;&amp; tag &lt;= 12);
  } data;
} g;
int x;

int main() {
  g.tag = 12;                 //Select g.data.ptrint
  g.data.ptrint = &amp;x;

  int* px = g.data.ptrint;    //To check that it's okay to access g.data.ptrint,
                              //CCured checks "g.tag &gt;= 10 &amp;&amp; g.tag &lt;= 12"
  return 0;
}
</FONT></PRE>
<a target="_blank" href="examples/ex71.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex71.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
In this case, the <FONT COLOR=blue>__SELECTEDWHEN</FONT> attributes tell CCured that the
field <FONT COLOR=blue>data.anint</FONT> is active when the <FONT COLOR=blue>tag</FONT> field is 0, the field
<FONT COLOR=blue>data.structure</FONT> is active when the <FONT COLOR=blue>tag</FONT> field is 1, and the field
<FONT COLOR=blue>data.ptrint</FONT> is active when the <FONT COLOR=blue>tag</FONT> field is between 10 and
12.<BR>
<BR>
Notes:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue>__SELECTEDWHEN</FONT> annotations can reference more than one tag
 field. The tags all must have integral types, and all must be
 fields of the struct that contains the union in question.
<LI CLASS="li-itemize">You must ensure that the <FONT COLOR=blue>__SELECTEDWHEN</FONT> annotations are
 disjoint. That is, no two fields should be &#8220;selected&#8221; at once.
 CCured does not yet check this.
<LI CLASS="li-itemize">The requirement that tags be written only after the data value
 is in many ways too restrictive. We are currently exploring other
 solutions. If this is too restrictive for your program and you do
 not need to maintain binary compatibility with external code,
 consider letting CCured add its own tag, as described in
 Section&nbsp;<A HREF="#sec-taggedunion-ccured">9.7.1</A>. CCured-maintained tags do not place
 any limitation on write order, since CCured will have exclusive control
 over the tag field that it cares about.
<LI CLASS="li-itemize">When writing the tag field, CCured will zero the data field only
 if the new tag is different from the old.
</UL>
<!--TOC section Annotated Lengths-->

<H2 CLASS="section"><A NAME="htoc79">9.8</A>&nbsp;&nbsp;Annotated Lengths</H2><!--SEC END -->
<A NAME="sec-dependent"></A>
Programmers can annotate array pointers with length attributes.
CCured will then use the annotated length whenever it needs to do a
bounds check on that pointer, instead of transforming the pointer into
a fat pointer. This has two advantages: 
<UL CLASS="itemize"><LI CLASS="li-itemize">
CCured will not need to change the representation of this
 pointer, which improves compatibility with precompiled code.
<LI CLASS="li-itemize">Using a CCured fat pointer to store the length of a buffer may
 be redundant if the program already maintains a similar length value
 near the pointer.
</UL>
Length annotations are allowed in two situations: struct fields may
have length annotations that depend on the values of other fields in
that struct, and function parameters may have lengths that depend on
other parameters in that function. (NB: but the annotations on
function parameters are not yet implemented. Coming soon ...)
<BR>
<BR>
Only pointer types may be annotated. The annotation
<FONT COLOR=blue>__SIZE(<I>exp</I>)</FONT> on a field means that the associated pointer is
<I>exp</I> bytes long, where the expression <I>exp</I> can involve integer
constants, arithmetic, <TT>sizeof</TT>, and the names of other fields in
the same struct. So <FONT COLOR=blue>__SIZE(1 + foo)</FONT> means that the specified
pointer has a length that's one greater than the runtime value of
field foo in the same object.<BR>
<BR>
<FONT COLOR=blue>__COUNT(<I>exp</I>)</FONT> means that the pointer is <I>exp</I> elements long.
So when annotating a pointer with type <FONT COLOR=blue>T*</FONT>, the
annotation <FONT COLOR=blue>__COUNT(<I>exp</I>)</FONT> is equivalent to <FONT COLOR=blue>__SIZE(<I>exp</I> *
sizeof(T))</FONT>.<BR>
<BR>
Any field that is referred to by a <FONT COLOR=blue>__SIZE</FONT> or <FONT COLOR=blue>__COUNT</FONT>
annotation is a <EM>metadata field</EM>. When a metadata field is
modified, any pointer fields that depend on it are set to NULL. <EM>Therefore, when writing both the metadata and pointer fields, programs
must always modify the metadata first, followed by the pointer.</EM> <BR>
<BR>
When an annotated pointer field is read, CCured will read any
metadata fields as well, and associate that length with the pointer.
When a pointer field is written, CCured will check that the buffer's
length is less than or equal to the length specified by the current
value of the metadata fields.
<PRE CLASS="verbatim"><FONT COLOR=blue>
extern void* malloc(int);
#pragma ccuredalloc("malloc", sizein(1), nozero)

struct bar {
  int nrInts;
  int *ints __COUNT(nrInts);
};

struct foo {
  int sizeBars;
  struct bar * bars __SIZE(sizeBars);
};

// Now the function that uses it

void init(struct foo* pFoo) {
  int nrBars = 5;
  pFoo-&gt;sizeBars = nrBars * sizeof(* pFoo-&gt;bars);
  pFoo-&gt;bars = (struct bar*)malloc(pFoo-&gt;sizeBars);
}
</FONT></PRE>
<a target="_blank" href="examples/ex72.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex72.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
In this code, we first overwrite the field <TT>pFoo-&gt;sizeBars</TT>, which
automatically sets the field <TT>pFoo-&gt;bars</TT> to NULL. The next step is
to write a new pointer to the <TT>pFoo-&gt;bars</TT> field. During this
write, CCured will check that the pointer being written (in this case,
the result of <TT>malloc</TT>) is at least &#8220;pFoo-&gt;sizeBars&#8221; bytes long.<BR>
<BR>
<!--TOC section Memory Management-->

<H2 CLASS="section"><A NAME="htoc80">9.9</A>&nbsp;&nbsp;Memory Management</H2><!--SEC END -->
<A NAME="sec-gc"></A>
The high order bit: we use the Boehm-Weiser garbage collector. <BR>
<BR>
TODO : finish this section<BR>
<BR>
<!--TOC section CCured Pragmas-->

<H2 CLASS="section"><A NAME="htoc81">9.10</A>&nbsp;&nbsp;CCured Pragmas</H2><!--SEC END -->
<A NAME="sec-pragma"></A>
The following pragmas are recognized by CCured. Note that pragmas can only
appear in between global declarations. Some of them are discussed in more
detail in following sections:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<FONT COLOR=blue>#pragma box(off)</FONT> - Turn off curing. The code that is not cured does
not contribute constraints to the type inferencer. However the code is changed
slightly during the program transformation phase to make sure that whenever it
refers to global variables that were cured it uses their <FONT COLOR=blue>_p</FONT> field. 
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma box(on)</FONT> - Turn curing back on
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma nobox("myfunc")</FONT> - Turn curing off for the function
<FONT COLOR=blue>myfunc</FONT> 
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma boxtext(...)</FONT> - CCured will turn this pragma into the <FONT COLOR=blue>...</FONT>
text in the cured file
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma ccuredpoly("myfunc1", "myfunc2", "struct foo")</FONT> - CCured will
treat the <FONT COLOR=blue>myfunc1</FONT> and <FONT COLOR=blue>myfunc2</FONT> functions and the <FONT COLOR=blue>foo</FONT> structure
polymorphically. See Section&nbsp;<A HREF="#sec-poly">7.1</A>.
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma ccuredalloc("malloc", nozero, sizein(1))</FONT> - CCured will treat
<FONT COLOR=blue>malloc</FONT> as an allocation function whose length is passed in the first
argument and which does not zero the allocated area. See Section&nbsp;<A HREF="#sec-malloc">7.2</A>.
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma ccuredalloc("calloc", zero, sizemul(1,2))</FONT> - CCured will treat
<FONT COLOR=blue>calloc</FONT> as an allocation function whose length is passed are the product of
the first two arguments and which does zero the allocated area. See
Section&nbsp;<A HREF="#sec-malloc">7.2</A>.
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma ccuredvararg("myfunc", sizeof(struct myfunc_arguments))</FONT> -
Declares <FONT COLOR=blue>myfunc</FONT> to be a variable argument function that can be passed a
variable number of arguments each having one of the types of the fields of
<FONT COLOR=blue>struct myfunc_arguments</FONT>. See Section&nbsp;<A HREF="#sec-vararg">9.6</A>.
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma ccuredvararg("myprintf", printf(2))</FONT> - Declares <FONT COLOR=blue>myprintf</FONT> to
be a printf-like function whose format string is in the second argument.
 See Section&nbsp;<A HREF="#sec-vararg">9.6</A>.
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma ccuredwrapper("foo_wrapper", of("foo"))</FONT> -
 Declares <FONT COLOR=blue>foo_wrapper</FONT> to be a wrapper for <FONT COLOR=blue>foo</FONT>. See
 Chapter&nbsp;<A HREF="#ch-wrapper">8</A>. Implies <FONT COLOR=blue>#pragma cilnoremove</FONT> and <FONT COLOR=blue>#pragma
 ccuredpoly</FONT> for <FONT COLOR=blue>foo_wrapper</FONT>.
<LI CLASS="li-enumerate"><FONT COLOR=blue>#pragma cilnoremove("func1", "var2", "type foo", "struct bar")</FONT> -
Instructs CIL to keep the declarations and definitions of the function
<FONT COLOR=blue>func1</FONT> and variable <FONT COLOR=blue>var2</FONT>, the definition of type <FONT COLOR=blue>foo</FONT> and of
structure <FONT COLOR=blue>bar</FONT>.
</OL>
<!--TOC chapter CCured Warnings and Errors-->

<H1 CLASS="chapter"><A NAME="htoc82">Chapter&nbsp;10</A>&nbsp;&nbsp;CCured Warnings and Errors</H1><!--SEC END -->
<A NAME="ch-warn"></A>
As you use CCured you might encounter various kinds of problems. Most of
these are due to a combination of aggressive coding practices and CCured being
less smart than the programmer. (Note: this section is continuously being
expanded; if you do not see the answer to your question, or if the answer is
not helpful, let us know).<BR>
<BR>
<!--TOC section Merging-->

<H2 CLASS="section"><A NAME="htoc83">10.1</A>&nbsp;&nbsp;Merging</H2><!--SEC END -->
<A NAME="sec-warn-merge"></A>
<UL CLASS="itemize"><LI CLASS="li-itemize">
You see this warning message in the merging stage:
<PRE CLASS="verbatim">
combine20_2.c:11: Warning: uniqueVarNames: Changing the name of local tmp___0 in main to tmp___1
</PRE>This is nothing to worry about. It means that the merged has discovered a
naming error in the merged file and has fixed it. <BR>
<BR>
<LI CLASS="li-itemize">Also during merging, you see:
<PRE CLASS="verbatim">
/usr/include/sys/socket.h:189: Error: Incompatible declaration for accept (4). Previous was at rblsmtpd.c:103 (0) (different type constructors: void  vs. int )
</PRE>
 This means that the merger has detected two incompatible declarations or
definitions of the same external global. You must fix that either by changing
all definitions and declarations to have the same type. In fact, in the
sources for gcc we found a few bugs like this where one function was defined
with one type and was declared and used with another type in some other file.<BR>
<BR>
In some cases however, there is nothing wrong with the program but it just
happens to redefine a function already defined in the library (as in the
example from which we got the error message). The program redefines accepts in
one file and uses the library's accept in another file. When you put the
things together it does not make sense anymore. You should change the name of
your global in that case.<BR>
<BR>
<LI CLASS="li-itemize">Also during merging, you may see:
<PRE CLASS="verbatim">
/home/weimer/cil/include/netdb_wrappers.h:110: Warning: The name gethostent_wrapper is used for two distinct globals
</PRE>
TODO. </UL>
<!--TOC section Inference-->

<H2 CLASS="section"><A NAME="htoc84">10.2</A>&nbsp;&nbsp;Inference</H2><!--SEC END -->
<A NAME="sec-warn-infer"></A>
<UL CLASS="itemize"><LI CLASS="li-itemize">
You see this warning in the Inference stage:
<PRE CLASS="verbatim">
chkshsgr.c:8: Warning: Calling function getgroups without proper prototype: will be WILD.
  getgroups has type void * __attribute__((___ptrnode__(12))) /* /* missing proto */  */()
</PRE>
 You should always have prototypes for the functions that you use. In fact,
CCured will be happy if you include the prototype in at least one of your
modules!<BR>
<BR>
<LI CLASS="li-itemize">Or, you see this
<PRE CLASS="verbatim">
chkshsgr.c:8: Warning: Calling function _exit with 1 arguments when expecting 0: will be WILD.
  _exit has type void ()
</PRE>
 Here what happens is that <FONT COLOR=blue>exit</FONT> is declared like &#8220;void _exit();&#8221;. This
is legal in C, and it allows you to call <FONT COLOR=blue>_exit</FONT> with whatever arguments
you choose. CCured will accept that but the cost will be that the function
becomes a <TT>WILD</TT> function with some significant run-time cost to ensure that
you call it correctly. Better, use a correct prototype!<BR>
<BR>
<LI CLASS="li-itemize">CCured cannot handle soundly inline assembly. You will see this if you
try to cure a program that contains inline assembly.
<PRE CLASS="verbatim">
iopause.c:68: Error: You did not turn on the handling of inline assembly. Better hide this assembly somewhere else!
</PRE>
 You can turn on the (unsound) handling of inline assembly by passing the
argument <FONT COLOR=blue>&ndash;allowInlineAssembly</FONT> to CCured. But you should try instead to
hide that inline assembly from CCured. You can put it in a file that CCured
does not see, for example (pass the name of that function with the
<FONT COLOR=blue>&ndash;leavealone</FONT> argument to CCured). <BR>
<BR>
<LI CLASS="li-itemize">Sometimes you see these warnings:
<PRE CLASS="verbatim">
pathexec_env.c:42: Warning: Encountered sizeof(char */* __attribute__((___ptrnode__(2595))) */) when type contains pointers. Use sizeof expression. Type has a disconnected node.
</PRE>
 Section&nbsp;<A HREF="#sec-sizeof">9.5</A> explains what the problem could be here.<BR>
<BR>
<LI CLASS="li-itemize">Sometimes you get this warning in the inference stage:
<PRE CLASS="verbatim">
Warning: Generated automatic vararg descriptor for log_d: struct autoVarargDescr_log_d : char const   */* __attribute__((___ptrnode__(922))) */,
uid_t
If this is a printf-like function you should declare it!
</PRE>
 This means that the function <FONT COLOR=blue>log_d</FONT> is a variable argument function that
was not declared using a <FONT COLOR=blue>ccuredvararg</FONT> pragma. In absence of such a pragma,
CCured examines all the call sites of that function and collects the set of
types for the arguments. You must inspect the definition of the function
involved to ensure that CCured has inferred correctly. If you see that this is
not the case, <EM>or if the function is a printf-like function</EM>, the you
should provide an explicit descriptor, as explained in Section&nbsp;<A HREF="#sec-vararg">9.6</A>. <BR>
<BR>
<LI CLASS="li-itemize">You get an error &#8220;<FONT COLOR=blue>type mismatch between called and use of va_arg
function</FONT>&#8221;. One possible problem is that you have a printf-like function that
CCured did not recognize and it inferred for it a wrong set of possible
argument types. For example,
<PRE CLASS="verbatim"><FONT COLOR=blue>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void myprintf(int level, const char *fmt, ...)
{
  va_list ap;
  char msgbuf[2048];

  va_start(ap,fmt);
  vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
  puts(msgbuf); 
  va_end(ap); 
}

int main()
{
  int i;

  myprintf(0, "Hello, %s! 2+2=%d\n", "world", 4); 
  return 0; 
} 
</FONT></PRE>
<a target="_blank" href="examples/ex73.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex73.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Here CCured will infer that the possible argument types for <FONT COLOR=blue>myprintf</FONT>
contain only <FONT COLOR=blue>int</FONT> and <FONT COLOR=blue>char *</FONT> (based on the call). Yet, the built-in
<FONT COLOR=blue>vsnprintf</FONT> uses a different set of argument types. To fix this problem you
must add:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma ccuredvararg("myprintf", printf(2))
</FONT></PRE><BR>
<BR>
<LI CLASS="li-itemize">You might also see a warning such as the following:
<PRE CLASS="verbatim">
/home/necula/ccured/include/netdb_wrappers.h:329: Warning: Solver: changing User Specified SAFE node 1371 (the local variable p_ith_alias) to WILD
</PRE>
 This means that CCured must change a user-specified <TT>SAFE</TT> pointer into
<TT>WILD</TT>. Open the browser (see Section&nbsp;<A HREF="#sec-browser">5.1</A>) and type in the node number
in question. Have you annotated that pointer to be <TT>SAFE</TT>? If yes, then
CCured thinks otherwise. If the message is from a wrapper (like the above
example) then most likely is a symptom of a badly written wrapper.<BR>
<BR>
<LI CLASS="li-itemize">Another possible warning that you might see is:
<PRE CLASS="verbatim">
/usr/include/sys/socket.h:156: Warning: sendmsg appears to be external
  (it has a wrapper), yet it has a mangled name: sendmsg_scsws_.
  Did you forget to use __ptrof and a version of __mkptr?
 For more information, consult the online documentation on
  "Writing Wrappers".
</PRE>
 In this case CCured mangles the name of the <FONT COLOR=blue>sendmsg</FONT> function (see
Section&nbsp;<A HREF="#sec-mangling">8.1</A>). The type of this function is
<PRE CLASS="verbatim">
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   int msg_iovlen ;
   void *msg_control ;
   socklen_t msg_controllen ;
   int msg_flags ;
};
int sendmsg(int s, const struct msghdr *fat_msg, int flags);
</PRE>
 The particular mangling suffix (_scsws_) means that the <FONT COLOR=blue>msg_iov</FONT>
pointer must be <TT>WILD</TT>. We can investigate why this happens also using the
browser. We press &#8220;Show types&#8221; and then click on <FONT COLOR=blue>msghdr</FONT>. We see that
indeed the <FONT COLOR=blue>msg_iov</FONT> field is <TT>WILD</TT> and when we click on the red pointer
type we find out that the <FONT COLOR=blue>__trusted_add_iov</FONT> issue is the cause of this
problem.</UL>
<!--TOC section Curing-->

<H2 CLASS="section"><A NAME="htoc85">10.3</A>&nbsp;&nbsp;Curing</H2><!--SEC END -->
<A NAME="sec-warn-cure"></A>
<UL CLASS="itemize"><LI CLASS="li-itemize"><PRE CLASS="verbatim">
main.c:278: Warning: Casting scalar (1) to non-WILD pointer in main!
</PRE>This warning says that the given scalar expression is assigned to a pointer
lvalue. This assignment probably has the effect that the lvalue is not
<TT>SAFE</TT>. During the assignment, CCured will produce a fat pointer value whose
metadata is NULL, which means that it cannot be used to access memory. In this
particular case, this is Ok, since nobody in its right mind would plan to use
the number 1 as an address. <BR>
<BR>
But sometimes you have a pointer value that is stored in an integer variable
and you want later to use it as a pointer. This is not safe in CCured, because
the compiler cannot be sure where this pointer originated. There are several
ways to solve this one. First, maybe the scalar variable that is being
assigned should be a pointer variable after all. If you cannot do that then
you must come up with some other pointer variable that is supposed to be in
the same home memory area as the scalar. Then you can change the code, as
follows: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * home;
int   scalar;
int * p = (int*)scalar;
// Change the last line:
int * p = home + (((int)scalar - (int)home) &gt;&gt; 2);
// Or, even
int * p = __mkptr(scalar, home);
</FONT></PRE>
Anyway, it is best if you keep pointer values into pointer variables at
all times. <BR>
<BR>
<LI CLASS="li-itemize"><PRE CLASS="verbatim">
Error: The suffix for the compatible version of sigaction_COMPAT is ws. This means that you have misused this compatible version. Please check your code.
</PRE>
 The <FONT COLOR=blue>sigaction_COMPAT</FONT> is a copy of <FONT COLOR=blue>struct sigaction</FONT> that CCured
creates automatically for use in wrappers. However, that structure should
remain compatible with the external version. When you get this error it means
that you have written an incorrect wrapper and somehow the constraints from
your program flow into the compatible version of the structure. You should use
the browser to find out why this happens.<BR>
<BR>
<LI CLASS="li-itemize"><PRE CLASS="verbatim">
Warning: isImported for CHECK_FORMATARGS, which is not even declared
</PRE>
TODO. <BR>
<BR>
<LI CLASS="li-itemize"><PRE CLASS="verbatim">
dnssec.c:236: Warning: Casting SAFE void* to FSEQ. The area is 1 word.
</PRE>
TODO. </UL>
<!--TOC section Linking-->

<H2 CLASS="section"><A NAME="htoc86">10.4</A>&nbsp;&nbsp;Linking</H2><!--SEC END -->
<A NAME="sec-warn-link"></A>
<UL CLASS="itemize"><LI CLASS="li-itemize">During linking you get the error:
<PRE CLASS="verbatim">
mathopd_comb.o: In function `log_request':
mathopd_comb.o(.text+0x189fd): undefined reference to `asctime_qs'
</PRE>
 If the missing function is one with a mangling suffix (see Section&nbsp;<A HREF="#sec-mangling">8.1</A>)
then this means that CCured has changed the calling convention of the
functions involved (in this case <FONT COLOR=blue>asctime</FONT>) and you need to provide a
wrapper to match the calling convention to the library version. See
Chapter&nbsp;<A HREF="#ch-wrapper">8</A> for details on how to do that.<BR>
<BR>
If the missing function has a &#8220;_t&#8221; mangling, then it is a <TT>WILD</TT>
function. You have either used the function without a prototype, or with a
type that does not match the prototype, or you have cast its pointer to
something strange. See if you can fix the prototypes (and fill in the argument
types in the function types).<BR>
<BR>
However, if the missing function does not have a mangled name then it means
that somehow CCured has lost an external global. This is probably a bug in
CIL, most likely in the module that removes unnecessary locals and prototypes.
Try disabling that module by passing the <FONT COLOR=blue>&ndash;keepunused</FONT> flag to CCured. <BR>
<BR>
<LI CLASS="li-itemize">You get this error while trying to use the merger.
<PRE CLASS="verbatim">
gcc -D_GNUCC  -o tcpserver -s tcpserver_comb.o cdb.a dns.a time.a unix.a byte.a
cdb.a: could not read symbols: Archive has no index; run ranlib to add one
</PRE>
 You look at <FONT COLOR=blue>cdb.a</FONT> and it is not a object file at all but, starts like
this:
<PRE CLASS="verbatim">
!&lt;arch&gt;
cdb.o/          1042137412  1002  100   100644  20279     `
#pragma merger(0, "./cdb.i", "")
# 1 "cdb.c"
 

# 1 "/home/necula/ccured/include/gcc_2.95.3/sys/types.h" 1
</PRE>
 You look at <FONT COLOR=blue>cdb.o</FONT> and, indeed, it is not an object file, but a copy of
the <FONT COLOR=blue>cdb.i</FONT> file. This is normal. What happened is that for merging,
compilation means just preprocessing (this explains why <FONT COLOR=blue>cdb.o</FONT> is as it
is). But the problem is that you have just invoked the <FONT COLOR=blue>ar</FONT> program to build
a library out of object files that are actually text file. The solution is to
use instead of <FONT COLOR=blue>ar</FONT> the command <FONT COLOR=blue>ccured &ndash;mode=AR</FONT>. This should create the
<FONT COLOR=blue>cdb.a</FONT> library as needed, but if you look at it, it is a C source file that
contains all the stuff from the archived files, with the necessary renaming to
avoid conflicts between static variables. You can find more information about
the merger at <A HREF="../cil/merger.html"><TT>../cil/merger.html</TT></A>. <BR>
<BR>
<LI CLASS="li-itemize">You get this error while trying to use the merger. 
<PRE CLASS="verbatim">
ranlib: cdb.a: File format not recognized
</PRE>
 You look at <FONT COLOR=blue>cdb.a</FONT> and find that it is a merged source file. You should
not use <FONT COLOR=blue>ranlib</FONT> on such files.<BR>
<BR>
<LI CLASS="li-itemize">Or this link-time error: 
<PRE CLASS="verbatim">
client.c:2139: warning: second parameter of `va_start' not last named
argument
</PRE>
TODO. </UL>
<!--TOC section Running the Cured Code-->

<H2 CLASS="section"><A NAME="htoc87">10.5</A>&nbsp;&nbsp;Running the Cured Code</H2><!--SEC END -->
<A NAME="sec-warn-run"></A>
When you run the code you might get run-time errors. Make sure you read the
Chapter&nbsp;<A HREF="#ch-invoke">4</A> on ways to control the handling of errors. 
<UL CLASS="itemize"><LI CLASS="li-itemize">At run-time you get the error:
<PRE CLASS="verbatim">
Failure UBOUND at config.c:924: new_pool(): Ubound
Aborted
</PRE>
 This says that the code triggered an upper bound check. Investigate the
problem first by looking at the line number. Also run the program with
<FONT COLOR=blue>gdb</FONT>; it should stop right where the error arises.<BR>
<BR>
There is one relatively common instance when you get a UBound error. Say that
the variable <FONT COLOR=blue>ceiling</FONT> is intended to be the end of a memory area:
<PRE CLASS="verbatim"><FONT COLOR=blue>
int * ceiling = area + area_length;
</FONT></PRE>
The <FONT COLOR=blue>area</FONT> pointer will be inferred <TT>FSEQ</TT> but the <FONT COLOR=blue>ceiling</FONT> pointer
will be inferred <TT>SAFE</TT>. This means that before the assignment, CCured will
insert an upper-bound check, which will fail. <BR>
<BR>
There are several solutions:
 <UL CLASS="itemize"><LI CLASS="li-itemize">
 Change the <FONT COLOR=blue>ceiling</FONT> pointer to be a <TT>FSEQ</TT> pointer. This is always
 Ok, or
 <LI CLASS="li-itemize">Change the <FONT COLOR=blue>ceiling</FONT> pointer to be an integer. This is Ok if you
 never plan to use the value it contains as a pointer (scan the <FONT COLOR=blue>comb.c</FONT>
 file to see all the uses of a variable), or
 <LI CLASS="li-itemize">Pass the<FONT COLOR=blue>&ndash;noUnrefPointerChecks</FONT> to CCured to ask it to figure out
 those pointer values that do not appear to be used, and to treat them as
 integers.
 </UL><BR>
<BR>
<LI CLASS="li-itemize"><PRE CLASS="verbatim"> 
Failure UBOUND at ping.c:1303: main(): Ubound
</PRE>
 Also an upper bound. We look at the code and we find the following:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct icmp {
   int various;
   char data[1];
};
char outpack[65536];

char foo() {
 // Get the 8th data character
 return ((struct icmp*)outpack)-&gt;data[8];
}
</FONT></PRE>
<a target="_blank" href="examples/ex74.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex74.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
This looks good overall, but technically we are accessing the 8th character
in a 1 character array. Once you cast the <FONT COLOR=blue>outpack</FONT> array to <TT>struct
icmp*</TT>, you loose access to some of the trailing characters. If you look at
the cured code you will see in fact the CCured uses a length of 1 in doing the
bounds check.<BR>
<BR>
Instead you could change the code to express more directly what you mean:
<PRE CLASS="verbatim"><FONT COLOR=blue>
struct icmp {
   int various;
   char data[1];
};
char outpack[65536];

char foo() {
 // Get the 8th data character
 return * (outpack + (int) &amp;((struct icmp*)0)-&gt;data[8]);
}
</FONT></PRE>
<a target="_blank" href="examples/ex75.browser/index.html">Browse</a> the CCured inferred pointer kinds,
or see the <A HREF="examples/ex75.cured.c">CCured output</A>
for this code fragment<BR>
<BR>
Now the access is in the <TT>outpack</TT> array and its length is used for bounds
checking. <BR>
<BR>
<LI CLASS="li-itemize">You get this error: <PRE CLASS="verbatim">
Failure STORE_SP at pathexec_env.c:47: pathexec_qq(): Storing stack address
</PRE>
 This means that you are trying to store into the heap, a pointer to some
stack location. See Section&nbsp;<A HREF="#sec-storeptr">3.5</A> for how to fix this. In rare occasions
the pointer is from your <TT>argv</TT> or <TT>envp</TT> arguments. Use <TT>strdup</TT> in
that case. </UL>
<!--TOC chapter License-->

<H1 CLASS="chapter"><A NAME="htoc88">Chapter&nbsp;11</A>&nbsp;&nbsp;License</H1><!--SEC END -->

Copyright (c) 2001-2002, 
<UL CLASS="itemize"><LI CLASS="li-itemize">
George C. Necula &lt;necula@cs.berkeley.edu&gt;
<LI CLASS="li-itemize">Scott McPeak &lt;smcpeak@cs.berkeley.edu&gt;
<LI CLASS="li-itemize">Wes Weimer &lt;weimer@cs.berkeley.edu&gt;
</UL>
All rights reserved.<BR>
<BR>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:<BR>
<BR>
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.<BR>
<BR>
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.<BR>
<BR>
3. The names of the contributors may not be used to endorse or promote
products derived from this software without specific prior written
permission.<BR>
<BR>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.<BR>
<BR>
<!--TOC chapter Bug reports-->

<H1 CLASS="chapter"><A NAME="htoc89">Chapter&nbsp;12</A>&nbsp;&nbsp;Bug reports</H1><!--SEC END -->

If you find a bug in CCured, please send email to
<A HREF="mailto:necula@cs.berkeley.edu">George Necula</A>.<BR>
<BR>
<!--TOC chapter Changes-->

<H1 CLASS="chapter"><A NAME="htoc90">Chapter&nbsp;13</A>&nbsp;&nbsp;Changes</H1><!--SEC END -->
<A NAME="sec-changes"></A><!--NAME changes.html-->
<BR>
<BR>
Below are some of the changes in the CCured system. These are in addition to
<A HREF="../cil/changes.html">changes made to the underlying CIL infrastructure</A>
<UL CLASS="itemize"><LI CLASS="li-itemize">
<B>August 6, 2006</B>: <B>Released version 1.3.5</B>
<LI CLASS="li-itemize"><B>March 31, 2006</B>: Fix bugs with global initializers and
 errors that were being ignored in the choptim optimizer.
<LI CLASS="li-itemize"><B>November 1, 2005</B>: Improved the <FONT COLOR=blue>__SIZE</FONT> and
 <FONT COLOR=blue>__COUNT</FONT> annotations. See Section&nbsp;<A HREF="#sec-dependent">9.8</A>
<LI CLASS="li-itemize"><B>September 26, 2005</B>: Reenabled special handling of strings.
 This may break some code, so use &ndash;noStrings to turn it off.
<LI CLASS="li-itemize"><B>June 14, 2005</B>: Tagged unions now use the same tags as RTTI
 pointers, making them more flexible. See Section&nbsp;<A HREF="#sec-taggedunion">9.7</A>.
<LI CLASS="li-itemize"><B>January 11, 2005</B>: <B>Released version 1.3.2</B>
<LI CLASS="li-itemize"><B>January 11, 2003</B>: Fixed bug in strcpy wrapper. 
<LI CLASS="li-itemize"><B>September 14, 2004</B>: Fixed performance bug on gcc 3.0 and later.
<LI CLASS="li-itemize"><B>August 7, 2004</B>: <B>Released version 1.3.1</B>
<LI CLASS="li-itemize"><B>July 28, 2004</B>: Ocaml version 3.08 is required.
<LI CLASS="li-itemize"><B>February 20, 2004</B>: <B>Released version 1.2.4</B><BR>
<BR>
<LI CLASS="li-itemize"><B>February 15, 2004</B>: Inlined some of the <TT>mkptr</TT> and <TT>ptrof</TT>
 wrappers.
<LI CLASS="li-itemize"><B>February 14, 2004</B>: New implementation for discriminated unions.
<LI CLASS="li-itemize"><B>January 26, 2004</B>: Changed wrapper helpers such as
 __ptrof so that the can no longer be used to silently cast from
 one type to another.<BR>
<BR>
<LI CLASS="li-itemize"><B>January 19, 2004</B>: Changed the statistics to not include unused
 pointer nodes. 
<LI CLASS="li-itemize"><B>November 25, 2003</B>: <B>Released version 1.2.2</B>
<LI CLASS="li-itemize"><B>October 13, 2003</B>: Fixed the handling of polymorphic structures. <BR>
<BR>
<LI CLASS="li-itemize"><B>September 17, 2003: Released version 1.2.1.</B> This release includes
many fixes in the underlying CIL infrastructure.<BR>
<BR>
<LI CLASS="li-itemize"><B>April 8, 2003</B>: Started version numbering for CCured. Released
version 1.1.0, based on CIL 1.1.0.<BR>
<BR>
<LI CLASS="li-itemize"><B>April 7, 2003</B>: Fixes in the error messages and the control of
error logging and reporting. Fixed a bug in fat function argument splitting. <BR>
<BR>
<LI CLASS="li-itemize"><B>January 10, 2003</B>: Numerous changes, including to this manual.
<LI CLASS="li-itemize"><B>October 14, 2002</B>: CCured is now available under the BSD license
(see the License section or the file LICENSE). 
</UL>
<!--TOC chapter Inference Results-->

<H1 CLASS="chapter"><A NAME="htoc91">Appendix&nbsp;A</A>&nbsp;&nbsp;Inference Results</H1><!--SEC END -->
<A NAME="ch-graph"></A>
The correspondence between the source code and the annotated graph can
be found in the <FONT COLOR=blue>infer.c</FONT> file. You may need to pass <FONT COLOR=blue>&ndash;emitinfer</FONT> to
<FONT COLOR=blue>ccured</FONT> to see this file. For a base file named <FONT COLOR=blue>FOO.c</FONT>, the graph
will be shown in <FONT COLOR=blue>FOOinfer.c</FONT>. This file represents the state of the tool
after pointer kind inference but before run-time checks have been inserted
and before names have been mangled. The <FONT COLOR=blue>infer.c</FONT> file consists of two
sections: the annotated source code and the inference graph. <BR>
<BR>
<!--TOC subsection Annotated Source-->

<H3 CLASS="subsection"><A NAME="htoc92">A.0.1</A>&nbsp;&nbsp;Annotated Source</H3><!--SEC END -->
<A NAME="sec-graphannot"></A>
The annotated source code is just the original source code with the special
syntax <FONT COLOR=blue>__NODE(n)</FONT> associated with every pointer type in the program.
There are two main places where the <FONT COLOR=blue>__NODE</FONT> attribute can appear:
immediately following a pointer-type constructor <FONT COLOR=blue>*</FONT> or immediately
following the name of a variable. In the former case the attribute specifies
the node associated with the pointer-type while in the latter
case the attribute specifies the node associated with the address-of the
variable. <BR>
<BR>
For example, the line:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  int * __NODE(3) ptr __NODE(4);
  int * __NODE(6) * __NODE(7) matrix __NODE(8);
</FONT></PRE>
indicates that node 3 in the graph is associated with the pointer variable
<FONT COLOR=blue>ptr</FONT> and node 4 is associated with the address of <FONT COLOR=blue>ptr</FONT>. Node 7 is
associated with the top-level pointer in the variable <FONT COLOR=blue>matrix</FONT>, while node 6
is associated with the inner pointer (e.g., node 6 is associated with the type
of the expression <FONT COLOR=blue>matrix[0]</FONT>). <FONT COLOR=blue>__NODE(n)</FONT> is a type qualifier (like
<FONT COLOR=blue>const</FONT> or <FONT COLOR=blue>restrict</FONT>) that modifies the pointer type constructor just to
its left.<BR>
<BR>
Consider the following simple test case:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  int main() { 
    int * ptr;
    int base;
    ptr = &amp;base;
    ptr ++; 
  } 
</FONT></PRE>
If we run it through CCured's inferencer we will see:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  int main() {
    int * __NODE(90) ptr __NODE(91);
    int base __NODE(92); 
    ptr = &amp; base;
    ptr = ptr + 1;
  } 
</FONT></PRE>
Node 90 is associated with <FONT COLOR=blue>ptr</FONT>. The additional nodes to the right are
associated with the addresses of variables. Node 91 is associated with
<FONT COLOR=blue>&amp;ptr</FONT> and node 92 is associated with <FONT COLOR=blue>&amp;base</FONT>. Since there is an
assignment between <FONT COLOR=blue>ptr</FONT> and <FONT COLOR=blue>&amp;base</FONT>, we expect to see an edge between
nodes 90 and 92 in the graph. The graph itself can be found at the end of
the C code near a line like:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  /* Now the solved graph (solver) */
</FONT></PRE>
<!--TOC subsection Inference Graphs -->

<H3 CLASS="subsection"><A NAME="htoc93">A.0.2</A>&nbsp;&nbsp;Inference Graphs </H3><!--SEC END -->
<A NAME="sec-graphformat"></A>
In order to see the whole graph, you must pass the argument
<TT>&ndash;emitGraphDetailLevel=3</TT> to Ccured. The graph at the end of
<TT>FILEinfer.c</TT> is represented as a printout of every node. Each node
description has the following form:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  ID : Location (flags) (node this type points to)
   K=Kind/Reason  T=(base type of this node)
   S=(successor edges)
   P=(predecessor edges)
</FONT></PRE>
So the entry for node 90 (from the example in Section&nbsp;<A HREF="#sec-graphannot">A.0.1</A>) might
look like:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  90 : Local(./simple.i.main.ptr).1 (stack,posarith,) ()
   K=FSEQ/from_flag T=int
   S=
   P=92:Cast
</FONT></PRE>
The node number is 90, the location field says that this node represents a
local variable named <FONT COLOR=blue>ptr</FONT> inside the <FONT COLOR=blue>main</FONT> function of the file
<FONT COLOR=blue>simple.i</FONT>. The location of a node is a unique name for the pointer type.
Locations use a hierarchical naming scheme is composed of a <EM>place</EM>
followed by a period and an <EM>index</EM> within the place. The following places
are used:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Glob(var)</TT> - this is associated with the global variable <FONT COLOR=blue>var</FONT>
<LI CLASS="li-itemize"><TT>Static(file.var)</TT> - this is associated with the file-scope variable
<FONT COLOR=blue>var</FONT> from file <TT>file</TT>.
<LI CLASS="li-itemize"><TT>Local(file.func.var)</TT> - this is associated with the local variable
<FONT COLOR=blue>var</FONT> occurring in function <FONT COLOR=blue>func</FONT> from file <TT>file</TT>.

<LI CLASS="li-itemize"><TT>Field(fieldname)</TT> - this is associated with a field in a structured
type. 
<LI CLASS="li-itemize"><TT>Anon(nr)</TT> - this is associated with an occurrence of a pointer-type
constructor in a cast or in the <FONT COLOR=blue>sizeof</FONT> expression.
</UL>
Since each place can contain many occurrences of a pointer-type constructor
(e.g. in a declaration <FONT COLOR=blue>int * * x</FONT>) we use indices to differentiate between
such occurrences. For a variable place (<TT>Glob</TT>, <TT>Static</TT>, <TT>Local</TT>), the
index 0 is always associated with the node corresponding to the address of the
variable. Then we traverse the type of the variable in depth-first order (for
functions we start with the result and then continue with the arguments) and
we assign indices starting at 1. For <TT>Field</TT> and <TT>Anon</TT> we do a similar
traversal. <BR>
<BR>
The flags field is a list of the following values:<BR>
<BR>
 
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><B>Flag</B></TD>
<TD ALIGN=left NOWRAP><B>Meaning</B></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>stack</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may contain a stack address</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>escape</TT></TD>
<TD ALIGN=left NOWRAP>this value may be assigned through a pointer 
 and escape to the heap</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>upd</TT></TD>
<TD ALIGN=left NOWRAP>a write may be performed through this pointer</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>posarith</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may be subject to positive 
 pointer arithmetic</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>arith</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may be subject to arbitrary 
 pointer arithmetic</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>null</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may become <TT>NULL</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>int</TT></TD>
<TD ALIGN=left NOWRAP>an int may be cast into this pointer</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>noproto</TT></TD>
<TD ALIGN=left NOWRAP>this pointer is associated with a function 
 that is missing a prototype</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>interf</TT></TD>
<TD ALIGN=left NOWRAP>this pointer is associated with a function 
 that is part of an interface</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>sized</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may point into a sized array</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>reach_s</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may flow into a string</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>reach_q</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may flow into a <TT>SEQ</TT>pointer</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>reach_i</TT></TD>
<TD ALIGN=left NOWRAP>this pointer may flow into an <TT>INDEX</TT>pointer</TD>
</TR></TABLE>
 <BR>
In our example, node 90 has the <TT>posarith</TT> flag because it represents
<TT>ptr</TT> and <TT>ptr++</TT> appears in the code. Node 90 has the <TT>stack</TT> flag
because <TT>&amp;base</TT> is a stack address and the assignment <TT>ptr = &amp;base</TT>
occurs in the code.<BR>
<BR>
Continuing our example, the text <TT>K=FSEQ/from_flag</TT> tells us that node
the pointer type associated with 90 is <TT>FSEQ</TT>because of one of the flags
(in this case, the <TT>posarith</TT> flag). That is, the type inference has made
node 90 a forward sequence pointer (one that carries its upper bound with
it) because positive pointer arithmetic is performed on it (so we will need
a run-time check to make sure that it stays in bounds). <BR>
<BR>
The text <TT>T=int</TT> tells us the base type of node 90, that is, node 90 is
associated with a pointer to an <TT>int</TT>. <BR>
<BR>
The <TT>S=</TT> and <TT>P=</TT> lists show successors and predecessors of this node.
In our example, the text <TT>P=92:Cast</TT> means that node 90 has a predecessor
edge of type <TT>Cast</TT> from node 92 (the node for <TT>&amp;base</TT>). That is,
information from node 92 flows into node 90. This is the graph's way of
representing the assignment statement <TT>ptr = &amp;base</TT>. There are various
sorts of edges in the graph: <BR>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><B>Edge Name</B></TD>
<TD ALIGN=left NOWRAP><B>Meaning</B></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>Cast</TT></TD>
<TD ALIGN=left NOWRAP>the value of pred may flow into succ</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>Compat</TT></TD>
<TD ALIGN=left NOWRAP>pred and succ must have equal types</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>Safe</TT></TD>
<TD ALIGN=left NOWRAP>if pred is <TT>WILD</TT>, succ must be <TT>WILD</TT>as well</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>(usually links structures and their fields)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>Null</TT></TD>
<TD ALIGN=left NOWRAP>a <TT>NULL</TT> flows in the direction of the edge</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>Index</TT></TD>
<TD ALIGN=left NOWRAP>if pred is <TT>INDEX</TT>, succ must be <TT>INDEX</TT>as well</TD>
</TR></TABLE><BR>
Of these, <TT>Cast</TT>, <TT>Compat</TT> and <TT>Safe</TT> are the most common. <TT>Cast</TT>
represents casts and assignments, <TT>Safe</TT> links up fields and structures
so that they have consistent pointer kinds and <TT>Compat</TT> ensures equality
between underlying pointers. As an example, in the code:
<PRE CLASS="verbatim"><FONT COLOR=blue>
        int * __NODE(1) * __NODE(2) a;
        int * __NODE(3) * __NODE(4) b;
        a = b; 
</FONT></PRE>
We would see a <TT>Cast</TT> edge from 4 to 2 and a <TT>Compat</TT> edge between 1
and 3. The <TT>Compat</TT> edge ensures that nodes 1 and 3 will end up with the
same pointer kind. <BR>
<BR>
<!--TOC section Type Names-->

<H2 CLASS="section"><A NAME="htoc94">A.1</A>&nbsp;&nbsp;Type Names</H2><!--SEC END -->
<A NAME="sec-tnames"></A>
CCured will also rename types that are expanded to contain extra
information used by the run-time checks that ensure safety. For example, a
<TT>SEQ</TT>pointer needs to carry information about its bounds. This information
is stored adjacent to the main pointer, but as a result a <TT>SEQ</TT>pointer is
larger than a normal C pointer. Thus a structure that contains a <TT>SEQ</TT>pointer will be larger than an otherwise-identical structure that contains
a normal C pointer (or a <TT>SAFE</TT>pointer). In addition, the offsets of any
structure fields that come after the <TT>SEQ</TT>pointer will be different. To
mark these differences and indicate new types, CCured will change the names
of types and structure. CCured does this by prepending strings to the
structure or type name. <BR>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><B>Pointer Kind</B></TD>
<TD ALIGN=left NOWRAP><B>Type Prefix</B></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>WILD</TT></TD>
<TD ALIGN=left NOWRAP><TT>wildp_</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>INDEX</TT></TD>
<TD ALIGN=left NOWRAP><TT>indexp_</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>SEQ</TT></TD>
<TD ALIGN=left NOWRAP><TT>seq_</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>SEQN</TT></TD>
<TD ALIGN=left NOWRAP><TT>seq_</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>FSEQ</TT></TD>
<TD ALIGN=left NOWRAP><TT>fseqp_</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>FSEQN</TT></TD>
<TD ALIGN=left NOWRAP><TT>fseqp_</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>SAFE</TT></TD>
<TD ALIGN=left NOWRAP>No associated prefix</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>RWSTRING</TT></TD>
<TD ALIGN=left NOWRAP>No associated prefix</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>ROSTRING</TT></TD>
<TD ALIGN=left NOWRAP>No associated prefix</TD>
</TR></TABLE><BR>
For example, given a program of the form:
<PRE CLASS="verbatim"><FONT COLOR=blue>
  Foo * ptr;
  ptr++;
</FONT></PRE>
CCured will probably infer that <TT>ptr</TT> should be an <TT>FSEQ</TT>pointer. The
resulting cured code will have the following form: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
  typedef struct {        /* type made by CCured */
    Foo * __FSEQ _p;      /* actual pointer */ 
    void * _e;            /* end of the allocated region: upper bound */
  } fseqp_Foo;            /* FSEQ pointer to an int */ 

  fseqp_Foo ptr;
  // code for "ptr++;"
</FONT></PRE>
If the original code were: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
  Foo ** ptr;
  ptr++;                /* forces ptr to be FSEQ */
  ptr[0]--;             /* forces *ptr to be SEQ */ 
</FONT></PRE>
We would expect the final type of <TT>ptr</TT> in the cured code to be
<TT>fseqp_seq_Foo</TT>, because <TT>ptr</TT> will have the type &#8220;(forward sequence
pointer) to (sequence pointer) to Foo.&#8221; Note that <TT>fseqp_seq_Foo</TT> is
not merely a name mangled form of <TT>Foo</TT>, since both the definition of
<TT>Foo</TT> and the definition of <TT>fseqp_seq_Foo</TT> will exist in the final
cured program. <BR>
<BR>
<!--TOC chapter A Tour of the Source Code-->

<H1 CLASS="chapter"><A NAME="htoc95">Appendix&nbsp;B</A>&nbsp;&nbsp;A Tour of the Source Code</H1><!--SEC END -->

<EM>This section was updated on Janury 2003</EM>
<PRE CLASS="verbatim">
./: 
  configure:            a shell script that creates the CCured makefiles by 
                        scanning your system for existing programs (like gcc)
  Makefile.cil.in:      instructions for building CIL
  Makefile.in:          instructions for building CCured
  Makefile.ocaml:       used by Makefile.ccured for the Ocaml part
  Makefile.gcc:         Included in the above if you use gcc
  Makefile.msvc:        Included in the above if you use Microsoft Visual C

./src: (ML code)
  main:                 driver for CCured: parses command line arguments
                        and transforms its input C files

./src/ccured: (ML code)
  cure:                  inserts run-time checks into C code based on 
                        pointer annotations
  curesplit:             turns multi-word structure pointer representations 
                        into multiple single-word variables (increases
                        performance by allowing later compilers to make
                        better optimizations)
  curestats:             counts the static number of run-time checks
                        inserted
  curechecks:           Some run-time checks for CCured
  cxxpp:                A preprocessor for EDG's output on C++ lowering.
  markptr:              marks pointers based on their usage so that the
                        inferencer can pick an efficient representation
  markutil:             Various utility functions
  optim:                optimizes the placement of run-time checks
  ptrnode:              a graph data structure used by the inferencer
  poly:                 handling of polymorphism
  seoptim:              a symbolic-execution based run-time check
                        eliminator
  solver:               an old inferencer
  solveutil:            support functions common to all inferencers
  type:                 an implementation of physical subtyping; determines
                        if one C type is a physical subtype of another
  typecheck:            verify that the pointer representations have been
                        assigned soundly
  unionfind:            a support data structure
  vararg:               handling of variable argument functions
  wrappers:             handling of wrappers

./bin/: (scripts)
  ccured:               a drop-in replacement for 'gcc' and for MS 'cl'

./include/: (C header files for use with programs being cured)
  ccured_GNUCC.patch:   a description of what to patch (modify) in GCC's
                        standard header files
  ccured_MSVC.patch:    as above, but for MS VC
  gcc_&lt;version&gt;/:       the patched files created when ccured_GNUCC.patch
                        is applied to the files in your /usr/include.
                        &lt;version&gt; is your version of gcc.  These files are
                        created when you build ccured.
  cl_&lt;version&gt;/:        as above, but for MSVC.
  ccured.h:             included before curing
  ccuredcheck.h:        inline macros for doing run-time checks (included
                        after curing)
  ccuredannot.h:        various declarations and macros common to ccured.h and
                        ccuredcheck.h
  *_wrappers.h:         wrappers for various functions in the standard library.
                        For example, we patch stdio.h to #include
                        stdio_wrappers.h, so that whenever you include stdio.h
                        in the target program the appropriate wrappers are
                        brought in as well.

./lib/: (C code for use at runtime)
  ccuredlib.c:          a library for error handling, wrapper helpers, etc
  gc/:                  boehm-weiser garbage collector 
                        (http://www.hpl.hp.com/personal/Hans_Boehm/gc/)
  browser*:             browser Javascript code
</PRE>
 
<!--TOC chapter Old Tutorials-->

<H1 CLASS="chapter"><A NAME="htoc96">Appendix&nbsp;C</A>&nbsp;&nbsp;Old Tutorials</H1><!--SEC END -->
 
<!--TOC section ftpd-->

<H2 CLASS="section"><A NAME="htoc97">C.1</A>&nbsp;&nbsp;ftpd</H2><!--SEC END -->

<B>Note: this section was written on 6/29/01. CCured has changed since
 then.</B>.<BR>
<BR>
Once you download the sources for a new package, you can run the translator
on it. To create a Makefile target for a package you typically add to
cil/Makefile a target that just invokes make on the package's own Makefile
with the CC variable bound to &#8220;ccured &ndash;merge&#8221;. I'll use the 6/29/01 version
of ftpd as my example.<BR>
<BR>
First we try to run it without our tool involved:
<PRE CLASS="verbatim">
  % make ftpd-clean
  % cd test/ftpd/ftpd
  % make
</PRE>This succeeds, generating an 'ftpd' binary. In the case of 'ftpd', 
running it is slightly complicated:
<PRE CLASS="verbatim">
  % ./ftpd -D -d -p 3333
  (then in another window)
  % telnet localhost 3333
  Trying 127.0.0.1...
  Connected to localhost.
  Escape character is '^]'.
  220 madrone.cs.berkeley.edu FTP server (Version 6.5/OpenBSD, linux port 0.3.2) ready.
  (etc)
</PRE>This is (to our way of measuring) success.<BR>
<BR>
Now we try it in 'cil' mode:
<PRE CLASS="verbatim">
  % cd cil
  % make ftpd-clean
  % make ftpd
</PRE>At the moment, this also works, producing another 'ftpd' binary. We test
it the same way, and rejoice at its success.<BR>
<BR>
Finally, we dare to try it in 'box' mode, meaning the instrumentation
module will be used:
<PRE CLASS="verbatim">
  % make ftpd-clean
  % make ftpd INFERBOX=4
</PRE>After crunching for a while, it reports this error (you have to scroll
back a bit to see the right one):
<PRE CLASS="verbatim">
  ./ls_all.c:1338: Bug: Calling non-wild ioctl with too many args
</PRE>
This is an error from the 'box' module, complaining about what it
perceives to be a type error. If we investigate the named source
line, we see
<PRE CLASS="verbatim"><FONT COLOR=blue>
  if(ioctl(1, 0x5413, &amp; win) == 0 &amp;&amp; win.ws_col &gt; 0)
</FONT></PRE>
confirming that 'ioctl' is involved. Since the <TT>*_all.c</TT> files are the
output of our tool, and do not themselves <TT>#include</TT> any files, we can
simply search in this file for ioctl's declaration. We do so, and see
<PRE CLASS="verbatim"><FONT COLOR=blue>
  extern int ioctl(int __fd , unsigned long int __request , ...) ;
</FONT></PRE>
Hmmm... looks like it was declared to accept any number (&gt;=2) of args, so
this looks like a bug in the 'box' module; it should accept this code,
but it does not.<BR>
<BR>
The next step is to write a tiny C program which calls ioctl (see
test/small2/ioctl.c), and verify it fails the same way
<PRE CLASS="verbatim"><FONT COLOR=blue>
  % make scott/ioctl INFERBOX=4
  [...]
  ioctl.c:9: Bug: Calling non-wild ioctl with too many args
  [...]
</FONT></PRE>
Yep, same problem. Now we report this to George, since typically he's
much faster at identifying the problem, since he wrote the 'box' module.<BR>
<BR>
In the meantime (waiting for George to magically fix the problem), we
could temporarily comment-out the call so we can proceed to find other
bugs. Or, perhaps we change the ioctl call to instead call a wrapper
function (wrappers are defined in lib/ccuredlib.c, which gets linked into
the translated program).<BR>
<BR>
Eventually (see "make go INFERBOX=4") we'll get an executable. If it
runs correctly, celebration is in order. If not, it will usually fail
because of a failed runtime check (this one is from a test vector for
which go fails);
<PRE CLASS="verbatim"><FONT COLOR=blue>
  % make go INFERBOX=4
  % cd test/spec/099.go/src
  % ./go 5 4
  [...]
  array bug: index is 5980 (vs 5980)
  Failure: Ubound
  Abort
</FONT></PRE>
Tracking down the source of such failures is the most time-consuming
part of pushing a program through. Sometimes it's a bug in the
translator, in which case ideally a test case can be isolated for easy
diagnosis.<BR>
<BR>
Sometimes (more and more often) it's a bug in the original program (go
had 10 array bounds violation bugs at last count). In this case you
have to change the original code to fix the bug; this may be easy or
hard. If it's hard, try just surrounding the offending statement with
an explicit bounds check in an 'if' statement, so the program skips
the bad statements (that is what I did to cause all of the "array bug"
outputs in the "5 4" case above).<BR>
<BR>
<!--TOC section Writing Wrappers Manually-->

<H2 CLASS="section"><A NAME="htoc98">C.2</A>&nbsp;&nbsp;Writing Wrappers Manually</H2><!--SEC END -->
<A NAME="sec-manualwrappers"></A>
To interface with external code, you are usually better off using the automatic
wrapper system described in Chapter&nbsp;<A HREF="#ch-wrapper">8</A>. However if that isn't possible,
you'll need to write a wrapper directly in C:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Step 1:</B><DD CLASS="dd-description"> 
 Consult the name-mangling algorithm documented Section&nbsp;<A HREF="#sec-mangling">8.1</A>
 and <TT>ccuredlib.c</TT> to decode the required types of the parameters. <BR>
<BR>
<DT CLASS="dt-description"><B>Step 2:</B><DD CLASS="dd-description">
 Determine the semantics of the function being wrapped (e.g.,
 if it's a unix libc call, consult its man page). In particular,
 find out how memory passed via pointers is accessed (read and
 written).<BR>
<BR>
<DT CLASS="dt-description"><B>Step 3:</B><DD CLASS="dd-description">
 Write the wrapper, and make calls to the verification
 and query functions in the section in <TT>ccuredlib.c</TT> titled 
 &#8220;general-purpose&#8221;. If the function manipulates wild pointers, 
 be sure to update tags; conversely, if no wild pointers are 
 involved, there are no tags to worry about.
</DL>
Good examples to consult (in <TT>ccuredlib.c</TT>) include <TT>read_w</TT>,
<TT>fgets_ffw</TT>, <TT>stat_ww</TT>, <TT>strcat_www</TT>, <TT>memmove_www</TT>.<BR>
<BR>
<!--TOC section Apache Modules-->

<H2 CLASS="section"><A NAME="htoc99">C.3</A>&nbsp;&nbsp;Apache Modules</H2><!--SEC END -->

<EM>This section applies to CCured as of July 2002</EM><BR>
<BR>
<!--TOC subsection Introduction-->

<H3 CLASS="subsection"><A NAME="htoc100">C.3.1</A>&nbsp;&nbsp;Introduction</H3><!--SEC END -->

This writing assumes Apache 1.3.19 and an x86/Linux system. Apache is an
open source web server that has the ability to dynamically load third-party
modules. Modules can examine and alter HTTP requests and also examine and
alter the webserver replies. For example, a compression module might
examine the HTTP request to see if it contains the &#8220;Accept-Encoding:
gzip&#8221; tag. If it does it might alter the HTTP reply, replacing the text of
the webpage body with a compressed version of that text. Modules can be
configured (via a file called <TT>httpd.conf</TT>) so that their behavior is
limited to a certain location or directory. <BR>
<BR>
Apache modules share the same address space as the Apache webserver: no
software fault isolation is present. As a result, if the module crashes it
brings down that webserver (although apache is usually configured to
immediately spawn a new webserver thread to replace the fallen one). More
distressingly, a module with a security violation (for example, a
format-string bug) can allow remote users to gain shell access to the
webserver machine (one version of <TT>mod_php3</TT> features such a
vulnerability: CCured prevents that vulnerability). <BR>
<BR>
Apache modules are typically single files with a fairly standard naming
convention: <TT>mod_foo.c</TT> is the <TT>foo</TT> module, where <TT>foo</TT>
ranges over fairly descriptive keywords like <TT>gzip</TT>, <TT>random</TT>, <TT>urlcount</TT>, <TT>auth</TT> or <TT>layout</TT>. <TT>mod_foo.c</TT> almost invariable
contains a global data structure of type <TT>module</TT> with the C name <TT>foo_module</TT>. This data structure is a table of function pointers and entry
points. Once <TT>mod_foo.c</TT> has been compiled to the shared object <TT>mod_foo.so</TT>, Apache will dynamically load it and call the function
pointers listed in the <TT>foo_module</TT> structure at the appropriate time
(e.g., when a new request comes in). <BR>
<BR>
<!--TOC subsection Curing Apache Modules-->

<H3 CLASS="subsection"><A NAME="htoc101">C.3.2</A>&nbsp;&nbsp;Curing Apache Modules</H3><!--SEC END -->

Most Apache modules are of a relatively modest size and curing them is no
great chore. However, some annotation work must be done. Since the cured
module must interact with the non-cured Apache webserver, objects that are
passed between them must not change size. As a result, <TT>WILD</TT> and other
fat pointers cannot be introduced into such objects. Annotations must be
added to convince CCured that the module can be made safe without such
run-time checks. <BR>
<BR>
Imagine that you are trying to cure <TT>mod_urlcount.c</TT>. Take out your
favorite text editor and open up the file. Near the top you should find a
configuration record structure. Each module defines a separate
configuration record structure with a separate (non-exported) name. For
example, <TT>mod_urlcount</TT> has:
<PRE CLASS="verbatim"><FONT COLOR=blue>
typedef struct urlcount_config_rec {
    int         urlcount_default;
    CounterType urlcount_type;
    int         urlcount_auto_add;
    char       *urlcount_file;
} urlcount_config_rec;
</FONT></PRE>
Each module also contains functions that create, manipulate and merge such
configuration structures. This is the mechanism through which Apache modules
maintain global state. Each time Apache calls one of the function pointers
exported by the module, it passes along a way to get to the appropriate
configuration record. Since Apache does not know how the config structure
will be defined, it uses <TT>void</TT> pointers to describe the type. CCured
comes with a set of macros that instantiate those <TT>void *</TT>s on a
per-module basis. Add the line:
<PRE CLASS="verbatim"><FONT COLOR=blue>
NEW_MODULE_TYPE(urlcount, urlcount_config_rec)  // this is a macro
</FONT></PRE>
where the first parameter is the module suffix name and the second is the
type name of the configuration record. This macro declares a type named
<TT>module_urlcount</TT>. As mentioned earlier, each module exports a module
structure (full of function pointers). We must redeclare the module to take
advantage of the instantiated types. Change:
<PRE CLASS="verbatim"><FONT COLOR=blue>
module urlcount_module; // full of "void *"s
</FONT></PRE>
to
<PRE CLASS="verbatim"><FONT COLOR=blue>
module_urlcount urlcount_module; // uses "url_config_rec *", not "void *"
</FONT></PRE>
Now scroll down a bit and look for the word keyword <TT>void</TT>. Apache
modules often feature unnecessary casts to void. For example, <TT>mod_headers</TT> contains this function:
<PRE CLASS="verbatim"><FONT COLOR=blue>
static void *merge_headers_config(pool *p, void *basev, void *overridesv)
{
    headers_conf *a = (headers_conf *) ap_pcalloc(p, sizeof(headers_conf));
    headers_conf *base = (headers_conf *) basev, 
        *overrides = (headers_conf *) overridesv;
    a-&gt;headers = ap_append_arrays(p, base-&gt;headers, overrides-&gt;headers);
    return a;
}
</FONT></PRE>
Every <TT>void</TT> in this function really stands for <TT>headrs_conf</TT> (the
<TT>mod_headers</TT> version of <TT>urlcount_config_rec</TT>). Change it so
that the <TT>void</TT> types are no longer present: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
static headers_conf *
    merge_headers_config(pool *p, headers_conf *basev, headers_conf *overridesv)
{
    headers_conf *a = (headers_conf *) ap_pcalloc(p, sizeof(headers_conf));
    headers_conf *base = (headers_conf *) basev, 
        *overrides = (headers_conf *) overridesv;
    a-&gt;headers = ap_append_arrays(p, base-&gt;headers, overrides-&gt;headers);
    return a;
}
</FONT></PRE>
Repeat this process with all configuration functions that contain <TT>void</TT>. Now search for <TT>ap_get_module_config</TT>. It is a macro that
contains a (safe) cast to and from <TT>void *</TT> &ndash; it allows modules to
extract their configuration record from the global server state. For
example, <TT>mod_headers</TT> contains:
<PRE CLASS="verbatim"><FONT COLOR=blue>
headers_conf *serverconf =
    (headers_conf *) ap_get_module_config(s-&gt;module_config, &amp;headers_module);
</FONT></PRE>
Change this to:
<PRE CLASS="verbatim"><FONT COLOR=blue>
    headers_conf * serverconf;
    { __NOBOXBLOCK
    serverconf = ap_get_module_config(s-&gt;module_config, &amp;headers_module);
    } 
</FONT></PRE>
The <TT>__NOBOXBLOCK</TT> block keyword tells CCured to leave the block
alone: we are asserting that it is already safe. Modify every instance of
<TT>ap_get_module_config</TT> and <TT>ap_get_perdir_module_config</TT>
the same way. <BR>
<BR>
Now look for a datatype with the suffix <TT>entry</TT>. For example, <TT>mod_headers</TT> features:
<PRE CLASS="verbatim"><FONT COLOR=blue>
typedef struct {
    hdr_actions action;
    char *header;
    char *value;
} header_entry;
</FONT></PRE>
This marks a use of Apache's polymorphic (via <TT>void *</TT>) array routines. 
Insert the following macro declaration to tell CCured about this array
type:
<PRE CLASS="verbatim"><FONT COLOR=blue>
NEW_TABLE_TYPE(header_entry, header_entry)      // macro
</FONT></PRE>
This macro declares a new type, <TT>array_header_FOO</TT> (where <TT>FOO</TT>
is the first argument) that is a specialized version of the Apache-provided
type <TT>array_header</TT>. Other data structure (for example, the
configuration record structure) will contain <TT>array_header</TT>s. We
change them to use this new datatype. Change all declarations like:
<PRE CLASS="verbatim"><FONT COLOR=blue>
typedef struct {
    array_header *headers;
} headers_conf;
</FONT></PRE>
into:
<PRE CLASS="verbatim"><FONT COLOR=blue>
typedef struct {
    array_header_header_entry *headers;
} headers_conf;
</FONT></PRE>
Now search for every call to <TT>ap_make_array</TT>, <TT>ap_append_arrays</TT>, <TT>ap_push_array</TT> and append <TT>FOO</TT> (in our
running example, <TT>header_entry</TT>) to the name of each called function.
For example, change: 
<PRE CLASS="verbatim"><FONT COLOR=blue>
new = (header_entry *) ap_push_array(dirconf-&gt;headers);
</FONT></PRE>
into:
<PRE CLASS="verbatim"><FONT COLOR=blue>
new = (header_entry *) ap_push_array_header_entry(dirconf-&gt;headers);
</FONT></PRE>
Finally, surround all global table declarations with <TT>#pragma</TT>s that
tell CCured to leave them alone (because Apache must read them). Often
there are three such global tables per module. One is an array of <TT>struct const command_rec</TT>s, one is an array of <TT>struct const
handler_rec</TT>s, and the last is a <TT>module</TT>. Surround them all with <TT>#pragma</TT>s as follows:
<PRE CLASS="verbatim"><FONT COLOR=blue>
static const handler_rec mod_gzip_handlers[] =
{
    {"mod_gzip_handler", mod_gzip_handler},
    {CGI_MAGIC_TYPE,     mod_gzip_handler},
    {"cgi-script",       mod_gzip_handler},
    {"*",                mod_gzip_handler},
    {NULL}
};
</FONT></PRE>
becomes:
<PRE CLASS="verbatim"><FONT COLOR=blue>
#pragma box(off)
static const handler_rec mod_gzip_handlers[] =
{
    {"mod_gzip_handler", mod_gzip_handler},
    {CGI_MAGIC_TYPE,     mod_gzip_handler},
    {"cgi-script",       mod_gzip_handler},
    {"*",                mod_gzip_handler},
    {NULL}
};
#pragma box(on)
</FONT></PRE>
Finally, change the declaration of the global module to use the new
specialized type we created earlier. For example, change:
<PRE CLASS="verbatim"><FONT COLOR=blue>
module MODULE_VAR_EXPORT urlcount_module = {
</FONT></PRE>
into:
<PRE CLASS="verbatim"><FONT COLOR=blue>
module_urlcount MODULE_VAR_EXPORT urlcount_module = {
</FONT></PRE>
Voil. <BR>
<BR>
<!--TOC subsection Linking Apache Modules-->

<H3 CLASS="subsection"><A NAME="htoc102">C.3.3</A>&nbsp;&nbsp;Linking Apache Modules</H3><!--SEC END -->

Suppose you have just finished making the source modifications to <TT>mod_foo.c</TT>. Now you want to test it on Apache. Use CCured to compile it to
<TT>mod_foo.o</TT>. Make sure that there are no <TT>WILD</TT> pointers and that 
the sizes of types involved in the apache-module interface did not change. 
Now you must link it:
<PRE CLASS="verbatim">
    $ gcc -shared -o mod_foo.so mod_foo.o
    $ cp mod_foo.so /path/to/apache/bin/
</PRE>
Now go to your Apache binary directory and edit <TT>httpd.conf</TT>. Go to the
<TT>LoadModule</TT> section and add something appropriate according to the
documentation for your module. For example, <TT>mod_usertrack</TT> can be
configured by adding:
<PRE CLASS="verbatim">
LoadModule usertrack_module bin/mod_usertrack.so
CookieTracking On
CookieExpires "1 days"
</PRE>
Now try to start Apache:
<PRE CLASS="verbatim">
    $ ./apachectl stop
    $ ./apachectl start
    ./apachectl start: httpd started
</PRE>
If you see the &#8220;<TT>httpd started</TT>&#8221; message, it worked. If there were
messages about undefined symbols, you probably have to write a few
wrappers. For example, you might see:
<PRE CLASS="verbatim">
    ./httpd: undefined symbol strdup_ff: mod_foo cannot be loaded
</PRE>
In this case you must write a wrapper for <TT>strdup</TT> that uses <TT>FSEQ</TT>
pointers. Suppose you write it in <TT>wrapper_foo.c</TT> and compile that to
<TT>wrapper_foo.o</TT>. Now go back to the linking step: 
<PRE CLASS="verbatim">
    $ gcc -shared -o mod_foo.so mod_foo.o wrapper_foo.o
    $ cp mod_foo.so /path/to/apache/bin/
</PRE>
And try to start Apache again. Eventually this process converges (you can
skip ahead by using a utility like <TT>nm</TT> to list all of the undefined
symbols in <TT>mod_foo.so</TT> if you like) and your Apache module will be up
and running.<BR>
<BR>
If for some reasons your Apache module crashes at run-time, consider using
the underlying CIL <TT>&ndash;logcalls</TT> mechanism to track down the error
(Apache modules do not treat well with normal debuggers). Make sure that
the debugging comments are directed to <TT>syslog(3)</TT> rather than <TT>printf(3)</TT> or somesuch. <BR>
<BR>
As daunting as it may seem, it actually takes less than 30 minutes to Cure
an Apache module of average size and get it up and running. Some of that
time is spend reading the module's documentation so that it can be loaded
and tested correctly. Good luck!<BR>
<BR>
<!--TOC chapter Using the Regression Tester-->

<H1 CLASS="chapter"><A NAME="htoc103">Appendix&nbsp;D</A>&nbsp;&nbsp;Using the Regression Tester</H1><!--SEC END -->
<A NAME="ch-regtest"></A>
The regression tester is a program that allows you to do two things: 
<UL CLASS="itemize"><LI CLASS="li-itemize">
Run a list of shell commands and capture their standard and error output
 in a log file, and<BR>
<BR>
<LI CLASS="li-itemize">Analyze such log files and extract various information, among which the
 most important is which test cases have succeeded and which have failed. <BR>
<BR>
<LI CLASS="li-itemize">Compare results of two runs according to many parameters, such as
whether the test succeeded or not, how much time CCured took to process it,
how many different kinds of pointers were inferred and how fast is the
resulting program. 
</UL>
Since the running of the tests and the analysis of the output is separated
you can easily do things like compare the results on multiple runs, extract
various reports from a single output (like what tests have succeeded, which
have failed, plus such information split by test groups). You can also extract
some data from each test (such as the running time) and make simple reports. <BR>
<BR>
Test cases can have comments associated with them (such as reminders of why
it fails) and can be associated with zero or more test groups.<BR>
<BR>
<!--TOC section Running the regression-->

<H2 CLASS="section"><A NAME="htoc104">D.1</A>&nbsp;&nbsp;Running the regression</H2><!--SEC END -->
<A NAME="sec-regtest"></A>
The regression tester is implemented in Perl as "<TT>testsafec.pl</TT>", which in
turn contains simple wrappers for functions provided by the more generic
<TT>RegTest.pm</TT>.<BR>
<BR>
The regression tester uses relative paths so it must be run in the
 <TT>cil/test</TT> directory.<BR>
<BR>
The basic command for running the tests is "<TT>testsafec &ndash;run</TT>". This runs
all of the test cases, saving the log in the file "<TT>safec.log</TT>". Before
creating this file, it renames previous versions of this file as
"<TT>safec.log.&lt;n&gt;</TT>" where n is an integer starting from 1 to a maximum number
that is configurable.<BR>
<BR>
The following command line options are useful for running the tests (see
 "<TT>testsafec &ndash;help</TT>" for a complete list:
<PRE CLASS="verbatim">
 --one &lt;testname&gt;       : runs only the named test
 --gory                 : shows lots of details about the execution of the
                          test, such as the commands executed
 --dryrun               : only pretends to run the test. Useful to see what
                          would be run
 --log                  : select the base name of the log file (default
                          "safec.log")
 --logversions &lt;n&gt;      : keep logs up to version &lt;n&gt;. Default is 5.
 --noremake             : runs the commands without trying to remake the safec
                          compiler before each test. Useful if you want to 
                          work on the compiler while the tests are running
 --safecdebug           : uses the DEBUG version of the safec compiler and
                          uses the C compiler in debug mode. By default it
                          used the RELEASE version and the optimizing compiler.



 --group &lt;groupname&gt;    : adds all the tests in the named group to the list of 
                          tests to be run or to participate in the analysis of
                          the log. (Right now we have groups: apache,
                          bad, cil, box, infer.) If no such option is
                          specified then all tests are selected. Multiple such
                          options can be given and are cumulative. 
 --nogroup &lt;groupname&gt;  : excludes the tests in the named group from running
                          or from the analysis. Multiple such options can be
                          given and are cumulative. These options are
                          processed after all --group options have 
                          been processed. 

 --listtests            : list the tests that are enabled along with their
                          group membership. This is useful to find out what
                          tests and groups exist.

 --stoponerror          : stop at the first error
 --showoutput           : show the output on the console. Normally output is
                          saved in a file.  
</PRE>
 <!--TOC section Analyzing the results-->

<H2 CLASS="section"><A NAME="htoc105">D.2</A>&nbsp;&nbsp;Analyzing the results</H2><!--SEC END -->

The basic command for analyzing log files is "<TT>testsafec</TT>". This will
prompt the user to select one of the several log files that exist in the
current directory and then (by default) it will print a list of the failed
test cases, with a short (user provided) comment and the last error message
detected in the output for that test case.<BR>
<BR>
The following commands are useful during analysis:
<PRE CLASS="verbatim">
 --log                  : select the log file (see above)
 --group, --nogroup     : select groups (see above)
 --listtests            : list tests and groups (see above)
 --param=&lt;pnames&gt;       : show a report about the successes, with the columns
                          being the named parameters (separated by ,). Run
                          "testsafec --help" to see what parameters are
                          available. Use --param=ALL to make a report with 
                          all available parameters.
 --sort=&lt;pnames&gt;        : sorts the report by the given parameters. 
</PRE>
 Furthermore, the reports that are generated can be compared. To compare the
 results of two runs (whose logs are say &#8220;safec.log.1&#8221; and &#8220;safec.log.2&#8221;,
 run 
<PRE CLASS="verbatim">
 test/compare safec.log.2 safec.log.1 --group=slow
</PRE>
 This will compare the results of <TT>safec.log.2</TT> using as reference the
results in log <TT>safec.log.1</TT>.<BR>
<BR>
<!--TOC section Configuring the regression-->

<H2 CLASS="section"><A NAME="htoc106">D.3</A>&nbsp;&nbsp;Configuring the regression</H2><!--SEC END -->

For this you have to edit testsafec.pl. You will see a large section in the
 middle of the file containing lines like:
<PRE CLASS="verbatim">
\$TEST-&gt;add3Tests("test/array1");
</PRE>
 (check out the definition of <TT>add3Tests</TT> at the bottom of the file). This
 adds three tests named "<TT>test/array1-cil</TT>", "<TT>test/array1-box</TT>" and
 <TT>test/array1-inferbox</TT>", each one containing one command that invokes
 "<TT>make test/array1 ...</TT>", where <TT>...</TT> are appropriate parameters.<BR>
<BR>
A second optional string parameter to <TT>add2Tests</TT> is something to be added
 to the command line.<BR>
<BR>
A third optional array parameters is a list of patterns to be used in
scanning the output of the test cases. This is an advanced feature and you are
on your own. <BR>
<BR>
To add just one test do (as in the body of add3Tests):
<PRE CLASS="verbatim">
    $TEST-&gt;newTest(Name =&gt; "mytestname",
                   Dir =&gt; "..",
                   Cmd =&gt; "make something",
                   Enabled =&gt; 1,
                   Comm =&gt; "Print this along with the test name",
                   Group =&gt; ["cil", "othergroup"],
                   Patterns =&gt; \%mypatterns);
</PRE>Sometimes you might want to add just a comment or to add one group to a
 certain test. Use the following simple functions: 
<PRE CLASS="verbatim">
 $TEST-&gt;addGroups("mytestname", "group1", "group2");
 $TEST-&gt;addComment("mytestname", "Another line of comment");
</PRE>
 There are some wrappers defined at the end of testsafec.pl:
<PRE CLASS="verbatim">
   $TEST-&gt;add3BadComment("test/scope3", "missing prototype");
</PRE>
 (this one adds a comment and the group "bad" to all three test cases)
<PRE CLASS="verbatim">
  $TEST-&gt;addBadComment("li-box", "bug in box.ml");
</PRE>
 (the same but just for one test)
<PRE CLASS="verbatim">
  $TEST-&gt;enable("li-box", 0);   (disable the li-box test case)
</PRE>
 For more advanced customization, read the Perl code. It is fairly easy to
 understand, especially the testsafec.pl.<BR>
<BR>
<!--TOC section An alternative interface-->

<H2 CLASS="section"><A NAME="htoc107">D.4</A>&nbsp;&nbsp;An alternative interface</H2><!--SEC END -->

A simpler (but somewhat less powerful) interface to add tests is
provided by the <TT>smAddTest</TT> and <TT>smFailTest</TT> functions. <BR>
<BR>
Suppose you want to add a test which runs &#8220;<TT>make sometarget
someoptions</TT>&#8221;. Just say
<PRE CLASS="verbatim">
  smAddTest("sometarget someoptions");
</PRE>somewhere after <TT>smAddTest</TT> is defined.<BR>
<BR>
If at some point this test stops working for <TT>somereason</TT> (just a
human-readable one-line description of what's wrong), and you want the
regression tester to expect failure, change it to read
<PRE CLASS="verbatim">
  smFailTest("somereason", "sometarget someoptions");
</PRE>
There are also facilities for associating a diagnosis with a failure
(for example, if failure of a particular test is often due to a
known, fixable cause), and for running a shell script upon completion
of a test. See the <TT>scott/tprintf</TT> and <TT>scott/ptrkinds</TT> tests
for examples of each.<BR>
<BR>
Finally, there is a script called <TT>regrtest</TT> in the base <TT>cil</TT>
directory which runs <TT>testsafec.pl</TT> with a set of options which:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Stops on the first failure or unexpected success.
<LI CLASS="li-itemize">Prints all test output to the screen (in addition to the log).
<LI CLASS="li-itemize">Numbers tests, and allows you to skip to a particular test.
<LI CLASS="li-itemize">Runs a mix of tests designed to maximize both speed and
 coverage. It runs in about 1 minute on a fast (1GHz) machine,
 and is made up mostly of micro-tests isolated from previous
 bugs in CCured.
</UL>
To use this, just say &#8220;<TT>./regrtest</TT>&#8221; in the <TT>cil</TT> directory.
It accepts the &#8220;<TT>-help</TT>&#8221; option.<BR>
<BR>
<!--TOC section The Automated Regression Tester-->

<H2 CLASS="section"><A NAME="htoc108">D.5</A>&nbsp;&nbsp;The Automated Regression Tester</H2><!--SEC END -->

Every time you commit a change to the CIL or CCURED repositories you trigger
two regression tests. The first is called the QUICK test and it takes about 5
minutes to complete and you should be receiving email with the results. If you
don't then it must be that the automated regression tester is not running or
it has encountered a problem that it cannot fix. <BR>
<BR>
The automated regression tester is implemented as a script <TT>mk-reports.pl</TT>
and lives in the home directory of user <TT>regtest</TT> on <TT>manju</TT>. To see
whether the tester is running run <TT>ps -Af</TT> and look for a line <TT>perl
mk-reports.pl -daemon</TT>. If you do not see any let me know. <BR>
<BR>
Here are the operations that are performed by the tester:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
A new directory is created under <TT>/home/regtest/cil.nightly</TT>. The name
of the directory encodes the time of the commit (e.g.
<TT>2001-12-07_17_50_-0800.dir</TT> is the directory for the commit at 17:50 on
07/12/2001 in the timezone that is 8 hours behind UTC). 
<LI CLASS="li-enumerate">A complete copy of CIL and CCURED is checked out in that directory and
<TT>make setup</TT> is run in there. 
<LI CLASS="li-enumerate">Then in the <TT>test</TT> directory we run <TT>testsafec</TT> but only on the
groups that are known to terminate quickly. This run takes about 3 minutes. A
copy of the <TT>safec.log</TT> file generated is saved as <TT>/home/regtest/cil.nightly/2001-12-07_17_50_-0800.safec.quick.log</TT>.
<LI CLASS="li-enumerate">Then we run <TT>testsafec</TT> again to produce a report with all available
parameters. This report is saved as
<TT>/home/regtest/cil.nightly/2001-12-07_17_50_-0800.report.quick.txt</TT>. In the
event that any of the previous steps fail this file will be created but with
zero length.
<LI CLASS="li-enumerate">Then we compare this report both with the previous commit and with a
reference report and a message is sent to the user who performed the commit.
This report is also saved as <TT>/home/regtest/cil.nightly/2001-12-07_17_50_-0800.msg.quick.txt</TT>. 
</OL>
The automated regression tester should be running continuously and monitoring
the commits every 60 seconds. However, between midnight and 6am it alternates
between the QUICK run described above and a SLOW run that processes those
tests that the QUICK run does not do. A SLOW run might take anywhere between
15 and 30 minutes. The SLOW report is generated using the same checked-out
repository as the QUICK run. Results of the regression test, reports and
messages for the SLOW run are saved in similar files as for the QUICK run
except that the word &#8220;quick&#8221; is replaced by &#8220;slow&#8221; in the name of those
files. <BR>
<BR>
If the QUICK report is zero-length then the SLOW run is not performed. This
is at the moment the only way to prevent the SLOW run from happening.<BR>
<BR>
If both the QUICK and SLOW reports exist then the directory containing the
distribution can be deleted. <BR>
<BR>
The reference report is in
<TT>/home/regtest/cil.nightly/reference.report.quick.txt</TT>. You can edit it
manually to change the reference for the messages but please do so only to
improve it.<BR>
<BR>
You can start <TT>regtest</TT> manually (though this shouldn't be necessary):
&#8220;<TT>sudo become-regtest</TT>&#8221; (only certain users can do this), then
&#8220;<TT>perl mk-reports.pl</TT>&#8221;.<BR>
<BR>
For each of your commit, a copy of the repository is checked out. This takes
about 150Mb on <TT>manju</TT> and 30 minutes worth of regression testing. If you
want to disable the SLOW run (because, for example, you made a silly mistake
and are committing a fix right away) you have to manually delete the contents
(<B>not the file</B>) of the corresponding <TT>report.quick</TT>. <BR>
<BR>
<!--TOC chapter Debugging support-->

<H1 CLASS="chapter"><A NAME="htoc109">Appendix&nbsp;E</A>&nbsp;&nbsp;Debugging support</H1><!--SEC END -->
<A NAME="sec-debugger"></A>
Most of the time we debug our code using the Errormsg module along with the
pretty printer. But if you want to use the Ocaml debugger here is an easy way
to do it. Say that you want to debug the invocation of CCured that arises out
of the following command:
<PRE CLASS="verbatim">
ccured --separate -c hello.c 
</PRE>
 You must follow the installation <A HREF="../ccured/setup.html">instructions</A>
to install the Elist support files for ocaml and to extend your .emacs
appropriately. Then from within Emacs you do
<PRE CLASS="verbatim">
ALT-X my-camldebug
</PRE>
 This will ask you for the command to use for running the Ocaml debugger
(initially the default will be &#8220;ocamldebug&#8221; or the last command you
introduced). You use the following command:
<PRE CLASS="verbatim">
ccured --ocamldebug -c hello.c 
</PRE>
 This will run <TT>ccured</TT> as usual and invoke the Ocaml debugger when the cilly
engine starts. The advantage of this way of invoking the debugger is that the
directory search paths are set automatically and the right set or arguments is
passed to the debugger. <BR>
<BR>
For the <TT>make</TT>-based interface to our regression tests you can pass the
argument <TT>OCAMLDEBUG=1</TT> to <TT>make</TT> to achieve the same effect. <BR>
<BR>
<!--TOC chapter Experimental Features-->

<H1 CLASS="chapter"><A NAME="htoc110">Appendix&nbsp;F</A>&nbsp;&nbsp;Experimental Features</H1><!--SEC END -->

To print the annotations that are needed for separate compilation, add
 <TT>&ndash;annout=foo.txt</TT>. Information about these annotations will be printed in
 that file. <BR>
<BR>
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
