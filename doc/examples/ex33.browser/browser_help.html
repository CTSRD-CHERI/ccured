<html>
<body>

<h1 align="center"> The CCured browser </h1>

<p>&nbsp;The <a href="http://www.cs.berkeley.edu/~necula/ccured">CCured</a> browser 
is an HTML-based user interface that visualizes the pointer-kinds inferred by 
CCured for each pointer type in your program, along with the reasons why CCured 
chose the particular kinds. The browser information is generated by CCured after 
type inference and consists of annotated source files (split into small HTML 
fragments) and inference graph data (also split into HTML fragments). These 
files, along with a small JavaScript program, are then read using a web browser.&nbsp;
</p>
<h3>Invocation:</h3>
<ul>
  <li>Pass the <b><font face="Courier New">--emitbrowser</font></b> parameter 
  when you invoke the <font face="Courier New">ccured</font> application. 
  Additionally you might pass the following arguments to control the generation 
  of the browser<ul>
    <li><b><font face="Courier New">--browserSourceFileSize=n</font></b> where 
    &quot;n&quot; is a number that controls how big each source file fragment is (it is 
    roughly the number of globals, instructions and statements in the file)</li>
    <li><b><font face="Courier New">--browserNodeFileSize=n</font></b> where &quot;n&quot; 
    is the number of nodes to place in a data file.</li>
  </ul>
  <p>After CCured finishes processing your file (say foo.c) you will see that it 
  has generated a subdirectory <font face="Courier New">foo.browser</font> in 
  the same directory with the result of curing. This directory contains the 
  following files:<ul>
    <li>index.html this is the top level file that loads the JavaScript code and 
    defines the frames. Generated from template in cil/lib/browser_index.html by 
    code in src/ccured/ptrnode.ml</li>
    <li>source__0.html, ... these are the fragments containing the marked-up 
    source code. The size of one fragment is controlled by the --browserSourceFileSize 
    parameter.</li>
    <li>node__0.html, ... these are the files containing the data about pointer 
    kinds (also referred to as <i>nodes</i>). This information is encoded as a 
    series of calls to Javascript functions defined in browser_code.js (see 
    below). The size of one fragment is controlled by the --browserNodeFileSize 
    parameter.</li>
    <li>edge__0.html, ... these are the files containing the data about casts 
    between pointers (also referred to as <i>edges</i>). The size of one 
    fragment is also controlled by the --browserNodeFileSize parameter.</li>
    <li>form.html this is the definition of the form and this also contains some 
    initialization code. For example this file contains the data about the total 
    number of nodes, edges, bad casts, and also information about the source 
    fragment in which each node is defined. This is generated from template in 
    cil/lib/browser_form.html.</li>
    <li>globals.html contains information about all the globals defined in your 
    program.</li>
    <li>types.html contains information about all the types defined in your 
    program.</li>
    <li>styles.css this defines the colors for the different pointer kinds. 
    Copied from the cil/lib directory.</li>
    <li>browser_code.js this file contains the&nbsp; common Javascript code.</li>
  </ul>
  </li>
  <li>After you have generated the browser files you simply direct a browser to 
  the index.html file. The following browsers have been tested (since the 
  browser is implemented in Javascript it is sensitive to  differences among 
  various implementations)<ul>
    <li>Internet Explorer 6.0 on Windows. </li>
    <li>Netscape Navigator 4.11 on Linux. The Javascript implementation in 
    browser is 
    badly broken. Use Mozilla or maybe a newer version of Navigator.&nbsp; </li>
    <li>Mozilla 1.0 on Linux.</li>
  </ul>
  </li>
</ul>
<h3>Usage:</h3>
<p>When the browser first opens the index.html file it will load the first 
source fragment and the form. You will see that some pointers are marked-up in 
the source file with a numerical subscript and a color. The subscript gives a 
unique identifier for each pointer (also referred to as a node). The color 
depends on the pointer kind as follows:</p>
<ul>
  <li>Black for SAFE nodes</li>
  <li><font color="#0000FF">Blue</font> for FSEQ nodes.</li>
  <li><font color="#008000">Green</font> for SEQ nodes.</li>
  <li><font color="#800080">Magenta</font> for RTTI nodes.</li>
  <li><font color="#FF0000">Red</font> for WILD nodes.</li>
</ul>
<p>Each occurrence of the pointer type constructor is a node. However, only
the following occurrences are marked-up:
 <ul>
    <li> those whose pointer kind is not SAFE, and
    <li> those whose type is void *, and<li> those whose base type contains non-SAFE pointers.
 </ul>

Additionally, 
there are nodes associated with the address-of variables and structure and 
pointer fields. These are shown using the &amp; symbol right before the final 
semicolon terminating a variable or field declaration. </p>
<p>When you click on a node the following things happen:</p>
<ul>
  <li>The source file fragment where the node is defined is loaded in the source 
  window (if not already there; this might take a little bit)</li>
  <li>A marker <img border="0" src="bullet.gif" width="14" height="11"> is shown 
  in the source file immediately before the first definition for that node<ul>
    <li>Many functions have both a prototype and a definition. They share nodes.
    </li>
    <li>In a cast to a pointer type the node is shared with the type of the 
    destination of the cast. For example, in code like &quot;<font face="Courier New">x 
    = (int *)y</font>;&quot;&nbsp; the node for the pointer type is shared with the 
    one in the declaration of x. </li>
  </ul>
  </li>
  <li>In the node information pane you will see some information&nbsp; about the 
  node:<ul>
    <li>The kind of the node along with an explanation why the node has that 
    kind (see below for details on explanations).</li>
    <li>&nbsp;A number of flags that are set for the node along with 
    explanations why they are set. </li>
    <li>Loading this information might take a bit depending on the size of your 
    program.</li>
  </ul>
  </li>
</ul>
<p>The <b>form</b> provides the following buttons:</p>
<ul>
  <li>&quot;Current file fragment&quot; shows the current source file fragment. You can 
  choose to load another fragment. </li>
  <li>&quot;Select node&quot;. In this input box you can choose to display a given node. 
  This acts as if you had clicked on the hyperlink for the node in the source 
  window.</li>
  <li>&quot;Save current node&quot;. If a node is current, this will copy its information 
  in a new window (thus allowing you to save the information while you browse 
  other nodes)</li>
  <li>&quot;Show bad casts&quot;. This will give a summary of the bad casts in the 
  program.</li>
  <li>&quot;Show globals&quot;. This will show an index of all of the globals defined in 
  your program.</li>
  <li>&quot;Show types&quot;. This will show an index of all of the types defined in your 
  program.</li>
  <li>&quot;Show cured file&quot;. This will open a new window showing the cured file. <b>
  WARNING: the cured file is not split into fragments so you might bring your 
  browser or network connection to its knees by doing this on large files. </b>
  </li>
</ul>
<h3>Explanations:</h3>
<p>CCured decides what pointer kinds to assign to each pointer based on the way 
that pointer (or any pointer it is related to) is used. There are several 
operations that trigger special pointer kinds. These are shown at the start of 
an explanation:</p>
<ul>
  <li>Bad casts (gives rise to WILD pointers)</li>
  <li>Pointer arithmetic (gives rise to SEQ pointers, if not already WILD)</li>
  <li>Positive pointer arithmetic (gives rise to FSEQ pointers, if not already 
  WILD or SEQ) </li>
</ul>
<p>Pointer kinds are then propagated across assignments, function argument and 
return passing and casts (all of these are generically called casts).&nbsp; WILD 
propagates in both directions but SEQ and FSEQ only from the target to the 
source of the cast. You will see that the explanation contains a chain of such 
casts, each with a location. </p>
<h4>Pointer compatibility</h4>
<p>&nbsp;In addition to casts CCured propagates pointer kind information (and 
flags) to all pointers that are required to be compatible. For example, in a 
cast from the pointer type <font face="Courier New">T1 *</font> to
<font face="Courier New">T2 </font>*, CCured requires that T1 and T2 be 
compatible, in which case all the pointer kinds in T1 are propagated to the 
corresponding pointers in T2 and vice-versa.&nbsp; </p>
<h4>Void* equivalence classes </h4>
<p>CCured has special handling for void* equivalence classes. Each occurrence of 
a void* type is taken as a hint that this is a placeholder (a type variable) 
that must be replaced by any other type that would make CCured inference work. 
This in a chain of casts int * to void* to int *, CCured will behave as if the 
middle type was int * as well. However, if CCured sees a sequence of casts like 
int * to void * to int * *, it will make all of the types involved WILD and the 
explanation will be that the two extremities of the sequence are incompatible.&nbsp;&nbsp;
</p>
<h3>Scalability and loading on demand of explanations:</h3>
<p>CCured has been used on programs as large as 1 million lines of code. The 
annotated source file for such a file is about 60Mb and the Javascript program 
that encodes the graph data is about 15Mb. This is overwhelming for all 
browsers. To solve this problem CCured splits both the source files and the 
graph data files into fragments that are loaded dynamically. It turns out that 
Javascript is not well suited for this dynamic loading of files. Our 
implementation will detect when new data must be loaded and will issue the 
necessary commands. However, there is no way to wait for the loading to 
complete. Instead, we continue the work (e.g. of displaying explanations) and 
when we are done we schedule another attempt after the files have been loaded. 
Because of this you will see that while constructing the explanations they 
appear initially with a lot of&nbsp; &quot;loading&quot; values, which slowly get filled 
in. In a large file this might take several iterations. Once a data 
file has been loaded it will not need to be reloaded again.&nbsp;&nbsp;&nbsp;
</p>
<hr>
<p>For comments please send email to <a href="mailto:necula@cs.berkeley.edu">
necula@cs.berkeley.edu</a>. Last changed on
<!--webbot bot="Timestamp" s-type="EDITED" s-format="%m/%d/%Y %H:%M:%S %Z" startspan -->08/23/2002 16:44:11 -0700<!--webbot bot="Timestamp" endspan i-checksum="38360" --></p>

</body>
</html>